-- MySQL dump 10.13  Distrib 8.0.24, for Linux (x86_64)
--
-- Host: localhost    Database: hah_home
-- ------------------------------------------------------
-- Server version	8.0.24

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `id` bigint NOT NULL COMMENT 'id',
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '内容',
  `first_Picture` longtext CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '首图',
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标签/原创/转载/引用',
  `views` int DEFAULT NULL COMMENT '浏览量',
  `commentabled` bit(1) DEFAULT NULL COMMENT '是否可评论',
  `published` bit(1) DEFAULT NULL COMMENT '是否发表',
  `recommendned` bit(1) DEFAULT NULL COMMENT '是否推荐',
  `createTime` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建时间',
  `editTime` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改时间',
  `user_id` bigint DEFAULT NULL COMMENT 'userid',
  `description` longtext CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '博客描述',
  `user_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT 'userName',
  `comment_count` int DEFAULT NULL COMMENT '评论数量',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '类型:0普通博客1友联2关于我',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `t_blog_t_user` (`user_id`) USING BTREE,
  CONSTRAINT `t_blog_t_user` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (1673367738707361794,'Linux学习笔记','VIM有三种模式：\r\n\r\n	1.一般模式：进行基本的复制粘贴和删除\r\n		w：	一个词，移动到下一个词开\r\n		b：	移动到上一个词的词头\r\n		e：	移动到当前词结尾\r\n		gg/H：	移动到页头\r\n		G/L：	移动到页尾\r\n		nG：	跳转到第n行         可通过命令模式：set nu/set nonu开启或关闭行号\r\n		$：	行尾\r\n		^：	行首\r\n		u:	撤销操作\r\n		ctrl+r	恢复撤销\r\n\r\n			复制：yy(复制换行符)     复制n行：nyy     \r\n		        从光标复制到行结尾：y$     yy$(复制换行符)     复制到行开头：y^     yy^(复制换行符)\r\n			复制一个词：yw\r\n			粘贴：p	     粘贴n次：np\r\n			删除行：dd   删除n行：ndd	删除当前词：dw        d$        d^\r\n			单个字符的剪切：x\r\n			每次剪切光标前一个字符：大写的X\r\n			替换光标位置字符：r\r\n			向后替换：大写R	\r\n\r\n	2.命令模式：按下:\r\n			eg：	保存	：w			按下ESC退出到一般模式\r\n			    退出编辑    ：q\r\n			    强制退出	：q!\r\n			    保存退出	：wq\r\n			    可通过命令模式：set nu/set nonu开启或关闭行号\r\n		    按下/\r\n			eg：查找文件内某个单词:		/xxx\r\n			    替换光标当前行的第一个匹配到的单词：	s/old/new\r\n			    替换光标当前行的所有匹配到的单词：		s/old/new/g\r\n			    替换光标当前行的第一个匹配到的单词：	%s/old/new\r\n			    替换文件中所有匹配到的单词：	%s/old/new/g\r\n			    n：移动到下一个匹配到的单词\r\n			    N：移动到上一个匹配到的单词\r\n			\r\n	3.编辑模式：i：光标前  a：光标后   o：向下换行\r\n		    I：行首    A：行尾     O：向上换行\r\n			\r\n				\r\nLinux终端基础指令：\r\n	\r\n	进入路径：cd xx/\r\n	列出文件：ls\r\n	列出隐藏文件： ls -a\r\n	列出软链接的原目录：ls -P\r\n	分行列出：ls -l 路径名\r\n	分行列出并筛选：ls -l xxx | grep xxx\r\n	上一级目录：..\r\n	当前目录：.\r\n	查看文件总数：ll\r\n	换页：ctrl + l  /  clear\r\n	清空：reset\r\n	获取指令的帮助文档：man 指令\r\n	获取指令帮助简化版：help 指令(只适用内嵌指令)\r\n	查看指令类型：type 指令\r\n	一般指令的帮助简化版：指令 --help\r\n	代码补全：输入一些字母后按下tab：eg：vim stu(此时按下tab键) stu会自动补全成为study.txt\r\n\r\n	查看是否可通信：ping ip         \r\n	停止ping：ctrl+c\r\n	查看本机网络配置：ifconfig\r\n	修改当前主机网络配置为静态配置网络ip地址：在～目录下：vim /etc/sysconfig/network-scripts/ifcfg-ens33\r\n	查看当前主机名：hostname/hostnamectl\r\n	立即更改当前主机名：hostnamectl set-hostname newName	\r\n	查看服务：ls /usr/bin/systemd/system\r\n	操作服务：systemctl start/stop/restart/status/enable(启用开机自启动)/disable(禁用开机自启动) 服务名\r\n	\r\n	可在终端敲setup，打开服务设置，选择服务的开机自启动选项\r\n	目前已做服务操作，关闭了network，而选择打开了centos建议的NetworkManager\r\n	\r\n	更换运行级别：init 3/5\r\n		      ctrl +  alt + F1:切换到运行级别5\r\n		      ctrl +  alt + F2-F6:切换到运行级别3\r\n	列出所有\r\n	\r\n	\r\n	windows使用远程登陆访问该主机：使用命令ssh root@redis100/ip      或者使用工具Xshell\r\n	windows使用远程传输文件：      使用命令scp			 或者使用工具Xftp\r\n\r\n	关机操作：shutdown		一分钟后关机\r\n		  shutdown n		n分钟后关机\r\n		  shutdown now		马上关机\r\n		  shutdown -h now	马上关机\r\n		  shutdown min:sec\r\n		  shutdown -c		取消关机\r\n		  sync			将数据由内存同步到硬盘中(shutdown操作也会默认执行该命令)\r\n		  shutdown -r now	重启\r\n		  reboot		重启\r\n		  halt			停机\r\n\r\n\r\n\r\n文件目录类：（勤用man和tab）\r\n	目录操作命令：\r\n		pwd 		打印出当前目录所在的绝对路径\r\n		cd /目录	切换目录(绝对路径，以/开头，表示从根目录开始)\r\n		cd 目录		进入目录\r\n		cd ../目录	相对路径\r\n		cd -		返回上一条命令所在目录\r\n		cd .. 		返回上一级目录\r\n		cd(后面啥也没有)进入当前登录用户所在的主目录：root用户为root（~），其他用户为/home/zyj\r\n		\r\n		s		打印出当前目录的文件\r\n		ls -a		打印所有文件（包括隐藏文件，用.开头的文件）\r\n		ls -l == ll	分行打印详细信息\r\n		ls -lh		显示当前目录存储总用量\r\n		\r\n		mkdir 目录	在当前目录下创建目录(空格隔开创建多个目录)makedirect\r\n		mkdir /目录	在根目录下创建目录\r\n		mkdir -p 目录	在当前目录嵌套创建目录\r\n		rmdir 目录	删除当前目录下的目录(removedirect)\r\n		rmdir -p 目录 	在当前目录嵌套删除目录\r\n\r\n	文件操作命令：\r\n		touch 文件	创建文件(默认为txt文件)\r\n		\r\n		cp 文件 目录	将指定文件复制到指定目录（覆盖会有提示）copy\r\n		\\cp 文件 目录	覆盖不会提示\r\n		cp -r 文件 目录	递归的复制整个文件夹（包括里面的子文件和子文件夹，一般使用的是加了-r参数的cp）\r\n		 \r\n		rm 文件		删除文件(有提示确认)remove\r\n		rm -f 文件	没有提示确认\r\n		rm -r 目录	递归删除当前目录下的所有目录文件\r\n		rm -rf 目录	递归强制删除目录下所有文件\r\n		rm -f ./*	删除当前目录下的所有文件\r\n		\r\n		mv 文件 目录		将指定文件移动到指定目录(move)\r\n	    	mv 文件 目录/文件名	移动文件后做重命名\r\n		\r\n		cat 文件	查看文件(catch)		无快捷键，只是打印出来\r\n		cat -n 文件	查看文件(显示行号)\r\n		more 文件	分页查看文件		有部分快捷键\r\n		less 文件	分页查看文件		有很多快捷键，快捷键和vim一般模式和命令模式差不多(功能最强大)\r\n							eg：/xxx			查找（按n向下检索，按N向上检索）\r\n							    f/空格/pagedown		向下翻页\r\n							    b/pageup			向上翻页\r\n							    enter			往下翻页一行\r\n		\r\n	其它命令：\r\n		echo xxx/“xxx”	输出字符串到控制台\r\n		echo -e xxx	输出到控制台(可以使用转义字符\\)\r\n		字符串 > 文件	用字符串的值覆盖文件\r\n		字符串 >> 文件	把字符串的值追加到文件\r\n		\r\n		head 文件	查看文件的前十行\r\n		head -n x 文件	查看文件的前x行\r\n		tail 文件	查看文件的后十行\r\n		tail -n x 文件	查看文件的后十行\r\n		tail -f 文件	实时追踪该文档的所有更新(若文件用vim做了更改重新保存，那么监控将追踪不到，因为文件索引变了，文件位置变了)\r\n							ctrl + c	结束跟踪\r\n							ctrl + s	暂停跟踪\r\n							ctrl + q	继续跟踪\r\n	\r\n\r\n		ln -s 文件或目录 软链接目录/软链接名(常用)	给原文件或目录创建一个软链接(相当于Windows的快捷方式)不同的文件，多个inode，原文件失效软链接失效\r\n		ln 文件 硬链接目录/硬链接名			给原文件常见一个硬链接(不能创建目录)同一个inode，多个名字，相互独立，原文件失效硬链接也能访问\r\n								注意：删除软链接时，rm -rf xxx时不能加/,否则删除的将会是原目录下的东西\r\n		\r\n		history		查看过去使用过的命令\r\n		history n 	查看过去使用过的最近n条命令\r\n		history -c	清除记录\r\n		! 命令行号	执行这条历史命令\r\n		\r\n\r\n\r\n\r\n时间日期类命令：\r\n		date				获取当前时间\r\n		date +%Y			获取当前年份\r\n		date +%y			获取当前年份简写2022-> 22\r\n		date +%s			获取时间戳(单位：秒)\r\n		date +%m/%d			eg: date +%Y-%m-%d-%H:%M:%S     /     date \"+%Y-%m-%d %H:%M:%S\"\r\n		date -d \"1 days ago\"		获取一天后的时间\r\n		date -d \"-1 hours ago\" 		获取一个小时前的时间\r\n		date -s \"2027-06-19 20:52:06\"	将系统时间设置为这么多\r\n		ntpdate				重新联网同步时间\r\n		cal 				查看当月日历\r\n		cal -y				查看当年日历\r\n		date -d @时间戳	获取时间戳对应的时间\r\n\r\n\r\n用户权限类：\r\n	用户(组)权限类：（add:添加、del:删除、mod:修改）\r\n		useradd					添加用户\r\n		useradd -d /home/主文件夹名 用户名	为新用户的主文件夹更改名字\r\n		passwd 用户名				给该用户更改密码\r\n		id 用户名				查看有无该用户打印用户信息\r\n		cat /etc/passwd				查看所有用户(里面有很多系统用户，用于专门执行相应的系统指令)\r\n		su 用户名				切换用户(switch user)\r\n		su - 用户名(root省略)	当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境(包括 PATH 变量、MAIL 变量等)，使用 - 选项可省略用户名，默认会切换为 root 用户\r\n		exit					切换用户后使用，可回退到上一个登录的用户\r\n		who am i/whoami				查看当前是哪个用户\r\n		\r\n		userdel 				删除用户(只删除用户，不删除对应的主文件夹)\r\n		userdel -r 用户名			删除用户(包括对应的主文件夹)\r\n		\r\n		vim /etc/sudoers			更改可以拥有sudo权限的用户的配置文件\r\n		sudo 命令				让当前非root用户暂时获得root权限\r\n		\r\n		groupadd				添加组\r\n		gpasswd				给组添加密码\r\n		gpasswd -d 用户 组名				从改组中删除该用户\r\n		usermod -g 组名 用户名			修改用户所属组\r\n		usermod -l 新用户名 用户名		修改用户的用户名\r\n		groupmod -n 新组名 旧组名		修改组的名字\r\n		groupdel 组名				删除组\r\n		\r\n		useradd -g 组名 用户名			添加新用户到组\r\n\r\n\r\n		批量添加删除用户：\r\n		1.写好user.info文件，用户分行写，格式为： network01::601:3::/home/network01:/bin/bash\r\n																network02::602:3::/home/network02:/bin/bash\r\n		2.写好passwd.info文件，分行写，格式为：用户名:密码 --> network01:network\r\n		3.newusers < user.info\r\n		4.pwunconv	取消 shadow passwd 功能，以便批量导入密码\r\n		5.chpasswd < passwd.info\r\n		6.pwconv	将密码写入影子文件 shadow 中\r\n		(以用户 network01 为例，测试其登录后是否显示正常： su  network01 。测试结果发现， 切换用户显示 bash-4.2 异常，其原因为：该用户 network01 缺少三个隐藏文件。\r\n		解决办法：输入 exit，回到 root 用户，拷贝三个隐藏文件到期家目录下，命令如下： cp    /etc/skel/.bash*    /home/network01\r\n		重新输入命令 su network01 切换到 network01，此时显示正常)\r\n\r\n	文件权限类：\r\n		（UGO:0-9位编号：\r\n		0:文件类型、\r\n		123：U：User代表属主，该文件的创建者拥有的权限、\r\n		456：G：Group代表属组，所有者的同组用户拥有的权限、\r\n		789：O：other其他用户的权限）\r\n		rwx：r	可读\r\n		     w	可写\r\n		     x	可操作\r\n		\r\n		chmod [{ugoa}{+-=}{rwx}] 文件名		更改文件的权限\r\n		chmod 777				更改文件权限（根据UGO对应的二进制数开放权限）\r\n							eg：777  第一个7代表二进制数111，代表U位置上rwx权限均有，1代表有权限，0代表无权限，再转换成二进制数\r\n		chmod -R 777				递归更改该目录和目录下所有目录及文件的权限\r\n		\r\n		chown 用户 文件				更改文件的属主\r\n		chown -R				递归更改\r\n		chgrp [-R]  组 文件			更改文件的属组\r\n\r\n\r\n\r\n		\r\n		\r\n搜索查找类命令：\r\n		find 查找目录(未指定默认为当前目录) -name 检索词	在指定目录下查找名字有检索词的文件\r\n		find 查找目录 -user 用户名				在指定目录下查找属主是该用户的文件\r\n		find 查找目录 -size +10M/-10M				在指定目录下查找大于/小于10M的文件\r\n		\r\n		locate 目录/文件		查找包含检索词的目录或文件(存放在数据库中，检索更迅速)\r\n		updatedb	 		更新locate数据库（默认一天才更新一次，故可能查找不准确，要更新）\r\n		which 命令			查找指定命令在哪个目录下\r\n		\r\n		grep (-n) 查找内容 源文件	查找指定文件中拥有的查找内容（-n：显示匹配行及行号）\r\n		|（管道符）			将前一个命令的处理结果交给后面的命令处理		grep xxx | grep -v grep	去掉包含grep的语句\r\n						eg：ls | grep -n test\r\n		\r\n		wc				wordcount的简写，用于统计某文件某指令结果的行数、单词数、字节大小\r\n						eg：wc study.txt          grep -n test study.txt | wc\r\n\r\n\r\n\r\n压缩解压命令：\r\n		gzip 文件	压缩文件（只能压缩文件，不能压缩目录、不保留原来的文件、同时多个文件会产生多个压缩包）\r\n		gunzip 文件.gz	解压文件\r\n		ls -lh		分行列出所有文件目录（并列出总用量）\r\n		\r\n		zip 文件					压缩文件（正常压缩文件和目录，不影响原文件目录）\r\n		zip -r 压缩成文件的名字 要压缩的目录		递归压缩目录并命名\r\n		unzip xxx.zip					解压文件\r\n		unzip -d 目标目录 xxx.zip			解压文件到指定目录\r\n		\r\n		tar [选项] XXX.tar.gz		打包/解包文件目录\r\n			-c	产生.tar打包文件\r\n			-v	显示详细压缩信息\r\n			-f	指定压缩后的文件名		eg：tar -zcvf 指定的文件名.tar.gz [要打包的所有文件或目录，用空格隔开]\r\n			-z	打包的同时压缩（使用gzip）	    tar -zxvf xxx.tar.gz -C /解压到的目录\r\n			-x	解包.tar文件\r\n			-C	解压到指定目录\r\n			\r\n\r\n		\r\n磁盘管理类命令：\r\n		yum install tree		安装tree插件\r\n		tree 目录			查看指定目录的树状结构信息（包括子目录文件）\r\n		ls -lh				只能看到可显示出来的目录文件的总用量，不全面\r\n		du [选项] 目录/文件		查看指定目录/文件的磁盘占用情况（显示目录下每个子目录的使用情况）(disk usage)\r\n			-a 		不仅查看子目录大小，还要包括文件\r\n			-h 		以人们更易阅读的GB、MB、KB显示，原来为B（human readen）			\r\n			-c		显示所有的文件和子目录大小后，显示总和(多余的命令，和.目录的大小一致)	eg：du -ah / du -sh / du --max-depth=1 -ah\r\n			-s 		只显示总和\r\n			--max-depth=n	指定统计子目录的深度为第n层(所有选项只限制打印出来的内容，不影响总和)\r\n		\r\n		df -h		显示磁盘占用情况（总容量、已用、可用、挂载点）（disk free）\r\n		free -h 	显示内存占用情况（包括swap虚拟内存）\r\n		lsblk		查看设备挂载情况\r\n		lsblk -f 	查看设备挂在情况和uuid\r\n		\r\n		mount 设备名 挂载点	设置挂载点	eg：设置光盘挂载点：mount /dev/cdrom /mnt/cdrom\r\n		umount 设备名		取消挂载点	eg：		    umount /dev/cdrom\r\n		vim /etc/fstab		在配置文件中写入开机自动配置挂载点\r\n		\r\n		fdisk -l			显示当前磁盘的详细信息\r\n		mkfs -t 文件类型(xfs) 设备名	设置磁盘分区	eg：mkfs -t xfs /dev/sdb1\r\n								添加新磁盘步骤：设置分区mkfs --> 设置挂载点\r\n\r\n\r\n\r\n进程/服务管理类命令：\r\n		服务(以d结尾如systemd):守护进程与服务是一一对应的，可以认为是一回事\r\n		ps [选项]		显示当前用户和终端正在运行的进程\r\n			a	列出带有终端的用户的所有用户进程\r\n			x	列出当前用户的所有进程，包括没有终端的进程		eg：ps aux | grep xxx		查看系统中所有的进程的内存占用\r\n			u	面向用户友好的显示风格\r\n			-e	列出所有进程\r\n			-u	列出某个用户关联的所有进程			eg：ps -ef | grep xxx		查看子父进程之间的关系\r\n			-f	显示完整的进程列表\r\n		\r\n		kill [选项] 进程好pid		通过进程号杀死进程\r\n			-9 	强制杀死\r\n		killall 进程名称		通过进程名称杀死进程\r\n		\r\n		yum install pstree 	安装pstree\r\n		pstree [选项]		查看进程树（也可看到父子进程的关系）\r\n			-p	显示进程号pid\r\n			-u	显示进程的所属用户\r\n		\r\n		top [选项]		实时查看系统进程	shift + p:pid升序、shift + n:pid降序\r\n			-d 秒数		指定top每隔几秒更新\r\n			-i		使top不显示任何闲置或者僵尸进程\r\n			-p 		通过指定PID来仅仅监控某个线程的状态\r\n		\r\n		netstat [选项]		显示网络状态和端口占用信息\r\n			-a	显示正在监听和未监听的套接字（socket）		\r\n			-n	拒绝显示别名，能显示数字的全部转化成数字	netstat -anp | grep 进程号	查看该进程网络信息\r\n			-l	仅列出在监听的服务状态				netstat -nlp | grep 端口号	查看网路端口号的占用情况\r\n			-p	表示显示哪个进程在调用\r\n\r\n		lsof -i:[端口号]		查看指定端口号的信息\r\n\r\n		\r\n系统定时任务：\r\n		systemctl restart crond\r\n		crontab [选项]		系统定时任务\r\n			-e	编辑crontab定时任务\r\n			-l	查询crontab任务\r\n			-r	删除当前用户的所有crontab任务\r\n		\r\n\r\n\r\n软件包管理命令：\r\n		RPM(RedHat Package Manager)：RedHat软件包管理工具\r\n		rpm -qa			查看所有已经安装的软件包\r\n		rpm -qa | grep xxx\r\n		rpm -qi xxx		检索xxx.rpm\r\n		\r\n		rpm -e PRM软件包	卸载软件包\r\n		rpm -e --nodeps		强制卸载软件包，不考虑软件之间的依赖关系\r\n		\r\n		rpm -ivh PRM包全名	安装软件包（-v：显示详细信息、-h：显示进度条）\r\n		rpm --nodeps 		不考虑依赖\r\n\r\n\r\n		YUM(Yellow dog Updater,Modified)：Redora和RedHat以及CentOS中的Shell前端软件包管理器，能够从指定服务器自动下载RPM包并且安装，\r\n						可以自动处理依赖关系，并且一次安装所有依赖的软件包，无需繁琐地一次次下载安装\r\n		yum [选项] [参数]	安装/更新/删除...rpm包\r\n			选项：	-y		对所有提问都回答yes\r\n			参数：	install		安装\r\n				update		更新\r\n				check-update	检查是否有更新\r\n				remove		删除\r\n				list		显示软件包信息\r\n				clean		清理yum过期的缓存\r\n				deplist		显示yum软件包的所有依赖关系\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n	\r\n','http://47.115.207.49/shareX/20230627/image-20230627003157504-shareX-20230627003203.png','原创',11,_binary '',_binary '',_binary '\0','2023-03-28 16:38:02','',2022576839,'记录了Linux的常用基础命令',NULL,NULL,'0'),(1673369924304650242,'Redis笔记','<font style=\"color: red;\">该笔记图片太多，可前往我的git拉取md文件查看</font>\r\n\r\n\r\n# 	1、Redis安装、配置和启动\r\n\r\n==阳哥邮箱：zzyybs@126.com==\r\n\r\n\r\n\r\n在官网下载tar.gz包后，拷贝到/opt中，进行解压，然后进入解压出的redis文件中，执行命令make && make install,默认安装到/usr/local/bin目录下\r\n\r\n在根目录下创建一个目录/myredis，并将/opt/redis-7.0.10/redis.conf文件复制到myredis目录下，保留原文件\r\n\r\n配置文件的修改：\r\n\r\n​	1.将daemonize no 改为 daemonize yes\r\n\r\n​	2.protected-mode yes 改为protected-mode no\r\n\r\n​	3.注释掉bind 127.0.0.1 -::1\r\n\r\n​	4.requirepass设置密码\r\n\r\n主从复制的配置：\r\n\r\n![image-20230408143127271](image/redis.assets/image-20230408143127271.png)\r\n\r\nredis可使用config get xxx 来查看对应的配置\r\n\r\n\r\n\r\nredis卸载：rm -rf /usr/local/bin/redis-*\r\n\r\n启动：\r\n\r\n​	redis-server /myredis/redis7.conf\r\n\r\n​	redis-cli -a 密码 [-p 6379] [--raw]\r\n\r\n​			redis-cli  --> auth 密码\r\n\r\n​	可使用ps -ef | grep redis | grep -v grep 查看进程\r\n\r\n​	若输入ping，输出PONG，则启动成功\r\n\r\n退出cli：quit\r\n\r\n退出cli和server：\r\n\r\n​	在redis命令行中：shutdown\r\n\r\n​	不在redis命令行中（远程关闭）：单实例关闭：redis -cli -a 密码 shutdown\r\n\r\n​																多实例关闭（分别指定端口号）：redis-cli -p 6379 shutdown\r\n\r\n# 2、Redis十大数据类型\r\n\r\n## 2.1 总体概述\r\n\r\n<img src=\"image/redis.assets/image-20230403225207494.png\" alt=\"image-20230403225207494\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230403225251521.png\" alt=\"image-20230403225251521\" style=\"zoom:50%;\" />\r\n\r\n![image-20230403225449055](image/redis.assets/image-20230403225449055.png)\r\n\r\n![image-20230403225621007](image/redis.assets/image-20230403225621007.png)\r\n\r\n![image-20230403225657133](image/redis.assets/image-20230403225657133.png)\r\n\r\n![image-20230403225720684](image/redis.assets/image-20230403225720684.png)\r\n\r\n![image-20230403225805567](image/redis.assets/image-20230403225805567.png)\r\n\r\n![image-20230403231640906](image/redis.assets/image-20230403231640906.png)\r\n\r\n![image-20230403231714477](image/redis.assets/image-20230403231714477.png)\r\n\r\n![image-20230403231900839](image/redis.assets/image-20230403231900839.png)\r\n\r\n![image-20230403231949615](image/redis.assets/image-20230403231949615.png)\r\n\r\n![image-20230403232046006](image/redis.assets/image-20230403232046006.png)\r\n\r\n## 2.2 获取redis常见数据类型操作命令\r\n\r\n官网英文：[Commands | Redis](https://redis.io/commands/)\r\n\r\n中文：[Redis命令中心（Redis commands） -- Redis中国用户组（CRUG）](http://redis.cn/commands.html)\r\n\r\n## 2.3 key操作命令\r\n\r\n![image-20230404144959263](image/redis.assets/image-20230404144959263.png)\r\n\r\n![image-20230404145353394](image/redis.assets/image-20230404145353394.png)\r\n\r\n**获取对应数据类型的命令：help @数据类型**\r\n\r\n**redis可使用config get xxx 来查看对应的配置**\r\n\r\n**命令不区分大小写，但是key使区分的**\r\n\r\n## 2.4.1 String\r\n\r\n![image-20230404164432416](image/redis.assets/image-20230404164432416.png)\r\n\r\n![image-20230404150507417](image/redis.assets/image-20230404150507417.png)\r\n\r\n![image-20230404151626311](image/redis.assets/image-20230404151626311.png)\r\n\r\n**若msetnx k1 v1 k2 v2：k1已经存在，k4不存在，则不会执行成功，全部都失败**\r\n\r\n\r\n\r\n![image-20230404151754634](image/redis.assets/image-20230404151754634.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404152137413.png\" alt=\"image-20230404152137413\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404152335659](image/redis.assets/image-20230404152335659.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404152346946.png\" alt=\"image-20230404152346946\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404152551652.png\" alt=\"image-20230404152551652\" style=\"zoom: 67%;\" />\r\n\r\n![image-20230404152759900](image/redis.assets/image-20230404152759900.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404152901807.png\" alt=\"image-20230404152901807\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404153014235](image/redis.assets/image-20230404153014235.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404153237570.png\" alt=\"image-20230404153237570\" style=\"zoom:33%;\" />\r\n\r\n**setnx == set nx的合并**\r\n\r\n**setex == set + expire 的合并 == set ex**\r\n\r\n![image-20230404153757944](image/redis.assets/image-20230404153757944.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404153827366.png\" alt=\"image-20230404153827366\" style=\"zoom:50%;\" />\r\n\r\n**getset k v == set k v get**\r\n\r\n\r\n\r\n\r\n\r\n**string应用场景：点赞，访问次数**\r\n\r\n\r\n\r\n## 2.4.2 List\r\n\r\n![image-20230404155852728](image/redis.assets/image-20230404155852728.png)\r\n\r\n![image-20230404155935050](image/redis.assets/image-20230404155935050.png)\r\n\r\n![image-20230404160240517](image/redis.assets/image-20230404160240517.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404160220307.png\" alt=\"image-20230404160220307\" style=\"zoom:50%;\" />\r\n\r\n**lrange list1 0 -1 相当于遍历**\r\n\r\n<img src=\"image/redis.assets/image-20230404160446068.png\" alt=\"image-20230404160446068\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404160507965](image/redis.assets/image-20230404160507965.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404160754814.png\" alt=\"image-20230404160754814\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404160808059.png\" alt=\"image-20230404160808059\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404160825227](image/redis.assets/image-20230404160825227.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404161120028.png\" alt=\"image-20230404161120028\" style=\"zoom: 50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404161301771.png\" alt=\"image-20230404161301771\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404161627474](image/redis.assets/image-20230404161627474.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404161641455.png\" alt=\"image-20230404161641455\" style=\"zoom:33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404161732069.png\" alt=\"image-20230404161732069\" style=\"zoom:33%;\" />\r\n\r\n![image-20230404161745126](image/redis.assets/image-20230404161745126.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404161818052.png\" alt=\"image-20230404161818052\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404161917970.png\" alt=\"image-20230404161917970\" style=\"zoom:50%;\" />\r\n\r\n**应用场景：微信公众号多关注订阅的文章**\r\n\r\n\r\n\r\n## 2.4.3 Hash\r\n\r\n![image-20230404163215501](image/redis.assets/image-20230404163215501.png)\r\n\r\n![image-20230404163255796](image/redis.assets/image-20230404163255796.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404163657688.png\" alt=\"image-20230404163657688\" style=\"zoom:50%;\" />\r\n\r\n**现版本hset == hmset，hmset已经被弃用**\r\n\r\n<img src=\"image/redis.assets/image-20230404163752325.png\" alt=\"image-20230404163752325\" style=\"zoom:50%;\" />\r\n\r\n**hgetall相当于遍历**\r\n\r\n![image-20230404164031407](image/redis.assets/image-20230404164031407.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404164110523.png\" alt=\"image-20230404164110523\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404164122328](image/redis.assets/image-20230404164122328.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404164307732.png\" alt=\"image-20230404164307732\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404164316473](image/redis.assets/image-20230404164316473.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404164500816.png\" alt=\"image-20230404164500816\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404164513482](image/redis.assets/image-20230404164513482.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404164646512.png\" alt=\"image-20230404164646512\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404164705975.png\" alt=\"image-20230404164705975\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404165057936](image/redis.assets/image-20230404165057936.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404165134941.png\" alt=\"image-20230404165134941\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404170156044](image/redis.assets/image-20230404170156044.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404170224054.png\" alt=\"image-20230404170224054\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404170246406.png\" alt=\"image-20230404170246406\" style=\"zoom:33%;\" />\r\n\r\n## 2.4.4 Set（无序且不重复）\r\n\r\n**![](image/redis.assets/image-20230404171056476.png)*\r\n\r\n![image-20230404171209171](image/redis.assets/image-20230404171209171.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404171217306.png\" alt=\"image-20230404171217306\" style=\"zoom:50%;\" />\r\n\r\n**smembers key 相当于遍历**\r\n\r\n![image-20230404171306420](image/redis.assets/image-20230404171306420.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404171256573.png\" alt=\"image-20230404171256573\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404171510161](image/redis.assets/image-20230404171510161.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404171736588.png\" alt=\"image-20230404171736588\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404171844719](image/redis.assets/image-20230404171844719.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404171956252.png\" alt=\"image-20230404171956252\" style=\"zoom:33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404172014454.png\" alt=\"image-20230404172014454\" style=\"zoom:33%;\" />\r\n\r\n![image-20230404172023254](image/redis.assets/image-20230404172023254.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404172121348.png\" alt=\"image-20230404172121348\" style=\"zoom:50%;\" />\r\n\r\n**![image-20230404172246329](image/redis.assets/image-20230404172246329.png)*\r\n\r\n![image-20230404172344442](image/redis.assets/image-20230404172344442.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404172351483.png\" alt=\"image-20230404172351483\" style=\"zoom: 50%;\" />\r\n\r\n![image-20230404172404918](image/redis.assets/image-20230404172404918.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404172417627.png\" alt=\"image-20230404172417627\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404172428866](image/redis.assets/image-20230404172428866.png)\r\n\r\n![image-20230404172620915](image/redis.assets/image-20230404172620915.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404172756269.png\" alt=\"image-20230404172756269\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404173028170](image/redis.assets/image-20230404173028170.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404173040632.png\" alt=\"image-20230404173040632\" style=\"zoom: 25%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404173548221.png\" alt=\"image-20230404173548221\" style=\"zoom:25%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404173644203.png\" alt=\"image-20230404173644203\" style=\"zoom:33%;\" />\r\n\r\n## 2.4.5 Zset(sorted set)\r\n\r\n![image-20230404174827874](image/redis.assets/image-20230404174827874.png)\r\n\r\n![image-20230404182213058](image/redis.assets/image-20230404182213058.png)\r\n\r\n\r\n\r\n![image-20230404175144751](image/redis.assets/image-20230404175144751.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404175009934.png\" alt=\"image-20230404175009934\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404175122275.png\" alt=\"image-20230404175122275\" style=\"zoom: 50%;\" />\r\n\r\n![image-20230404175321184](image/redis.assets/image-20230404175321184.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404175334432.png\" alt=\"image-20230404175334432\" style=\"zoom:33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404175749802.png\" alt=\"image-20230404175749802\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230404180040229](image/redis.assets/image-20230404180040229.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180050914.png\" alt=\"image-20230404180050914\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404180059802](image/redis.assets/image-20230404180059802.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180154881.png\" alt=\"image-20230404180154881\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404180204980](image/redis.assets/image-20230404180204980.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180252285.png\" alt=\"image-20230404180252285\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404180335624](image/redis.assets/image-20230404180335624.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180441994.png\" alt=\"image-20230404180441994\" style=\"zoom:33%;\" />\r\n\r\n![image-20230404180530928](image/redis.assets/image-20230404180530928.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180542323.png\" alt=\"image-20230404180542323\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404180602183](image/redis.assets/image-20230404180602183.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404180840261.png\" alt=\"image-20230404180840261\" style=\"zoom:33%;\" />\r\n\r\n![image-20230404180917807](image/redis.assets/image-20230404180917807.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404181107403.png\" alt=\"image-20230404181107403\" style=\"zoom: 50%;\" />\r\n\r\n![image-20230404181333071](image/redis.assets/image-20230404181333071.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404181315571.png\" alt=\"image-20230404181315571\" style=\"zoom: 25%;\" />\r\n\r\n## 2.4.6 bitmap（位图）--string\r\n\r\n![image-20230404193548268](image/redis.assets/image-20230404193548268.png)\r\n\r\n**bitmap 相当于string的子类，type bit 的返回值为string**\r\n\r\n<img src=\"image/redis.assets/image-20230404193729538.png\" alt=\"image-20230404193729538\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404193706412.png\" alt=\"image-20230404193706412\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404193815527](image/redis.assets/image-20230404193815527.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404193918746.png\" alt=\"image-20230404193918746\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230404194130392](image/redis.assets/image-20230404194130392.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404194243814.png\" alt=\"image-20230404194243814\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404194221167](image/redis.assets/image-20230404194221167.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404194317163.png\" alt=\"image-20230404194317163\" style=\"zoom: 33%;\" />\r\n\r\n**每八位一组，一组是一个字节，strlen返回的是字节数**\r\n\r\n![image-20230404194520508](image/redis.assets/image-20230404194520508.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404194542795.png\" alt=\"image-20230404194542795\" style=\"zoom: 50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404194808845.png\" alt=\"image-20230404194808845\" style=\"zoom: 80%;\" />\r\n\r\n![image-20230404195616077](image/redis.assets/image-20230404195616077.png)\r\n\r\n![image-20230404195544962](image/redis.assets/image-20230404195544962.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404195416531.png\" alt=\"image-20230404195416531\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230404195952350](image/redis.assets/image-20230404195952350.png)\r\n\r\n**签到天数**\r\n\r\n<img src=\"image/redis.assets/image-20230404200137404.png\" alt=\"image-20230404200137404\" style=\"zoom:33%;\" />\r\n\r\n\r\n\r\n## 2.4.7 HyperLogLog（基数统计）--string\r\n\r\n<img src=\"image/redis.assets/image-20230404202309445.png\" alt=\"image-20230404202309445\" style=\"zoom: 50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404201722609.png\" alt=\"image-20230404201722609\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404201729369.png\" alt=\"image-20230404201729369\" style=\"zoom: 50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404202514808.png\" alt=\"image-20230404202514808\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404202707642.png\" alt=\"image-20230404202707642\" style=\"zoom: 67%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404202750880.png\" alt=\"image-20230404202750880\" style=\"zoom:50%;\" />\r\n\r\n![image-20230404202919105](image/redis.assets/image-20230404202919105.png)\r\n\r\n## 2.4.8 GEO（地理空间）--zset\r\n\r\n![image-20230404204809187](image/redis.assets/image-20230404204809187.png)\r\n\r\n![image-20230404205224307](image/redis.assets/image-20230404205224307.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404205234321.png\" alt=\"image-20230404205234321\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230404205529983](image/redis.assets/image-20230404205529983.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404205633619.png\" alt=\"image-20230404205633619\"  />\r\n\r\n![image-20230404205732280](image/redis.assets/image-20230404205732280.png)\r\n\r\n![image-20230404210047316](image/redis.assets/image-20230404210047316.png)\r\n\r\n![image-20230404211347133](image/redis.assets/image-20230404211347133.png)\r\n\r\n![image-20230404211518786](image/redis.assets/image-20230404211518786.png)\r\n\r\n## 2.4.9 Stream（redis流）用于MQ\r\n\r\n<img src=\"image/redis.assets/image-20230404213312159.png\" alt=\"image-20230404213312159\" style=\"zoom: 50%;\" />\r\n\r\n![image-20230404213756806](image/redis.assets/image-20230404213756806.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404213817188.png\" alt=\"image-20230404213817188\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404213852193.png\" alt=\"image-20230404213852193\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230404214147552](image/redis.assets/image-20230404214147552.png)\r\n\r\n<img src=\"image/redis.assets/image-20230404214230187.png\" alt=\"image-20230404214230187\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404214641212.png\" alt=\"image-20230404214641212\" style=\"zoom:50%;\" />\r\n\r\n### 生产相关命令\r\n\r\n<img src=\"image/redis.assets/image-20230404214802556.png\" alt=\"image-20230404214802556\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230404221030749.png\" alt=\"image-20230404221030749\" style=\"zoom: 50%;\" />\r\n\r\n![image-20230405133621236](image/redis.assets/image-20230405133621236.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405133851521.png\" alt=\"image-20230405133851521\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405134309238.png\" alt=\"image-20230405134309238\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405134411435](image/redis.assets/image-20230405134411435.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405134539497.png\" alt=\"image-20230405134539497\" style=\"zoom:33%;\" />\r\n\r\n![image-20230405134615310](image/redis.assets/image-20230405134615310.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405134629566.png\" alt=\"image-20230405134629566\" style=\"zoom:33%;\" />\r\n\r\n![image-20230405134736417](image/redis.assets/image-20230405134736417.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405134800206.png\" alt=\"image-20230405134800206\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405134813680.png\" alt=\"image-20230405134813680\" style=\"zoom: 80%;\" />\r\n\r\n![image-20230405134836892](image/redis.assets/image-20230405134836892.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405135127611.png\" alt=\"image-20230405135127611\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405135019850.png\" alt=\"image-20230405135019850\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230405135150439](image/redis.assets/image-20230405135150439.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405135516758.png\" alt=\"image-20230405135516758\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405135613818.png\" alt=\"image-20230405135613818\" style=\"zoom:33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405135813755.png\" alt=\"image-20230405135813755\" style=\"zoom:33%;\" />\r\n\r\n\r\n\r\n### 消费相关命令\r\n\r\n![image-20230405140112329](image/redis.assets/image-20230405140112329.png)\r\n\r\n![image-20230405140209314](image/redis.assets/image-20230405140209314.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405140238202.png\" alt=\"image-20230405140238202\" style=\"zoom:33%;\" />\r\n\r\n![image-20230405140353249](image/redis.assets/image-20230405140353249.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405140736329.png\" alt=\"image-20230405140736329\" style=\"zoom:33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405140922357.png\" alt=\"image-20230405140922357\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230405141112822](image/redis.assets/image-20230405141112822.png)\r\n\r\n![image-20230405141506009](image/redis.assets/image-20230405141506009.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405141551701.png\" alt=\"image-20230405141551701\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405142023606.png\" alt=\"image-20230405142023606\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405141818015](image/redis.assets/image-20230405141818015.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405142000116.png\" alt=\"image-20230405142000116\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405142050646](image/redis.assets/image-20230405142050646.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405142109446.png\" alt=\"image-20230405142109446\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405142211049](image/redis.assets/image-20230405142211049.png)\r\n\r\n\r\n\r\n## 2.4.10 bitfield（位域）\r\n\r\n<img src=\"image/redis.assets/image-20230405144707422.png\" alt=\"image-20230405144707422\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405144851639](image/redis.assets/image-20230405144851639.png)\r\n\r\n![image-20230405145226605](image/redis.assets/image-20230405145226605.png)\r\n\r\n![image-20230405145236375](image/redis.assets/image-20230405145236375.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405145600229.png\" alt=\"image-20230405145600229\" style=\"zoom: 33%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405153436277.png\" alt=\"image-20230405153436277\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405153853768.png\" alt=\"image-20230405153853768\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405154832889](image/redis.assets/image-20230405154832889.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405155213731.png\" alt=\"image-20230405155213731\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405161058796.png\" alt=\"image-20230405161058796\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405161127243.png\" alt=\"image-20230405161127243\" style=\"zoom: 50%;\" />\r\n\r\n\r\n\r\n# 3、Redis持久化\r\n\r\n![image-20230405161743958](image/redis.assets/image-20230405161743958.png)\r\n\r\n![image-20230405161628794](image/redis.assets/image-20230405161628794.png)\r\n\r\n\r\n\r\n## ==3.1 RDB（Redis Database）==\r\n\r\n### 是什么（含6 7 自动触发区别）\r\n\r\n![image-20230405161830350](image/redis.assets/image-20230405161830350.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405161835676.png\" alt=\"image-20230405161835676\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405162918429.png\" alt=\"image-20230405162918429\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405163104062.png\" alt=\"image-20230405163104062\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230405163445841.png\" alt=\"image-20230405163445841\" style=\"zoom:50%;\" />\r\n\r\n\r\n\r\n\r\n\r\n### 自动触发\r\n\r\n<img src=\"image/redis.assets/image-20230405163627189.png\" alt=\"image-20230405163627189\" style=\"zoom:50%;\" />\r\n\r\n**按上图修改配置**\r\n\r\nsave 5 2（现在已经设置为5秒两次）\r\n\r\ndir /myredis/dumpfiles\r\n\r\ndbfilename dump6379.rdb\r\n\r\n![image-20230405195656003](image/redis.assets/image-20230405195656003.png)\r\n\r\n![image-20230405195612851](image/redis.assets/image-20230405195612851.png)\r\n\r\n**执行shutdown命令且没有开启AOF持久化也会生成dump文件**\r\n\r\n![image-20230405195924064](image/redis.assets/image-20230405195924064.png)\r\n\r\n\r\n\r\n\r\n\r\n### 手动触发（默认推荐使用DBSAVE，因为不会阻塞redis服务器）\r\n\r\n![image-20230405201853548](image/redis.assets/image-20230405201853548.png)\r\n\r\n**严禁使用save手动触发！！！**\r\n\r\n![image-20230405202047053](image/redis.assets/image-20230405202047053.png)\r\n\r\n![image-20230405202414292](image/redis.assets/image-20230405202414292.png)\r\n\r\n\r\n\r\n\r\n\r\n### 优缺点\r\n\r\n![image-20230405203410922](image/redis.assets/image-20230405203410922.png)\r\n\r\n![image-20230405203520365](image/redis.assets/image-20230405203520365.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405203606972.png\" alt=\"image-20230405203606972\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405203827514](image/redis.assets/image-20230405203827514.png)\r\n\r\n\r\n\r\n\r\n\r\n### 修复RDB文件\r\n\r\n使用在/usr/local/bin目录下的check-rdb，修复rdb文件\r\n\r\n![image-20230405205319503](image/redis.assets/image-20230405205319503.png)\r\n\r\n\r\n\r\n\r\n\r\n### RDB触发情况和快照禁用\r\n\r\n![image-20230405205742570](image/redis.assets/image-20230405205742570.png)\r\n\r\n![image-20230405210011878](image/redis.assets/image-20230405210011878.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405210056378.png\" alt=\"image-20230405210056378\" style=\"zoom: 50%;\" />\r\n\r\n**将save后写成空串，但还是可以手动触发生成rdb文件**\r\n\r\n\r\n\r\n\r\n\r\n### redis数据库RDB和AOF配置，数据库备份的区别：\r\n\r\n**一句话：AOF的优先级高于RDB**\r\n\r\n**情况1：整个redis默认情况下，redis为不设置save参数且未开启了AOF持久化时，当shutdown时会生成一个有效dump文件，整个过程只能在shutdown时保存一个有效的dump文件，以至于下一次打开redis时可恢复数据**\r\n\r\n**情况2：不设置save参数但是开启了AOF持久化时，以AOF为主，当shutdown时也会生成一个无效dump文件，备份数据库由AOF完成，若将AOF文件删除，数据库将无法完成备份**\r\n\r\n**情况3：但是若将save 后写成空串，则是禁用所有dump文件的自动生成方式，shutdown时连空文件也不会生成，若开启了AOF，则可由AOF完成备份，若未开启AOF，则是纯缓存模式，则redis无法自动完成备份**\r\n\r\n**情况4：设置了save参数以开启自动触发RDB，若未开启AOF，则由RDB独自完成备份，若开启了AOF且开启了混合模式，则由RDB和AOF混合完成备份，生成的AOF文件包括RDB头部和AOF混写，若未开启混合模式，则以AOF为主，AOF优先级高**\r\n\r\n\r\n\r\n\r\n\r\n### 优化配置项（后四者都推荐默认）\r\n\r\n![image-20230405210439775](image/redis.assets/image-20230405210439775.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405210531817.png\" alt=\"image-20230405210531817\" style=\"zoom:50%;\" />\r\n\r\n**若为yes，则数据一致性很高（建议默认yes）**\r\n\r\n\r\n\r\n![image-20230405210654149](image/redis.assets/image-20230405210654149.png)\r\n\r\n**推荐默认yes**\r\n\r\n\r\n\r\n![image-20230405211009684](image/redis.assets/image-20230405211009684.png)\r\n\r\n**推荐默认yes**\r\n\r\n\r\n\r\n![image-20230405211123785](image/redis.assets/image-20230405211123785.png)\r\n\r\n**推荐默认no**\r\n\r\n\r\n\r\n### 小总结\r\n\r\n<img src=\"image/redis.assets/image-20230405211326775.png\" alt=\"image-20230405211326775\" style=\"zoom:50%;\" />\r\n\r\n\r\n\r\n\r\n\r\n## ==3.2 AOF（Append Only File）==\r\n\r\n### 是什么\r\n\r\n![image-20230405211935077](image/redis.assets/image-20230405211935077.png)\r\n\r\n![image-20230405213547778](image/redis.assets/image-20230405213547778.png)\r\n\r\n**默认为关闭，可通过yes开启**\r\n\r\n\r\n\r\n\r\n\r\n### AOF持久工作流程和三种写回策略（默认为everysec）\r\n\r\n<img src=\"image/redis.assets/image-20230405212518162.png\" alt=\"image-20230405212518162\" style=\"zoom:50%;\" />\r\n\r\n**先保存在AOF缓存区，等达到一定数量后再写入AOF文件，减少IO次数**\r\n\r\n![image-20230405213502389](image/redis.assets/image-20230405213502389.png)\r\n\r\n![image-20230405213754559](image/redis.assets/image-20230405213754559.png)\r\n\r\n![image-20230405213843436](image/redis.assets/image-20230405213843436.png)\r\n\r\n![image-20230405213857279](image/redis.assets/image-20230405213857279.png)\r\n\r\n<img src=\"image/redis.assets/image-20230405213638513.png\" alt=\"image-20230405213638513\" style=\"zoom:50%;\" />\r\n\r\n![image-20230405214050241](image/redis.assets/image-20230405214050241.png)\r\n\r\n\r\n\r\n\r\n\r\n### 配置开启（含6 7aof保存路径、保存名称的区别）\r\n\r\n![image-20230405215504057](image/redis.assets/image-20230405215504057.png)\r\n\r\n![image-20230405215214769](image/redis.assets/image-20230405215214769.png)\r\n\r\n![image-20230405215316036](image/redis.assets/image-20230405215316036.png)\r\n\r\n\r\n\r\n++++\r\n\r\n\r\n\r\n\r\n\r\n![image-20230405215521608](image/redis.assets/image-20230405215521608.png)\r\n\r\n\r\n\r\n++++\r\n\r\n\r\n\r\n\r\n\r\n![image-20230405215545871](image/redis.assets/image-20230405215545871.png)\r\n\r\n![image-20230405215808682](image/redis.assets/image-20230405215808682.png)\r\n\r\n![image-20230405220437485](image/redis.assets/image-20230405220437485.png)\r\n\r\n**redis6：和RDB保存的位置相同**\r\n\r\n**==redis7：会在RAB文件保存的位置上加上一个自己设定的appenddirname目录，保存在其中==**\r\n\r\n\r\n\r\n++++\r\n\r\n\r\n\r\n![image-20230405220449448](image/redis.assets/image-20230405220449448.png)\r\n\r\n![image-20230405220900536](image/redis.assets/image-20230405220900536.png)\r\n\r\n![image-20230405220601888](image/redis.assets/image-20230405220601888.png)\r\n\r\n**redis6：只有一个aof文件**\r\n\r\n**==redis7：aof文件被拆分为三个==**\r\n\r\n\r\n\r\n<img src=\"image/redis.assets/image-20230405220920558.png\" alt=\"image-20230405220920558\" style=\"zoom:50%;\" />\r\n\r\n\r\n\r\n\r\n\r\n### 正常恢复\r\n\r\n![image-20230405221343030](image/redis.assets/image-20230405221343030.png)\r\n\r\n![image-20230406191559461](image/redis.assets/image-20230406191559461.png)\r\n\r\n**不看rdb文件，把rdb文件全部删掉，可以证明只用aof文件也可以对redis数据库进行恢复**\r\n\r\n**对于写操作，==是aof.incr在默默记录==，对于读操作，不会记录，大小不变**\r\n\r\n<img src=\"image/redis.assets/image-20230406192008533.png\" alt=\"image-20230406192008533\"  />\r\n\r\n\r\n\r\n\r\n\r\n### 异常恢复\r\n\r\n![image-20230406192332377](image/redis.assets/image-20230406192332377.png)\r\n\r\n![image-20230406194408184](image/redis.assets/image-20230406194408184.png)\r\n\r\n**在aof.incr文件中故意写入乱码：**\r\n\r\n**![image-20230406194651594](image/redis.assets/image-20230406194651594.png)**\r\n\r\n**redis服务器启动不了**\r\n\r\n**使用/usr/local/bin目录下的==redis-check-aof --fix==修复incr文件**\r\n\r\n![image-20230406195245468](image/redis.assets/image-20230406195245468.png)\r\n\r\n\r\n\r\n\r\n\r\n### 优缺点\r\n\r\n![image-20230406195543939](image/redis.assets/image-20230406195543939.png)\r\n\r\n![image-20230406200028100](image/redis.assets/image-20230406200028100.png)\r\n\r\n![image-20230406195839056](image/redis.assets/image-20230406195839056.png)\r\n\r\n![image-20230406195926135](image/redis.assets/image-20230406195926135.png)\r\n\r\n\r\n\r\n\r\n\r\n### 重写机制\r\n\r\n![image-20230406200319735](image/redis.assets/image-20230406200319735.png)\r\n\r\n![image-20230406200337939](image/redis.assets/image-20230406200337939.png)\r\n\r\n**当aof文件达到阈值时，自动触发**\r\n\r\n**使用bgrewriteaof手动触发**\r\n\r\n\r\n\r\n![image-20230406200549216](image/redis.assets/image-20230406200549216.png)\r\n\r\n![image-20230406200450221](image/redis.assets/image-20230406200450221.png)\r\n\r\n\r\n\r\n\r\n\r\n案例：\r\n\r\n![image-20230406205204119](image/redis.assets/image-20230406205204119.png)\r\n\r\n![image-20230406205256049](image/redis.assets/image-20230406205256049.png)\r\n\r\n![image-20230406205311350](image/redis.assets/image-20230406205311350.png)\r\n\r\n![image-20230406205340698](image/redis.assets/image-20230406205340698.png)\r\n\r\n\r\n\r\n\r\n\r\n### 小总结\r\n\r\n![image-20230406205535287](image/redis.assets/image-20230406205535287.png)\r\n\r\n![image-20230406205656264](image/redis.assets/image-20230406205656264.png)\r\n\r\n\r\n\r\n\r\n\r\n## 3.3 RDB-AOF混合持久化\r\n\r\n![image-20230406210824682](image/redis.assets/image-20230406210824682.png)\r\n\r\n![image-20230406210206899](image/redis.assets/image-20230406210206899.png)\r\n\r\n![image-20230406210125216](image/redis.assets/image-20230406210125216.png)\r\n\r\n**可以共存，但AOF优先级高于RDB**\r\n\r\n![image-20230406210220048](image/redis.assets/image-20230406210220048.png)\r\n\r\n![image-20230406210429725](image/redis.assets/image-20230406210429725.png)\r\n\r\n![image-20230406210504894](image/redis.assets/image-20230406210504894.png)\r\n\r\n![image-20230406210608955](image/redis.assets/image-20230406210608955.png)\r\n\r\n\r\n\r\n![image-20230406210617243](image/redis.assets/image-20230406210617243.png)\r\n\r\n![image-20230406210925750](image/redis.assets/image-20230406210925750.png)\r\n\r\n![image-20230406210834433](image/redis.assets/image-20230406210834433.png)\r\n\r\n### redis数据库RDB和AOF配置，数据库备份的区别：\r\n\r\n==**一句话：AOF的优先级高于RDB==**\r\n\r\n**情况1：整个redis默认情况下，redis为不设置save参数且未开启了AOF持久化时，当shutdown时会生成一个有效dump文件，整个过程只能在shutdown时保存一个有效的dump文件，以至于下一次打开redis时可恢复数据**\r\n\r\n**情况2：不设置save参数但是开启了AOF持久化时，以AOF为主，当shutdown时也会生成一个无效dump文件，备份数据库由AOF完成，若将AOF文件删除，数据库将无法完成备份**\r\n\r\n**情况3：但是若将save 后写成空串，则是禁用所有dump文件的自动生成方式，shutdown时连空文件也不会生成，若开启了AOF，则可由AOF完成备份，若未开启AOF，则是纯缓存模式，则redis无法自动完成备份**\r\n\r\n**情况4：设置了save参数以开启自动触发RDB，若未开启AOF，则由RDB独自完成备份，若开启了AOF且开启了混合模式，则由RDB和AOF混合完成备份，生成的AOF文件包括RDB头部和AOF混写，若未开启混合模式，则以AOF为主，AOF优先级高**\r\n\r\n\r\n\r\n\r\n\r\n## 3.4 纯缓存模式\r\n\r\n![image-20230406211459344](image/redis.assets/image-20230406211459344.png)\r\n\r\n![image-20230406211639486](image/redis.assets/image-20230406211639486.png)\r\n\r\n**不影响手动备份！！！！！！！！！！！！！！！！**\r\n\r\n\r\n\r\n\r\n\r\n# ==4、Redis事务==\r\n\r\n![image-20230406213545815](image/redis.assets/image-20230406213545815.png)\r\n\r\n\r\n\r\n\r\n\r\n## 4.1 Redis事务是什么，与数据库事务的对比\r\n\r\n**==数据库事务：在一次跟数据库的连接会话当中，所有执行的SQL，要么一起成功，要么一起失败==**\r\n\r\n**==原子性：一个事务中的所有操作要么全部成功，要么全部失败回滚，不能只执行其中的一部分操作==**\r\n\r\n![image-20230406214148888](image/redis.assets/image-20230406214148888.png)\r\n\r\n![image-20230406214330200](image/redis.assets/image-20230406214330200.png)\r\n\r\n![image-20230406214351875](image/redis.assets/image-20230406214351875.png)\r\n\r\n**Redis的事务只是能够==保证一组命令能够连续独占的执行，不会被其他命令插入，也不会被阻塞==，事务提交前任何命令都==不会被实际执行，即不涉及数据库事务的回滚操作，所以没有隔离级别，不保证原子性==(即不保证同时成功或同时失败，冤头债主)，只决定是否开始执行一组的全部指令**\r\n\r\n\r\n\r\n\r\n\r\n## 4.2 怎么使用Redis事务\r\n\r\n![image-20230406215728790](image/redis.assets/image-20230406215728790.png)\r\n\r\n\r\n\r\n\r\n\r\n### 常用命令\r\n\r\n![image-20230406215751030](image/redis.assets/image-20230406215751030.png)\r\n\r\n### 正常执行\r\n\r\n![image-20230406215854707](image/redis.assets/image-20230406215854707.png)\r\n\r\n<img src=\"image/redis.assets/image-20230406220100279.png\" alt=\"image-20230406220100279\" style=\"zoom:50%;\" />\r\n\r\n### 放弃执行\r\n\r\n![image-20230406220134672](image/redis.assets/image-20230406220134672.png)\r\n\r\n<img src=\"image/redis.assets/image-20230406220206888.png\" alt=\"image-20230406220206888\" style=\"zoom:50%;\" />\r\n\r\n### 全体连坐（语法编译错误，该组命令全部被舍弃）\r\n\r\n![image-20230406220552344](image/redis.assets/image-20230406220552344.png)\r\n\r\n![image-20230406220526376](image/redis.assets/image-20230406220526376.png)\r\n\r\n### 冤头债主（语法没错，编译时没检查出错误，对的命令执行，不对的不执行）\r\n\r\n![image-20230406221001476](image/redis.assets/image-20230406221001476.png)\r\n\r\n<img src=\"image/redis.assets/image-20230406220856366.png\" alt=\"image-20230406220856366\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"image/redis.assets/image-20230406221021739.png\" alt=\"image-20230406221021739\" style=\"zoom:50%;\" />\r\n\r\n![image-20230406220829205](image/redis.assets/image-20230406220829205.png)\r\n\r\n### watch监控（开启乐观锁）\r\n\r\n![](image/redis.assets/image-20230406221419392.png)\r\n\r\n![image-20230406221224677](image/redis.assets/image-20230406221224677.png)\r\n\r\n![image-20230406221248353](image/redis.assets/image-20230406221248353.png)\r\n\r\n**==Redis采用乐观锁，但必须要提交的版本大于当前版本才能执行==**\r\n\r\n**watch key时，若其他客户端已对key进行修改，当前事务将会被打断，无效**\r\n\r\n![image-20230406221547634](image/redis.assets/image-20230406221547634.png)\r\n\r\n### unwatch\r\n\r\n![image-20230406221911990](image/redis.assets/image-20230406221911990.png)\r\n\r\n\r\n\r\n\r\n\r\n![image-20230406222014243](image/redis.assets/image-20230406222014243.png)\r\n\r\n![image-20230406222325070](image/redis.assets/image-20230406222325070.png)\r\n\r\n\r\n\r\n### 小总结\r\n\r\n![image-20230406222053893](image/redis.assets/image-20230406222053893.png)\r\n\r\n\r\n\r\n\r\n\r\n# 5、Redis管道\r\n\r\n![image-20230408121329331](image/redis.assets/image-20230408121329331.png)\r\n\r\n## 5.1 管道的由来，是什么\r\n\r\n![image-20230408122015366](image/redis.assets/image-20230408122015366.png)\r\n\r\n![image-20230408120938690](image/redis.assets/image-20230408120938690.png)\r\n\r\n![image-20230408121039056](image/redis.assets/image-20230408121039056.png)\r\n\r\n![image-20230408121112824](image/redis.assets/image-20230408121112824.png)\r\n\r\n\r\n\r\n\r\n\r\n## ==5.2 管道的操作==\r\n\r\n![image-20230408122353571](image/redis.assets/image-20230408122353571.png)\r\n\r\n**在Linux窗口下，写好一个txt文件，用管道符执行该文件中的所有命令**\r\n\r\n\r\n\r\n## 5.3 管道与原生批处理命令和事务的对比，使用注意事项\r\n\r\n![image-20230408122448993](image/redis.assets/image-20230408122448993.png)\r\n\r\npipeline与原生批处理命令对比：\r\n\r\n![image-20230408122740607](image/redis.assets/image-20230408122740607.png)\r\n\r\npipeline与事务对比：\r\n\r\n![image-20230408122831546](image/redis.assets/image-20230408122831546.png)\r\n\r\n使用pipeline注意事项：\r\n\r\n![image-20230408123247953](image/redis.assets/image-20230408123247953.png)\r\n\r\n\r\n\r\n\r\n\r\n# 6、Redis发布订阅（了解即可）\r\n\r\n![image-20230408133106050](image/redis.assets/image-20230408133106050.png)\r\n\r\n## 6.1 是什么\r\n\r\n![image-20230408133137417](image/redis.assets/image-20230408133137417.png)\r\n\r\n是stream的前身\r\n\r\n## 6.2 能干嘛\r\n\r\n![image-20230408133423825](image/redis.assets/image-20230408133423825.png)\r\n\r\n![image-20230408133450828](image/redis.assets/image-20230408133450828.png)\r\n\r\n## 6.3 常用命令\r\n\r\n![image-20230408133534728](image/redis.assets/image-20230408133534728.png)\r\n\r\n![image-20230408133710677](image/redis.assets/image-20230408133710677.png)\r\n\r\n![image-20230408133853118](image/redis.assets/image-20230408133853118.png)\r\n\r\n![image-20230408134016908](image/redis.assets/image-20230408134016908.png)\r\n\r\n![image-20230408134039254](image/redis.assets/image-20230408134039254.png)\r\n\r\n![image-20230408134105040](image/redis.assets/image-20230408134105040.png)\r\n\r\n![image-20230408134158868](image/redis.assets/image-20230408134158868.png)\r\n\r\n![image-20230408134400720](image/redis.assets/image-20230408134400720.png)\r\n\r\n\r\n\r\n**演示：**\r\n\r\n![image-20230408135504653](image/redis.assets/image-20230408135504653.png)\r\n\r\n**psubscribe是订阅带有通配符*的频道**\r\n\r\n\r\n\r\n**小总结：**\r\n\r\n![image-20230408135955937](image/redis.assets/image-20230408135955937.png)\r\n\r\n\r\n\r\n\r\n\r\n# 7、Redis主从复制\r\n\r\n![image-20230408140117380](image/redis.assets/image-20230408140117380.png)\r\n\r\n## 7.1 是什么、能干嘛\r\n\r\n![image-20230408140207933](image/redis.assets/image-20230408140207933.png)\r\n\r\n**==master以写为主，slave以读为主==**\r\n\r\n![image-20230408140527803](image/redis.assets/image-20230408140527803.png)\r\n\r\n<img src=\"image/redis.assets/image-20230408140537631.png\" alt=\"image-20230408140537631\" style=\"zoom:50%;\" />\r\n\r\n\r\n\r\n\r\n\r\n## 7.2 操作与操作命令\r\n\r\n![image-20230408140713081](image/redis.assets/image-20230408140713081.png)\r\n\r\n![image-20230408140751191](image/redis.assets/image-20230408140751191.png)\r\n\r\n\r\n\r\n权限细节：\r\n\r\n![image-20230408140848125](image/redis.assets/image-20230408140848125.png)\r\n\r\n**==从机要设置masterauth来获得主机的许可==**\r\n\r\n\r\n\r\n![image-20230408141303037](image/redis.assets/image-20230408141303037.png)\r\n\r\n![image-20230408141419076](image/redis.assets/image-20230408141419076.png)\r\n\r\n**手动给自己临时换一个主机**\r\n\r\n\r\n\r\n![image-20230408141429591](image/redis.assets/image-20230408141429591.png)\r\n\r\n\r\n\r\n\r\n\r\n## ==7.3 实操案例演示==\r\n\r\n![image-20230408141558903](image/redis.assets/image-20230408141558903.png)\r\n\r\n![image-20230408211647900](image/redis.assets/image-20230408211647900.png)\r\n\r\n\r\n\r\n### 准备工作\r\n\r\n<img src=\"image/redis.assets/image-20230408141742401.png\" alt=\"image-20230408141742401\" style=\"zoom:33%;\" />\r\n\r\n![image-20230408141618892](image/redis.assets/image-20230408141618892.png)\r\n\r\n![image-20230408142229016](image/redis.assets/image-20230408142229016.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n![image-20230408142241404](image/redis.assets/image-20230408142241404.png)\r\n\r\n![image-20230408142459814](image/redis.assets/image-20230408142459814.png)\r\n\r\n![image-20230408142533115](image/redis.assets/image-20230408142533115.png)\r\n\r\n**==配主不配从==**\r\n\r\n\r\n\r\n### 配置细节\r\n\r\n![image-20230408143002113](image/redis.assets/image-20230408143002113.png)\r\n\r\n![image-20230408143127271](image/redis.assets/image-20230408143127271.png)\r\n\r\n\r\n\r\n**==主机只配前十步，从机需要配第十一步==**\r\n\r\n从机配置replicaof和masterauth\r\n\r\n\r\n\r\ndump文件名为dump6379.rdb\r\n\r\nlog文件名为6379.log\r\n\r\n\r\n\r\n\r\n\r\n### ==一主二仆实现==\r\n\r\n#### 配置文件写死情况\r\n\r\n![image-20230408155758562](image/redis.assets/image-20230408155758562.png)\r\n\r\n**==先开主机，再开从机==**\r\n\r\n**==从机启动时，一定要指明端口，否则默认为6379==**\r\n\r\n![image-20230410192559543](image/redis.assets/image-20230410192559543.png)\r\n\r\n\r\n\r\n![image-20230408160528137](image/redis.assets/image-20230408160528137.png)\r\n\r\n主机日志\r\n\r\n![image-20230408160204938](image/redis.assets/image-20230408160204938.png)\r\n\r\n备机日志\r\n\r\n![image-20230408160401834](image/redis.assets/image-20230408160401834.png)\r\n\r\n\r\n\r\n**使用info  replication命令查看主从关系**\r\n\r\n<img src=\"image/redis.assets/image-20230408160618114.png\" alt=\"image-20230408160618114\" style=\"zoom:50%;\" />\r\n\r\n\r\n\r\n#### 主从问题演示（配置写死）\r\n\r\n![image-20230408161138030](image/redis.assets/image-20230408161138030.png)\r\n\r\n![image-20230408160949114](image/redis.assets/image-20230408160949114.png)\r\n\r\n**==从机不可以执行写命令，读写分离==**\r\n\r\n\r\n\r\n![image-20230408161017451](image/redis.assets/image-20230408161017451.png)\r\n\r\n**==可以跟上，首次开机全部复制==**\r\n\r\n\r\n\r\n![image-20230408161536521](image/redis.assets/image-20230408161536521.png)\r\n\r\n**==主机shutdown过后，从机原地待命==**\r\n\r\n\r\n\r\n![image-20230408161735149](image/redis.assets/image-20230408161735149.png)\r\n\r\n**==关系依旧==**\r\n\r\n\r\n\r\n![image-20230408161801434](image/redis.assets/image-20230408161801434.png)\r\n\r\n**==和问题2一样，可以跟上==**\r\n\r\n\r\n\r\n#### 命令操作手动指定情况\r\n\r\n![image-20230408161947054](image/redis.assets/image-20230408161947054.png)\r\n\r\n**==从机重启过后，关系不在了==**\r\n\r\n\r\n\r\n![image-20230408162719965](image/redis.assets/image-20230408162719965.png)\r\n\r\n\r\n\r\n### 薪火相传实现\r\n\r\n**![image-20230408211712851](image/redis.assets/image-20230408211712851.png)*\r\n\r\n<img src=\"image/redis.assets/image-20230408211751697.png\" alt=\"image-20230408211751697\" style=\"zoom: 33%;\" />\r\n\r\n**==slave6380还是不能写操作==**\r\n\r\n\r\n\r\n\r\n\r\n### 反客为主实现\r\n\r\n![image-20230408212547621](image/redis.assets/image-20230408212547621.png)\r\n\r\n\r\n\r\n\r\n\r\n## ==7.4 复制原理和工作流程总结==\r\n\r\n![image-20230408212807487](image/redis.assets/image-20230408212807487.png)\r\n\r\n![image-20230408212925378](image/redis.assets/image-20230408212925378.png)\r\n\r\n![image-20230408212951325](image/redis.assets/image-20230408212951325.png)\r\n\r\n\r\n\r\n**首次连接，全量复制：**\r\n\r\n![](image/redis.assets/image-20230408213021098.png)\r\n\r\n\r\n\r\n![image-20230408213457007](image/redis.assets/image-20230408213457007.png)\r\n\r\n![image-20230408213503623](image/redis.assets/image-20230408213503623.png)\r\n\r\n\r\n\r\n![image-20230408213546586](image/redis.assets/image-20230408213546586.png)\r\n\r\n\r\n\r\n![image-20230408213617020](image/redis.assets/image-20230408213617020.png)\r\n\r\n\r\n\r\n\r\n\r\n## 7.5 主从复制缺点\r\n\r\n![image-20230408214049921](image/redis.assets/image-20230408214049921.png)\r\n\r\n![image-20230408214109882](image/redis.assets/image-20230408214109882.png)\r\n\r\n\r\n\r\n![image-20230408214339860](image/redis.assets/image-20230408214339860.png)\r\n\r\n![image-20230408214647487](image/redis.assets/image-20230408214647487.png)\r\n\r\n\r\n\r\n引入哨兵和集群进行改进\r\n\r\n\r\n\r\n\r\n\r\n# 8、Redis哨兵监控\r\n\r\n![image-20230408214830459](image/redis.assets/image-20230408214830459.png)\r\n\r\n## 8.1 是什么、能干嘛\r\n\r\n![image-20230408215731885](image/redis.assets/image-20230408215731885.png)\r\n\r\n![image-20230408215802828](image/redis.assets/image-20230408215802828.png)\r\n\r\n![image-20230408220023357](image/redis.assets/image-20230408220023357.png)\r\n\r\n\r\n\r\n\r\n\r\n## ==8.2 操作与案例==\r\n\r\n![image-20230408220452407](image/redis.assets/image-20230408220452407.png)\r\n\r\n\r\n\r\n### 准备工作\r\n\r\n**Redis Sentinel架构，前提说明**\r\n\r\n![image-20230408221206785](image/redis.assets/image-20230408221206785.png)\r\n\r\n![image-20230408224401749](image/redis.assets/image-20230408224401749.png)\r\n\r\n**至少需要三台哨兵，因为网络抖动等等原因，可能造成哨兵down机，并且需要多台哨兵进行投票选取新的master**\r\n\r\n\r\n\r\n### 配置细节\r\n\r\n![image-20230408224809355](image/redis.assets/image-20230408224809355.png)\r\n\r\n\r\n\r\n<img src=\"image/redis.assets/image-20230408225425792.png\" alt=\"image-20230408225425792\" style=\"zoom: 25%;\" />\r\n\r\n黑字和之前的一样配置\r\n\r\n\r\n\r\n![image-20230409153923243](image/redis.assets/image-20230409153923243.png)\r\n\r\n**==quorum参数：法定票数==**\r\n\r\n![image-20230408225558891](image/redis.assets/image-20230408225558891.png)\r\n\r\n![image-20230409153549805](image/redis.assets/image-20230409153549805.png)\r\n\r\n![image-20230409153638060](image/redis.assets/image-20230409153638060.png)\r\n\r\n**==至少要有quorum个sentinel认为master有故障，才会进行下线和故障转移==**\r\n\r\n\r\n\r\n**设置哨兵连接master的密码**\r\n\r\n![image-20230409153950260](image/redis.assets/image-20230409153950260.png)\r\n\r\n\r\n\r\n其他参数：（用默认即可）\r\n\r\n![image-20230409154146355](image/redis.assets/image-20230409154146355.png)\r\n\r\n\r\n\r\n\r\n\r\n### 本次案例sentinel 文件通用配置\r\n\r\n![image-20230409154450472](image/redis.assets/image-20230409154450472.png)\r\n\r\n![image-20230409154511552](image/redis.assets/image-20230409154511552.png)\r\n\r\n\r\n\r\n**将三个sentinel端口.conf配置文件如下格式写好**\r\n\r\n![image-20230409154740426](image/redis.assets/image-20230409154740426.png)\r\n\r\n![image-20230409155150040](image/redis.assets/image-20230409155150040.png)\r\n\r\n自己的：\r\n\r\n![image-20230409160326358](image/redis.assets/image-20230409160326358.png)\r\n\r\n\r\n\r\n\r\n\r\n### 哨兵集群启动\r\n\r\n#### 一主二从启动\r\n\r\n![image-20230409160502282](image/redis.assets/image-20230409160502282.png)\r\n\r\n**==从机启动时，一定要指明端口，否则默认为6379==**\r\n\r\n![image-20230410192559543](image/redis.assets/image-20230410192559543.png)\r\n\r\n![image-20230409160517691](image/redis.assets/image-20230409160517691.png)\r\n\r\n![image-20230409160537725](image/redis.assets/image-20230409160537725.png)\r\n\r\n**==前面主从复制的时候，master的redis6379.conf不用设置masterauth，但是这里要设置新主机的密码，因为此时主机可能变从机，推荐所有密码都设为一致，避免报错==**\r\n\r\n![image-20230409161059750](image/redis.assets/image-20230409161059750.png)\r\n\r\n![image-20230409161732939](image/redis.assets/image-20230409161732939.png)\r\n\r\n\r\n\r\n![image-20230409161948018](image/redis.assets/image-20230409161948018.png)\r\n\r\n\r\n\r\n#### 哨兵启动\r\n\r\n![image-20230409162303680](image/redis.assets/image-20230409162303680.png)\r\n\r\n**==在同一个终端下启动三个哨兵（实际应用都是一台主机一个哨兵）==**\r\n\r\n![image-20230409162317618](image/redis.assets/image-20230409162317618.png)\r\n\r\n![image-20230409162408724](image/redis.assets/image-20230409162408724.png)\r\n\r\n![image-20230409162915334](image/redis.assets/image-20230409162915334.png)\r\n\r\n\r\n\r\n\r\n\r\n==sentinel日志文件：==\r\n\r\n![image-20230410195557845](image/redis.assets/image-20230410195557845.png)\r\n\r\n![image-20230410195522975](image/redis.assets/image-20230410195522975.png)\r\n\r\n\r\n\r\n\r\n\r\n**==哨兵启动后，会在各自的sentinel.conf配置文件中自动追加重写一些信息，与其生成的log文件相对应==**\r\n\r\n例如自己的id，监控的master是谁，slave有哪些，哨兵集群中其他的哨兵是谁\r\n\r\n![image-20230410200005543](image/redis.assets/image-20230410200005543.png)\r\n\r\n\r\n\r\n\r\n\r\n### master挂了，含问题思考\r\n\r\n![image-20230409164303693](image/redis.assets/image-20230409164303693.png)\r\n\r\n![image-20230409164637286](image/redis.assets/image-20230409164637286.png)\r\n\r\n**==1、从机数据OK，只是要等sentinel进行投票选举，master刚挂时可能会提醒断开连接==**\r\n\r\n**==2、会从剩下的两台机器上选出新的master==**\r\n\r\n**==3、重启后，将会变成slave，6379下位后，会自动向其redis6379.conf最后追加重写一些内容==**\r\n\r\n![image-20230409170647296](image/redis.assets/image-20230409170647296.png)\r\n\r\n<img src=\"image/redis.assets/image-20230409170826523.png\" alt=\"image-20230409170826523\" style=\"zoom: 33%;\" />\r\n\r\n![image-20230409170655715](image/redis.assets/image-20230409170655715.png)\r\n\r\n![image-20230409171113649](image/redis.assets/image-20230409171113649.png)\r\n\r\n\r\n\r\n### ==master挂后配置文件的改变==\r\n\r\n![image-20230409173948430](image/redis.assets/image-20230409173948430.png)\r\n\r\n![image-20230409174348692](image/redis.assets/image-20230409174348692.png)\r\n\r\n**==哨兵启动后，会在各自的sentinel.conf配置文件中自动追加重写一些信息，与其生成的log文件相对应==**\r\n\r\n例如自己的id，监控的master是谁，slave有哪些，哨兵集群中其他的哨兵是谁\r\n\r\n![image-20230410200005543](image/redis.assets/image-20230410200005543.png)\r\n\r\n\r\n\r\n**==6379下位后开机，会自动向其redis6379.conf最后追加重写一些内容==**\r\n\r\n![image-20230409171519355](image/redis.assets/image-20230409171519355.png)\r\n\r\n\r\n\r\n**==主从切换后，之前哨兵启动时往sentinel追加的信息也会相应的发生该变，因为主从关系变了==**\r\n\r\n\r\n\r\n![image-20230409205846099](image/redis.assets/image-20230409205846099.png)\r\n\r\n\r\n\r\n## ==8.3 哨兵故障转移运行流程==\r\n\r\n![image-20230409205940971](image/redis.assets/image-20230409205940971.png)\r\n\r\n**==建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换==**\r\n\r\n![image-20230409210441156](image/redis.assets/image-20230409210441156.png)\r\n\r\n### Sdown主观下线\r\n\r\n![image-20230409210637243](image/redis.assets/image-20230409210637243.png)\r\n\r\n![image-20230409210809009](image/redis.assets/image-20230409210809009.png)\r\n\r\n### Odown客观下线\r\n\r\n![image-20230409211028803](image/redis.assets/image-20230409211028803.png)\r\n\r\n![image-20230409211042076](image/redis.assets/image-20230409211042076.png)\r\n\r\n\r\n\r\n### Raft算法选举出领导者哨兵（兵王）\r\n\r\n![image-20230409212402031](image/redis.assets/image-20230409212402031.png)\r\n\r\n![image-20230409213142631](image/redis.assets/image-20230409213142631.png)\r\n\r\n**简单了解Raft算法**\r\n\r\n![image-20230409220651126](image/redis.assets/image-20230409220651126.png)\r\n\r\n\r\n\r\n### ==兵王选出新master（含选举算法）==\r\n\r\n![image-20230409221052860](image/redis.assets/image-20230409221052860.png)\r\n\r\n**新主登基**\r\n\r\n![image-20230409221634107](image/redis.assets/image-20230409221634107.png)\r\n\r\n![image-20230409221858246](image/redis.assets/image-20230409221858246.png)\r\n\r\n<img src=\"image/redis.assets/image-20230409221927353.png\" alt=\"image-20230409221927353\" style=\"zoom:33%;\" />\r\n\r\n**==选举算发：优先级--> offset--> RunID==**\r\n\r\n<img src=\"image/redis.assets/image-20230409221724624.png\" alt=\"image-20230409221724624\" style=\"zoom: 25%;\" />\r\n\r\n\r\n\r\n**群臣俯首**\r\n\r\n![image-20230409222227063](image/redis.assets/image-20230409222227063.png)\r\n\r\n\r\n\r\n**旧主拜服**\r\n\r\n![image-20230409222345404](image/redis.assets/image-20230409222345404.png)\r\n\r\n**小总结**\r\n\r\n![image-20230409222418931](image/redis.assets/image-20230409222418931.png)\r\n\r\n![image-20230409222446305](image/redis.assets/image-20230409222446305.png)\r\n\r\n\r\n\r\n## 8.4 哨兵使用建议与缺点\r\n\r\n![image-20230409222956031](image/redis.assets/image-20230409222956031.png)\r\n\r\n**==建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换==**\r\n\r\n**主从 + 哨兵也不能保证数据零丢失，所以引出集群**\r\n\r\n\r\n\r\n\r\n\r\n# ==9、Redis集群分片==\r\n\r\n![image-20230410212906598](image/redis.assets/image-20230410212906598.png)\r\n\r\n![image-20230410212814102](image/redis.assets/image-20230410212814102.png)\r\n\r\n## 9.1 是什么、能干嘛\r\n\r\n![image-20230410213205105](image/redis.assets/image-20230410213205105.png)\r\n\r\n![image-20230410213216449](image/redis.assets/image-20230410213216449.png)\r\n\r\n![image-20230410213403087](image/redis.assets/image-20230410213403087.png)\r\n\r\n**==不用再使用哨兵，只需链接任意一个集群中的可用2节点即可，master之间数据共享，但是不保证强一致性==**\r\n\r\n\r\n\r\n\r\n\r\n## ==9.2 集群算法-分片-槽位slot==\r\n\r\n![image-20230410214145186](image/redis.assets/image-20230410214145186.png)\r\n\r\n![image-20230410214309164](image/redis.assets/image-20230410214309164.png)\r\n\r\n**==被分为16384个槽，有效设置了16384个主节点的集群大小上限，但是建议最大节点大小约为1000个节点==**\r\n\r\n\r\n\r\n### 槽位slot\r\n\r\n![image-20230410214525181](image/redis.assets/image-20230410214525181.png)\r\n\r\n### 分片和它的优势\r\n\r\n![image-20230410214751714](image/redis.assets/image-20230410214751714.png)\r\n\r\n![image-20230410215136036](image/redis.assets/image-20230410215136036.png)\r\n\r\n\r\n\r\n\r\n\r\n### 槽位映射算法\r\n\r\n![image-20230410215439039](image/redis.assets/image-20230410215439039.png)\r\n\r\n#### 哈希取余分区\r\n\r\n![image-20230410220439769](image/redis.assets/image-20230410220439769.png)\r\n\r\n![image-20230410220754453](image/redis.assets/image-20230410220754453.png)\r\n\r\n![image-20230410220747234](image/redis.assets/image-20230410220747234.png)\r\n\r\n\r\n\r\n#### 一致性哈希算法分区\r\n\r\n<img src=\"image/redis.assets/image-20230410220940292.png\" alt=\"image-20230410220940292\" style=\"zoom:33%;\" />\r\n\r\n![image-20230410220841456](image/redis.assets/image-20230410220841456.png)\r\n\r\n![image-20230410220905305](image/redis.assets/image-20230410220905305.png)\r\n\r\n![image-20230410220924182](image/redis.assets/image-20230410220924182.png)\r\n\r\n\r\n\r\n**算法构建一致性哈希环**\r\n\r\n![image-20230410221104902](image/redis.assets/image-20230410221104902.png)\r\n\r\n\r\n\r\n**服务器IP节点映射**\r\n\r\n节点：redis服务器\r\n\r\n![image-20230410221419152](image/redis.assets/image-20230410221419152.png)\r\n\r\n\r\n\r\n**key落到服务器的落键规则**\r\n\r\n![image-20230410221816579](image/redis.assets/image-20230410221816579.png)\r\n\r\n![image-20230410221710199](image/redis.assets/image-20230410221710199.png)\r\n\r\n\r\n\r\n![image-20230410221938760](image/redis.assets/image-20230410221938760.png)\r\n\r\n![image-20230410222014396](image/redis.assets/image-20230410222014396.png)\r\n\r\n![image-20230410222039801](image/redis.assets/image-20230410222039801.png)\r\n\r\n![image-20230410222146248](image/redis.assets/image-20230410222146248.png)\r\n\r\n\r\n\r\n\r\n\r\n![image-20230410222213891](image/redis.assets/image-20230410222213891.png)\r\n\r\n![image-20230410222156798](image/redis.assets/image-20230410222156798.png)\r\n\r\n![image-20230410222256716](image/redis.assets/image-20230410222256716.png)\r\n\r\n\r\n\r\n\r\n\r\n#### ==哈希槽分区==\r\n\r\n![image-20230410222419545](image/redis.assets/image-20230410222419545.png)\r\n\r\n![image-20230410222814597](image/redis.assets/image-20230410222814597.png)\r\n\r\n![image-20230410222915337](image/redis.assets/image-20230410222915337.png)\r\n\r\n\r\n\r\n\r\n\r\n### ==为什么最大槽数是16384==\r\n\r\n![image-20230410223424858](image/redis.assets/image-20230410223424858.png)\r\n\r\n![image-20230410223513872](image/redis.assets/image-20230410223513872.png)\r\n\r\n![image-20230410223538678](image/redis.assets/image-20230410223538678.png)\r\n\r\n![image-20230410223650056](image/redis.assets/image-20230410223650056.png)\r\n\r\n**==（1）65536消息头太大==**\r\n\r\n![image-20230410223821799](image/redis.assets/image-20230410223821799.png)\r\n\r\n**==（2）1000以内节点16384个槽够用了，不易造成网络拥堵==**\r\n\r\n![image-20230410223913265](image/redis.assets/image-20230410223913265.png)\r\n\r\n**==（3）在节点少的情况下，即小型集群中，因为填充率为slots/N，若采用65536的话，填充率将会很高，压缩比将会很低，不容易传输，但是采用16384的话，填充率低一些，压缩比将会高很多，容易传输些==**\r\n\r\n\r\n\r\n\r\n\r\n### 不保证强一致性\r\n\r\n![image-20230410230449517](image/redis.assets/image-20230410230449517.png)\r\n\r\n\r\n\r\n\r\n\r\n## ==9.3 三主三从集群搭建==\r\n\r\n![image-20230411155840013](image/redis.assets/image-20230411155840013.png)\r\n\r\n### ==3主3从redis集群配置==\r\n\r\n![image-20230411160032970](image/redis.assets/image-20230411160032970.png)\r\n\r\n\r\n\r\n#### 新建6台独立的redis实例服务\r\n\r\n![image-20230411160402336](image/redis.assets/image-20230411160402336.png)\r\n\r\n \r\n\r\n![image-20230411160420264](image/redis.assets/image-20230411160420264.png)\r\n\r\n\r\n\r\n![image-20230411160526569](image/redis.assets/image-20230411160526569.png)\r\n\r\n**==相比主从复制，只写了masterauth，没有写replicaof==**\r\n\r\nbind 0.0.0.0\r\ndaemonize yes\r\nprotected-mode no\r\nport 6381\r\nlogfile \"/myredis/cluster/cluster6381.log\"\r\npidfile /myredis/cluster6381.pid\r\ndir /myredis/cluster\r\ndbfilename dump6381.rdb\r\nappendonly yes\r\nappendfilename \"appendonly6381.aof\"\r\nrequirepass xxxxxxxxxxxxxx@\r\nmasterauth xxxxxxxxxxxxxx@\r\ncluster-enabled yes\r\ncluster-config-file nodes-6381.conf\r\ncluster-node-timeout 5000\r\n\r\n![image-20230411161810076](image/redis.assets/image-20230411161810076.png)\r\n\r\n**==这里只需启动redis-server==**\r\n\r\n\r\n\r\n####  redis-cli为6台机器构建集群关系\r\n\r\n![image-20230411185514494](image/redis.assets/image-20230411185514494.png)\r\n\r\n![image-20230411185526464](image/redis.assets/image-20230411185526464.png)\r\n\r\n**==redis-cli语句如下==**，并没有打开客户端，只是构建了集群\r\n\r\n```\r\nredis-cli -a 111111 --cluster create --cluster-replicas 1 192.168.111.185:6381 192.168.111.185:6382 192.168.111.172:6383 192.168.111.172:6384 192.168.111.184:6385 192.168.111.184:6386\r\n```\r\n\r\n![image-20230411190221954](image/redis.assets/image-20230411190221954.png)\r\n\r\n**==主从关系是随机分配的==**\r\n\r\n![image-20230411190310678](image/redis.assets/image-20230411190310678.png)\r\n\r\n**集群启动后会产生nodes开头的文件**\r\n\r\n![image-20230411191114952](image/redis.assets/image-20230411191114952.png)\r\n\r\n\r\n\r\n#### redis-cli打开6381客户端为切入点，查看并检验集群的状态\r\n\r\n![image-20230411191320016](image/redis.assets/image-20230411191320016.png)\r\n\r\n**==再使用redis-cli打开6381的客服端，记得指明端口==**\r\n\r\n\r\n\r\n**==根据下面的读写测试，这里加一个-c，表示路由==**\r\n\r\n```\r\nredis-cli -a 111111 -p 6381 -c\r\n```\r\n\r\n![image-20230411191329641](image/redis.assets/image-20230411191329641.png)\r\n\r\n**可以使用==info replication==和==cluster ndoes== 命令来查看**\r\n\r\n![image-20230411191816166](image/redis.assets/image-20230411191816166.png)\r\n\r\n\r\n\r\n\r\n\r\n### 3主3从集群读写\r\n\r\n![image-20230411192632504](image/redis.assets/image-20230411192632504.png)\r\n\r\n\r\n\r\n![image-20230411192718591](image/redis.assets/image-20230411192718591.png)\r\n\r\n![image-20230411192618705](image/redis.assets/image-20230411192618705.png)\r\n\r\n\r\n\r\n![image-20230411192824959](image/redis.assets/image-20230411192824959.png)\r\n\r\n![image-20230411192808854](image/redis.assets/image-20230411192808854.png)\r\n\r\n\r\n\r\n![image-20230411192820642](image/redis.assets/image-20230411192820642.png)\r\n\r\n```\r\nredis-cli -a 111111 -p 6381 -c\r\n```\r\n\r\n![image-20230411193152962](image/redis.assets/image-20230411193152962.png)\r\n\r\n![image-20230411193554765](image/redis.assets/image-20230411193554765.png)\r\n\r\n![image-20230411192830986](image/redis.assets/image-20230411192830986.png)\r\n\r\n![image-20230411193252458](image/redis.assets/image-20230411193252458.png)\r\n\r\n![image-20230411192836243](image/redis.assets/image-20230411192836243.png)\r\n\r\n```\r\ncluster keyslot k1\r\n```\r\n\r\n![image-20230411193328906](image/redis.assets/image-20230411193328906.png)\r\n\r\n\r\n\r\n\r\n\r\n### 主从容错切换迁移案例(即一个master宕机)、不保证强一致性、节点从属调整(手动恢复6381master身份)\r\n\r\n![image-20230411193727209](image/redis.assets/image-20230411193727209.png)\r\n\r\n\r\n\r\n**容错切换迁移**\r\n\r\n![image-20230411193812792](image/redis.assets/image-20230411193812792.png)\r\n\r\n![image-20230411193846054](image/redis.assets/image-20230411193846054.png)\r\n\r\n![image-20230411194103431](image/redis.assets/image-20230411194103431.png)\r\n\r\n**==master宕机后，其真实从机上位==**\r\n\r\n![image-20230411194132853](image/redis.assets/image-20230411194132853.png)\r\n\r\n\r\n\r\n![image-20230411194731132](image/redis.assets/image-20230411194731132.png)\r\n\r\n**==6381变成slave==**\r\n\r\n![image-20230411194738722](image/redis.assets/image-20230411194738722.png)\r\n\r\n\r\n\r\n\r\n\r\n**redis集群不保证强一致性**\r\n\r\n![image-20230411194830000](image/redis.assets/image-20230411194830000.png)\r\n\r\n![image-20230411194936604](image/redis.assets/image-20230411194936604.png)\r\n\r\n\r\n\r\n\r\n\r\n**手动故障转移（节点从属调整：恢复6381master身份）**\r\n\r\n![image-20230411195121396](image/redis.assets/image-20230411195121396.png)\r\n\r\n![image-20230411195833357](image/redis.assets/image-20230411195833357.png)\r\n\r\n```\r\ncluster failover\r\n```\r\n\r\n![image-20230411195821023](image/redis.assets/image-20230411195821023.png)\r\n\r\n\r\n\r\n\r\n\r\n### ==主从扩容==\r\n\r\n![image-20230411200141308](image/redis.assets/image-20230411200141308.png)\r\n\r\n\r\n\r\n**主从扩容全部命令总结：**\r\n\r\n```shell\r\nredis-server /myredis/cluster/redisCluster6387.conf		#启动6387server\r\n\r\nredis-server /myredis/cluster/redisCluster6388.conf		#启动6388server\r\n\r\nredis-cli -a 111111 --cluster add-node 192.168.111.100:6387 192.168.111.100:6381	\r\n#将6387作为新的master加入集群，6381为引荐人\r\n\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381	#第一次检查\r\n\r\nredis-cli -a 111111 --cluster reshard 192.168.111.100:6381		#给6387分配slot\r\n\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381		#第二次检查\r\n\r\nredis-cli -a 111111 --cluster add-node 192.168.111.100:6388 192.168.111.100:6387 --cluster-slave --cluster-master-id xxxxxxxxxxxxxxxxxxxxx(6387id)\r\n#让6388成为6387的从节点\r\n\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381		#第三c\r\n```\r\n\r\n\r\n\r\n![image-20230411200238386](image/redis.assets/image-20230411200238386.png)\r\n\r\n\r\n\r\n![image-20230411200258446](image/redis.assets/image-20230411200258446.png)\r\n\r\n![image-20230411200308296](image/redis.assets/image-20230411200308296.png)\r\n\r\n\r\n\r\n![image-20230411200329974](image/redis.assets/image-20230411200329974.png)\r\n\r\n**==redis-cli -a 111111 --cluster add-node 192.168.111.100:6387 192.168.111.100:6381==**\r\n\r\n![image-20230411200344808](image/redis.assets/image-20230411200344808.png)\r\n\r\n\r\n\r\n![image-20230411200528594](image/redis.assets/image-20230411200528594.png)\r\n\r\n**==redis-cli -a 111111 --cluster check 192.168.111.100:6381==**\r\n\r\n![image-20230411200541581](image/redis.assets/image-20230411200541581.png)\r\n\r\n\r\n\r\n![image-20230411200801940](image/redis.assets/image-20230411200801940.png)\r\n\r\n**==redis-cli -a 111111 --cluster reshard 192.168.111.100:6381==**\r\n\r\n![image-20230411200820289](image/redis.assets/image-20230411200820289.png)\r\n\r\n![image-20230411201047651](image/redis.assets/image-20230411201047651.png)\r\n\r\n\r\n\r\n![image-20230411201336969](image/redis.assets/image-20230411201336969.png)\r\n\r\n**==6387的slot槽是从其他三家匀过来的==**\r\n\r\n![image-20230411201409810](image/redis.assets/image-20230411201409810.png)\r\n\r\n\r\n\r\n![image-20230411201212167](image/redis.assets/image-20230411201212167.png)\r\n\r\n**==redis-cli -a 111111 --cluster check 192.168.111.100:6381==**\r\n\r\n![image-20230411201236370](image/redis.assets/image-20230411201236370.png)\r\n\r\n\r\n\r\n![image-20230411201435700](image/redis.assets/image-20230411201435700.png)\r\n\r\n**==redis-cli -a 111111 --cluster add-node 192.168.111.100:6388 192.168.111.100:6387 --cluster-slave --cluster-master-id xxxxxxxxxxxxxxxxx(6387的id)==**\r\n\r\n**==redis-cli -a 111111 --cluster add-node 192.168.111.100:6387 192.168.111.100:6381==**\r\n\r\n![image-20230411201451758](image/redis.assets/image-20230411201451758.png)\r\n\r\n\r\n\r\n![image-20230411201754433](image/redis.assets/image-20230411201754433.png)\r\n\r\n**==redis-cli -a 111111 --cluster check 192.168.111.100:6381==**\r\n\r\n![image-20230411201804991](image/redis.assets/image-20230411201804991.png)\r\n\r\n\r\n\r\n\r\n\r\n### ==主从缩容==\r\n\r\n![image-20230411212355577](image/redis.assets/image-20230411212355577.png)\r\n\r\n![image-20230411212210424](image/redis.assets/image-20230411212210424.png)\r\n\r\n\r\n\r\n**主从缩容全部命令总结：**\r\n\r\n```shell\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6388	#获得6388的ID\r\nredis-cli -a 111111 --cluster del-node 192.168.111.100:6388 xxxxxxxx(6388id)  #删除6388\r\nredis-cli -a 111111 --cluster reshard 192.168.111.100:6381    #把6387的slot都给6381\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381    #第二次检查\r\nredis-cli -a 111111 --cluster del-node 192.168.111.100:6387 xxxxxxxx(6387id)  #删除6387\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381	#第三次检查\r\n```\r\n\r\n\r\n\r\n\r\n\r\n![image-20230411212229950](image/redis.assets/image-20230411212229950.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6388\r\n```\r\n\r\n![image-20230411212239192](image/redis.assets/image-20230411212239192.png)\r\n\r\n\r\n\r\n![image-20230411212325608](image/redis.assets/image-20230411212325608.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster del-node 192.168.111.100:6388 xxxxxxxxxxxxxxxxx(6388id)\r\n```\r\n\r\n![image-20230411212426831](image/redis.assets/image-20230411212426831.png)\r\n\r\n\r\n\r\n![image-20230411212527893](image/redis.assets/image-20230411212527893.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster reshard 192.168.111.100:6381\r\n```\r\n\r\n![image-20230411212614682](image/redis.assets/image-20230411212614682.png)\r\n\r\n![image-20230411212639959](image/redis.assets/image-20230411212639959.png)\r\n\r\n\r\n\r\n![image-20230411212825431](image/redis.assets/image-20230411212825431.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381\r\n```\r\n\r\n![image-20230411212837370](image/redis.assets/image-20230411212837370.png)\r\n\r\n\r\n\r\n![image-20230411212936781](image/redis.assets/image-20230411212936781.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster del-node 192.168.111.100:6387 xxxxxxxxxxx(6387id)\r\n```\r\n\r\n![image-20230411212946012](image/redis.assets/image-20230411212946012.png)\r\n\r\n\r\n\r\n![image-20230411213022252](image/redis.assets/image-20230411213022252.png)\r\n\r\n```\r\nredis-cli -a 111111 --cluster check 192.168.111.100:6381\r\n```\r\n\r\n![image-20230411213028972](image/redis.assets/image-20230411213028972.png)\r\n\r\n\r\n\r\n\r\n\r\n## 9.4 总结：集群常用操作命令和CRC16算法分析\r\n\r\n ![image-20230411213444797](image/redis.assets/image-20230411213444797.png)\r\n\r\n\r\n\r\n![image-20230411213935213](image/redis.assets/image-20230411213935213.png)\r\n\r\n**==用{}设定key的分组，可让其存入同一个slot==**\r\n\r\n![image-20230411213641606](image/redis.assets/image-20230411213641606.png)\r\n\r\n![image-20230411213754047](image/redis.assets/image-20230411213754047.png)\r\n\r\n\r\n\r\n![image-20230411213943972](image/redis.assets/image-20230411213943972.png)\r\n\r\n![image-20230411214051864](image/redis.assets/image-20230411214051864.png)\r\n\r\n\r\n\r\n\r\n\r\n![image-20230411214241003](image/redis.assets/image-20230411214241003.png)\r\n\r\n![image-20230411214315210](image/redis.assets/image-20230411214315210.png)\r\n\r\n![image-20230411214322712](image/redis.assets/image-20230411214322712.png)\r\n\r\n\r\n\r\n![image-20230411215209114](image/redis.assets/image-20230411215209114.png)\r\n\r\n查看当前槽是否有key\r\n\r\n![image-20230411215101016](image/redis.assets/image-20230411215101016.png)\r\n\r\n\r\n\r\n![image-20230411215221913](image/redis.assets/image-20230411215221913.png)\r\n\r\n![image-20230411215233700](image/redis.assets/image-20230411215233700.png)\r\n\r\n\r\n\r\n\r\n\r\n# 10、SpringBoot整合Redis\r\n\r\n![image-20230412153753021](image/redis.assets/image-20230412153753021.png)\r\n\r\n![image-20230412154146207](image/redis.assets/image-20230412154146207.png)\r\n\r\n\r\n\r\n## 10.1 集成jedis\r\n\r\n![image-20230412154225636](image/redis.assets/image-20230412154225636.png)\r\n\r\n![image-20230412154253292](image/redis.assets/image-20230412154253292.png)\r\n\r\n![image-20230412161522114](image/redis.assets/image-20230412161522114.png)\r\n\r\n```xml\r\n		<!--导入redis:jedis-->\r\n        <dependency>\r\n            <groupId>redis.clients</groupId>\r\n            <artifactId>jedis</artifactId>\r\n        </dependency>\r\n```\r\n\r\n写application.properties/yml\r\n\r\n```\r\nserver.port=7777\r\nspring.application.name=redis7_study\r\n```\r\n\r\n![image-20230412161525251](image/redis.assets/image-20230412161525251.png)\r\n\r\n**==记得关闭linux防火墙：systemctl stop firewalld==**\r\n\r\n**==还是连不上注意是不是linux不能上网，检查win + R，输入：services.msc ，启动VMware NAT Servise服务==**\r\n\r\n![image-20230412162425540](image/redis.assets/image-20230412162425540.png)\r\n\r\n\r\n\r\n\r\n\r\n## 10.2 集成lettuce\r\n\r\n![image-20230412162452175](image/redis.assets/image-20230412162452175.png)\r\n\r\n![image-20230412162616934](image/redis.assets/image-20230412162616934.png)\r\n\r\n是线程安全的\r\n\r\n\r\n\r\n![image-20230412163006935](image/redis.assets/image-20230412163006935.png)\r\n\r\n```xml\r\n		<!--导入redis：lettuce-->\r\n        <dependency>\r\n            <groupId>io.lettuce</groupId>\r\n            <artifactId>lettuce-core</artifactId>\r\n        </dependency>\r\n```\r\n\r\n![image-20230412164148555](image/redis.assets/image-20230412164148555.png)\r\n\r\n\r\n\r\n## ==10.3 集成RedisTemplate==\r\n\r\n![image-20230412164318846](image/redis.assets/image-20230412164318846.png)\r\n\r\n\r\n\r\n\r\n\r\n### 连接单机\r\n\r\n![image-20230412164355654](image/redis.assets/image-20230412164355654.png)\r\n\r\n![image-20230412164445454](image/redis.assets/image-20230412164445454.png)\r\n\r\n\r\n\r\n**改POM（最后附全部pom.xml内容）**\r\n\r\n![image-20230412165525170](image/redis.assets/image-20230412165525170.png)\r\n\r\n```xml\r\n		<!--springboot与Redis整合依赖-->\r\n        <!--redis：RedisTemplate(下面四个)-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-data-redis</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.apache.commons</groupId>\r\n            <artifactId>commons-pool2</artifactId>\r\n        </dependency>\r\n\r\n        <!--swagger2-->\r\n        <dependency>\r\n            <groupId>io.springfox</groupId>\r\n            <artifactId>springfox-swagger2</artifactId>\r\n            <version>2.9.2</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>io.springfox</groupId>\r\n            <artifactId>springfox-swagger-ui</artifactId>\r\n            <version>2.9.2</version>\r\n        </dependency>\r\n```\r\n\r\n\r\n\r\n**写application.properties/yml**\r\n\r\n![image-20230412171044640](image/redis.assets/image-20230412171044640.png)\r\n\r\n```properties\r\nserver.port=7777\r\nspring.application.name=redis7_study\r\n\r\n#========================logging=========================\r\nlogging.level.root=info\r\nlogging.level.com.spongehah.redis7=info\r\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n \r\n\r\nlogging.file.name=D:/mylogs2023/redis7_study.log\r\nlogging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger- %msg%n\r\n\r\n#=========================swagger==========================\r\n#控制SwaggerConfig的enable的值\r\nspring.swagger2.enabled=true\r\n#springboot.2.6.X结合swagger2.9.X会提小documentationPluginsBootstrapper空指针异常，\r\n#原因是在springboot2.6,X中将springMVC默认路径匹配策略从AntPathMatcher.更改为PathPatternParser,\r\n#导致出错，解决办法是matching-strategy切换回，之前ant_path_matcher\r\nspring.mvc.pathmatch.matching-strategy=ant_path_matcher\r\n\r\n#==========================redis单机===========================\r\nspring.redis.database=0\r\n#修改为自己的真实IP\r\nspring.redis.host=192.168.111.100\r\nspring.redis.port=6379\r\nspring.redis.password=xxxxxxxxxxxxxx@\r\nspring.redis.lettuce.pool.max-active=8\r\nspring.redis.lettuce.pool.max-wait=-1ms\r\nspring.redis.lettuce.pool.max-idle=8\r\nspring.redis.lettuce.pool.min-idle=0\r\n```\r\n\r\n\r\n\r\n**主启动类默认**\r\n\r\n![image-20230412171555368](image/redis.assets/image-20230412171555368.png)\r\n\r\n\r\n\r\n**业务类**\r\n\r\n![image-20230412171528300](image/redis.assets/image-20230412171528300.png)\r\n\r\n\r\n\r\nconfig.RedisConfig（解决了后面测试的序列化问题）\r\n\r\n```java\r\n@Configuration\r\npublic class RedisConfig\r\n{\r\n    /**\r\n     * redis序列化的工具配置类，下面这个请一定开启配置\r\n     * 127.0.0.1:6379> keys *\r\n     * 1) \"ord:102\"  序列化过\r\n     * 2) \"\\xac\\xed\\x00\\x05t\\x00\\aord:102\"   野生，没有序列化过\r\n     * this.redisTemplate.opsForValue(); //提供了操作string类型的所有方法\r\n     * this.redisTemplate.opsForList(); // 提供了操作list类型的所有方法\r\n     * this.redisTemplate.opsForSet(); //提供了操作set的所有方法\r\n     * this.redisTemplate.opsForHash(); //提供了操作hash表的所有方法\r\n     * this.redisTemplate.opsForZSet(); //提供了操作zset的所有方法\r\n     * @param lettuceConnectionFactory\r\n     * @return\r\n     */\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory)\r\n    {\r\n        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();\r\n\r\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\r\n        //设置key序列化方式string\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        //设置value的序列化方式json，使用GenericJackson2JsonRedisSerializer替换默认序列化\r\n        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n\r\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\r\n\r\n        redisTemplate.afterPropertiesSet();\r\n\r\n        return redisTemplate;\r\n    }\r\n}\r\n```\r\n\r\nconfig.SwaggerConfig\r\n\r\n```java\r\n@Configuration\r\n@EnableSwagger2\r\npublic class SwaggerConfig\r\n{\r\n    @Value(\"${spring.swagger2.enabled}\")\r\n    private Boolean enabled;\r\n\r\n    @Bean\r\n    public Docket createRestApi() {\r\n        return new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                .enable(enabled)\r\n                .select()\r\n                .apis(RequestHandlerSelectors.basePackage(\"com.spongehah.redis7\")) //你自己的package\r\n                .paths(PathSelectors.any())\r\n                .build();\r\n    }\r\n    public ApiInfo apiInfo() {\r\n        return new ApiInfoBuilder()\r\n                .title(\"springboot利用swagger2构建api接口文档 \"+\"\\t\"+ DateTimeFormatter.ofPattern(\"yyyy-MM-dd\").format(LocalDateTime.now()))\r\n                .description(\"springboot+redis整合,有问题给管理员阳哥邮件:zzyybs@126.com\")\r\n                .version(\"1.0\")\r\n                .termsOfServiceUrl(\"https://www.atguigu.com/\")\r\n                .build();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\nservice.OrderService\r\n\r\n```java\r\n@Service\r\n@Slf4j\r\npublic class OrderService {\r\n    public static final String ORDER_KEY = \"ord:\";\r\n    \r\n    @Resource\r\n    private RedisTemplate redisTemplate;\r\n//    private StringRedisTemplate stringRedisTemplate;\r\n    \r\n    public void addOrder(){\r\n        int keyId = ThreadLocalRandom.current().nextInt(1000)+1;\r\n        String serialNo = UUID.randomUUID().toString();\r\n        \r\n        String key = ORDER_KEY+keyId;\r\n        String value = \"京东订单\" + serialNo;\r\n        \r\n        redisTemplate.opsForValue().set(key,value);\r\n//        stringRedisTemplate.opsForValue().set(key,value);\r\n        \r\n        log.info(\"***key:{}\",key);\r\n        log.info(\"***value:{}\",value);\r\n    }\r\n    \r\n    public String getOrderById(Integer keyId){\r\n        return (String) redisTemplate.opsForValue().get(ORDER_KEY + keyId);\r\n//        return  stringRedisTemplate.opsForValue().get(ORDER_KEY + keyId);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\ncontroller.OrderController\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\n@Api(tags = \"订单接口\")\r\npublic class OrderController {\r\n    @Resource\r\n    private OrderService orderService;\r\n    \r\n    @ApiOperation(\"新增订单\")\r\n    @RequestMapping(value = \"/order/add\",method = RequestMethod.POST)\r\n    public void addOrder(){\r\n        orderService.addOrder();\r\n    }\r\n    \r\n    @ApiOperation(\"按照keyId查询订单\")\r\n    @RequestMapping(value = \"/order/{keyId}\",method = RequestMethod.GET)\r\n    public void getOrderById(@PathVariable Integer keyId){\r\n        orderService.getOrderById(keyId);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**测试**\r\n\r\n![image-20230412195519310](image/redis.assets/image-20230412195519310.png)\r\n\r\nhttp://localhost:7777/swagger-ui.html#/\r\n\r\n**序列化问题**\r\n![image-20230412194149191](image/redis.assets/image-20230412194149191.png)\r\n\r\n第一种方案：\r\n\r\n将OrderService类中的RedisTemplate改为其子类StringRedisTemplate,此时swagger和浏览器中显示正常，若要在redis客户端中正常显示中文，redis-cli命令需要加上--raw\r\n\r\n\r\n\r\n==第二种方案：（推荐）==\r\n\r\n配置好RedisConfig类\r\n\r\n\r\n\r\n### 连接集群\r\n\r\n![image-20230412195742047](image/redis.assets/image-20230412195742047.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# POM.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.atguigu.redis7</groupId>\r\n    <artifactId>redis7_study</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.6.10</version>\r\n        <relativePath/>\r\n    </parent>\r\n\r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <maven.compiler.source>1.8</maven.compiler.source>\r\n        <maven.compiler.target>1.8</maven.compiler.target>\r\n        <junit.version>4.12</junit.version>\r\n        <log4j.version>1.2.17</log4j.version>\r\n        <lombok.version>1.16.18</lombok.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <!--guava Google 开源的 Guava 中自带的布隆过滤器-->\r\n        <dependency>\r\n            <groupId>com.google.guava</groupId>\r\n            <artifactId>guava</artifactId>\r\n            <version>23.0</version>\r\n        </dependency>\r\n        <!--SpringBoot通用依赖模块-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <!--jedis-->\r\n        <dependency>\r\n            <groupId>redis.clients</groupId>\r\n            <artifactId>jedis</artifactId>\r\n            <version>4.3.1</version>\r\n        </dependency>\r\n        <!--lettuce-->\r\n        <!--<dependency>\r\n            <groupId>io.lettuce</groupId>\r\n            <artifactId>lettuce-core</artifactId>\r\n            <version>6.2.1.RELEASE</version>\r\n        </dependency>-->\r\n        <!--SpringBoot与Redis整合依赖-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-data-redis</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.commons</groupId>\r\n            <artifactId>commons-pool2</artifactId>\r\n        </dependency>\r\n        <!--swagger2-->\r\n        <dependency>\r\n            <groupId>io.springfox</groupId>\r\n            <artifactId>springfox-swagger2</artifactId>\r\n            <version>2.9.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>io.springfox</groupId>\r\n            <artifactId>springfox-swagger-ui</artifactId>\r\n            <version>2.9.2</version>\r\n        </dependency>\r\n        <!--Mysql数据库驱动-->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.47</version>\r\n        </dependency>\r\n        <!--SpringBoot集成druid连接池-->\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid-spring-boot-starter</artifactId>\r\n            <version>1.1.10</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid</artifactId>\r\n            <version>1.1.16</version>\r\n        </dependency>\r\n        <!--mybatis和springboot整合-->\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>1.3.0</version>\r\n        </dependency>\r\n        <!--hutool-->\r\n        <dependency>\r\n            <groupId>cn.hutool</groupId>\r\n            <artifactId>hutool-all</artifactId>\r\n            <version>5.2.3</version>\r\n        </dependency>\r\n        <!--persistence-->\r\n        <dependency>\r\n            <groupId>javax.persistence</groupId>\r\n            <artifactId>persistence-api</artifactId>\r\n            <version>1.0.2</version>\r\n        </dependency>\r\n        <!--通用Mapper-->\r\n        <dependency>\r\n            <groupId>tk.mybatis</groupId>\r\n            <artifactId>mapper</artifactId>\r\n            <version>4.1.5</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-autoconfigure</artifactId>\r\n        </dependency>\r\n        <!--通用基础配置junit/devtools/test/log4j/lombok/-->\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>${junit.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>${log4j.version}</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <version>${lombok.version}</version>\r\n            <optional>true</optional>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n\r\n\r\n```\r\n\r\n​	\r\n','http://47.115.207.49/shareX/20230627/image-20230627003718952-shareX-20230627003723.png','原创',12,_binary '',_binary '',_binary '\0','2023-04-12 19:57:42','2023-07-05 16:16:24',2022576839,'Redis基本数据类型、主从、哨兵、集群、整合',NULL,NULL,'0'),(1673370844409118721,'SpringCloud+SpringCloudAlibaba笔记','# SpringCloud-SR12\r\n\r\n![image-20230507205944262](http://47.115.207.49/shareX/20230507/image-20230507205944262-shareX-20230507205945.png)\r\n\r\n![image-20230508195351399](http://47.115.207.49/shareX/20230508/image-20230508195351399-shareX-20230508195401.png)\r\n\r\n\r\n\r\n==所使用的是springcloud-SR12，笔记中所有组件都是选择的适配该版本的组件==\r\n\r\n\r\n\r\n# 服务注册中心\r\n\r\n![image-20230509213520514](http://47.115.207.49/shareX/20230509/image-20230509213520514-shareX-20230509213521.png)\r\n\r\n![image-20230510125426563](http://47.115.207.49/shareX/20230510/image-20230510125426563-shareX-20230510125427.png)\r\n\r\n\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230510/image-20230510144903537-shareX-20230510144904.png\" alt=\"image-20230510144903537\" style=\"zoom:50%;\" />\r\n\r\n![image-20230510154136587](http://47.115.207.49/shareX/20230510/image-20230510154136587-shareX-20230510154138.png)\r\n\r\n\r\n\r\n==网站客户端通过restTemplate调用网站服务端的服务==\r\n\r\n\r\n\r\n## Eureka（AP）\r\n\r\n### Eureka单机/集群配置		\r\n\r\neureka的服务端加注解==@EnableEurekaServer==\r\n\r\n```xml\r\n<!--eureka-server-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\r\n</dependency>\r\n```\r\n\r\n网站的服务端和客户端加注解==@EnableEurekaClient==\r\n\r\n```xml\r\n<!--eureka-client-->\r\n<dependency>\r\n   <groupId>org.springframework.cloud</groupId>\r\n   <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n1.当eureka为单机版时，配置文件自己注册自己，网站的服务端和客户端都是eureka客户端，都只用写一个eureka-server的地址\r\n\r\n2.当eureka为集群版时，相互注册，多者用逗号分隔，网站的服务端和客户端都是eureka客户端，都需要写全部的eureka-server的地址\r\n\r\n（可在Windows的host文件中绑定eureka端口号与名字的对应关系）\r\n\r\n### 网站服务端单机/集群配置\r\n\r\n1.当网站的当服务提供者为单机版时，网站的客户端controller中的服务端url可以写死，\r\n\r\n2.当网站的当服务提供者为集群版时，网站的客户端controller中的服务端url不能写死，可以写为服务端的注册名称，并且要在网站的客户端的config中在restTemplate的@Bean注解处加上注解==@LoadBalanced==，赋予restTemplate负载均衡的能力，才能通过网站服务提供者的注册名称得到服务\r\n\r\n### actuator微服务信息完善\r\n\r\n在网站服务端集群的每个配置文件中，在eureka下都要加上instance配置\r\n\r\n```yaml\r\neureka:    \r\n    instance:\r\n      instance-id: payment8001    #修改eureka中显示的服务名称  localhost:cloud-payment-service:8001 变为 																						payment8001\r\n      prefer-ip-address: true     #访问路径可以显示ip地址\r\n```\r\n\r\n\r\n\r\n### 服务发现Discovery\r\n\r\n在controller中注入DiscoveryClient变量，写discovery方法，并在主启动类上加注解==@EnableDiscoveryClient==\r\n\r\n### 关闭自我保护\r\n\r\n在eureka服务端配置文件中加入：\r\n\r\n```yaml\r\nserver:\r\n  #关闭自我保护机制，保证不可用服务被及时踢除\r\n  enable-self-preservation: false\r\n  eviction-interval-timer-in-ms: 2000\r\n```\r\n\r\n在网站服务端配置文件中加入：\r\n\r\n```yaml\r\n#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\r\nlease-renewal-interval-in-seconds: 1\r\n#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\r\nlease-expiration-duration-in-seconds: 2\r\n```\r\n\r\n### 配置文件集合\r\n\r\neureka服务端\r\n\r\n```yaml\r\nserver:\r\n  port: 7001\r\n\r\neureka:\r\n  instance:\r\n#  	hostname: localhost   #单机版\r\n    hostname: eureka7001.com #eureka服务端的实例名称  要在windows host文件中绑定id和名称的对应关系\r\n  client:\r\n    #false表示不向注册中心注册自己。\r\n    register-with-eureka: false\r\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\r\n    fetch-registry: false\r\n    service-url:\r\n      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\r\n      #集群版相互注册，单机版注册自己\r\n      defaultZone: http://eureka7002.com:7002/eureka/\r\n          \r\n#  server:\r\n#    #关闭自我保护机制，保证不可用服务被及时踢除\r\n#    enable-self-preservation: false\r\n#    eviction-interval-timer-in-ms: 2000\r\n```\r\n\r\n网站服务端\r\n\r\n```yaml\r\nserver:\r\n  port: 8001\r\n\r\nspring:\r\n  application:\r\n    name: cloud-payment-service\r\n  datasource:\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/db_test?useUnicode=true&characterEncoding=utf-8&userSSL-false\r\n    username: root\r\n    password: xxxxxx\r\n    \r\n    \r\nmybatis:\r\n  mapper-locations: classpath:mapper/*.xml\r\n  type-aliases-package: com.spongehah.springcloud.entities\r\n\r\neureka:\r\n  client:\r\n    #表示是否将自己注册进EurekaServer默认为true。\r\n    register-with-eureka: true\r\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\r\n    fetchRegistry: true\r\n    service-url:\r\n#      defaultZone: http://localhost:7001/eureka    #单机版\r\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka    #集群版\r\n  instance:\r\n    instance-id: payment8001    #修改eureka中显示的服务名称  localhost:cloud-payment-service:8001 变为 payment8001\r\n    prefer-ip-address: true     #访问路径可以显示ip地址\r\n          \r\n#    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\r\n#    lease-renewal-interval-in-seconds: 1\r\n#    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\r\n#    lease-expiration-duration-in-seconds: 2\r\n```\r\n\r\n网站客户端\r\n\r\n```yaml\r\nserver:\r\n  port: 8080\r\n  \r\nspring:\r\n  application:\r\n    name: cloud-order-service\r\n\r\neureka:\r\n  client:\r\n    #表示是否将自己注册进EurekaServer默认为true。\r\n    register-with-eureka: true\r\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\r\n    fetchRegistry: true\r\n    service-url:\r\n      #      defaultZone: http://localhost:7001/eureka    #单机版\r\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka    #集群版\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Zookeeper（CP）\r\n\r\n关闭linux防火墙后，启动zookeeper服务器\r\n\r\nlinux启动zookeeper：\r\n\r\n```shell\r\ncd /opt/module/zookeeper-3.5.7/bin	\r\n./zkServer.sh start		#启动zk服务器\r\n./zkCli.sh			#启动zk客户端\r\n./zkServer.sh stop\r\n./zkServer.sh status\r\nquit		#退出客户端\r\n```\r\n\r\n新建module\r\n\r\n改pom\r\n\r\n```xml\r\n<!-- SpringBoot整合zookeeper客户端 -->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\r\n            <!--若环境报错，排除自带的zookeeper3.5.3-->\r\n<!--            <exclusions>-->\r\n<!--                <exclusion>-->\r\n<!--                    <groupId>org.apache.zookeeper</groupId>-->\r\n<!--                    <artifactId>zookeeper</artifactId>-->\r\n<!--                </exclusion>-->\r\n<!--            </exclusions>-->\r\n        </dependency>\r\n        <!--添加zookeeper3.5.7版本-->\r\n        <dependency>\r\n            <groupId>org.apache.zookeeper</groupId>\r\n            <artifactId>zookeeper</artifactId>\r\n            <version>3.5.7</version>\r\n        </dependency>\r\n\r\n```\r\n\r\n写yml\r\n\r\n```yaml\r\n#8004表示注册到zookeeper服务器的支付服务提供者端口号\r\nserver:\r\n  port: 8004/80(被占用用8080)\r\n#服务别名----注册zookeeper到注册中心名称\r\nspring:\r\n  application:\r\n    name: cloud-provider-payment/cloud-consumer-order\r\n  cloud:\r\n    zookeeper:\r\n      connect-string: 192.168.111.100:2181\r\n```\r\n\r\n主启动类  		加上==@EnableDiscoveryClient==注解\r\n\r\ncontroller： 和eureka中的网站服务端客户端controller类似，网站客户端记得给restTemplate加上==@LoadBalanced==\r\n\r\n\r\n\r\n\r\n\r\n## Consul（CP）\r\n\r\nwindows启动consul：\r\n\r\n来到consul路径下，启动cmd，\r\n\r\n```shell\r\nconsul agent -dev\r\n```\r\n\r\n通过网址  http://localhost:8500  访问consul界面\r\n\r\n新建module\r\n\r\n改pom\r\n\r\n```xml\r\n<!--SpringCloud consul-server -->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n写yaml\r\n\r\n```shell\r\n###consul服务端口号\r\nserver:\r\n  port: 8006/8080\r\n\r\nspring:\r\n  application:\r\n    name: consul-provider-payment/cloud-consumer-order\r\n####consul注册中心地址\r\n  cloud:\r\n    consul:\r\n      host: localhost\r\n      port: 8500\r\n      discovery:\r\n        #hostname: 127.0.0.1\r\n        service-name: ${spring.application.name}\r\n```\r\n\r\n主启动类  		加上==@EnableDiscoveryClient==注解\r\n\r\ncontroller： 和eureka中的网站服务端客户端controller类似，网站客户端记得给restTemplate加上==@LoadBalanced==\r\n\r\n\r\n\r\n## 三个注册中心的异同点（CAP概念）\r\n\r\n![image-20230511190346678](http://47.115.207.49/shareX/20230511/image-20230511190346678-shareX-20230511190353.png)\r\n\r\n![image-20230511190502168](http://47.115.207.49/shareX/20230517/image-20230511190502168-shareX-20230511190502-shareX-20230511190527-shareX-20230517161159-shareX-20230517161209.png)\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230517/image-20230517161117543-shareX-20230517161126-shareX-20230517161235.png\"  />\r\n\r\n![image-20230511190441650](http://47.115.207.49/shareX/20230511/image-20230511190441650-shareX-20230511190441.png)\r\n\r\n![image-20230511190705880](http://47.115.207.49/shareX/20230511/image-20230511190705880-shareX-20230511190706.png)\r\n\r\n![image-20230511190719259](http://47.115.207.49/shareX/20230511/image-20230511190719259-shareX-20230511190719.png)\r\n\r\n\r\n\r\n\r\n\r\n# 服务调用1\r\n\r\n\r\n\r\n==服务调用：选取服务提供者集群中的具体某一个实例==（从8001、8002中选择一个处理客户端的请求）\r\n\r\n\r\n\r\n![image-20230511192521503](http://47.115.207.49/shareX/20230511/image-20230511192521503-shareX-20230511192521.png)\r\n\r\n## Ribbon\r\n\r\n\r\n\r\n==restTemplate实现调用服务端，@LoadBalance实现负载均衡==\r\n\r\n\r\n\r\n![image-20230511192644735](http://47.115.207.49/shareX/20230511/image-20230511192644735-shareX-20230511192645.png)\r\n\r\n```xml\r\n<!--引入eureka依赖时就会引入ribbon依赖-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\r\n</dependency>\r\n```\r\n\r\n### restTemplate的使用\r\n\r\n==@LoadBalanced==\r\n\r\n```java\r\n@Configuration\r\npublic class ApplicationContextConfig {\r\n    \r\n    @Bean\r\n//    @LoadBalanced       //赋予RestTemplate负载均衡的能力，才能通过网站服务提供者的注册名称得到服务      自写轮询算法时注释掉\r\n    public RestTemplate getRestTemplate(){\r\n        return new RestTemplate();\r\n    }\r\n}\r\n```\r\n\r\npublic static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\";\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\npublic class OrderController {\r\n    \r\n//    public static final String PAYMENT_URL = \"http://localhost:8001\";     //服务提供为单机版\r\n    public static final String PAYMENT_URL = \"http://CLOUD-PAYMENT-SERVICE\";        //服务提供为集群版，不能写死，写服务提供者的注册名称\r\n    \r\n    @Resource\r\n    private RestTemplate restTemplate;\r\n\r\n    /**\r\n     * 消费者插入时，插入了一条空数据：因为8001controller的create属性没有加@RequestBody注解,重启两个module\r\n     * @param payment\r\n     * @return\r\n     */\r\n    @GetMapping(\"/consumer/payment/create\")\r\n    public CommonResult<Payment> create(Payment payment){ \r\n        return restTemplate.postForObject(PAYMENT_URL + \"/payment/create\",payment,CommonResult.class);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n![image-20230511195014319](http://47.115.207.49/shareX/20230511/image-20230511195014319-shareX-20230511195014.png)\r\n\r\n![image-20230511195021942](http://47.115.207.49/shareX/20230511/image-20230511195021942-shareX-20230511195022.png)\r\n\r\n![](http://47.115.207.49/shareX/20230511/image-20230511195021942-shareX-20230511195022-shareX-20230511195040.png)\r\n\r\n\r\n\r\n### IRule接口替换负载均衡算法\r\n\r\n![image-20230511195733581](http://47.115.207.49/shareX/20230511/image-20230511195733581-shareX-20230511195734.png)\r\n\r\n默认为轮询算法\r\n\r\n![image-20230511200555370](http://47.115.207.49/shareX/20230511/image-20230511200555370-shareX-20230511200555.png)\r\n\r\n在客户端的主启动类的上一级包下新建一个包\r\n\r\n![image-20230511200719617](http://47.115.207.49/shareX/20230511/image-20230511200719617-shareX-20230511200719.png)\r\n\r\n在新建包下新建MySelfRule规则类\r\n\r\n```java\r\n@Configuration\r\npublic class MySelfRule\r\n{\r\n    @Bean\r\n    public IRule myRule()\r\n    {\r\n        return new RandomRule();//定义为随机\r\n    }\r\n}\r\n \r\n```\r\n\r\n在主启动类上添加@RibbonClient注解\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\",configuration=MySelfRule.class)\r\npublic class OrderMain80\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        SpringApplication.run(OrderMain80.class,args);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 负载均衡算法原理\r\n\r\n轮询算法原理：\r\n\r\n![image-20230511201741922](http://47.115.207.49/shareX/20230511/image-20230511201741922-shareX-20230511201743.png)\r\n\r\n\r\n\r\n### 手写轮询算法\r\n\r\n![image-20230511212600922](http://47.115.207.49/shareX/20230511/image-20230511212600922-shareX-20230511212601.png)\r\n\r\n1、服务端8001、8002改造：\r\n\r\n```java\r\n	//只为测试用，在实际生产中为实际的CRUD操作\r\n	@GetMapping(value = \"/payment/lb\")\r\n    public String getPaymentLB()\r\n    {\r\n        return serverPort;\r\n    }\r\n    \r\n```\r\n\r\n2、去掉@LoadBalanced注解，确保是由自己写的算法生效\r\n\r\n3、新建包lb，新建自写lb接口\r\n\r\n```java\r\npublic interface LoadBalancer\r\n{\r\n    //抽象方法\r\n    ServiceInstance instances(List<ServiceInstance> serviceInstances);\r\n}\r\n```\r\n\r\n4、新建MyLB类，实现自写的lb接口\r\n\r\n```java\r\n@Component\r\npublic class MyLB implements LoadBalancer\r\n{\r\n    private AtomicInteger atomicInteger = new AtomicInteger(0);		//初始值为0\r\n\r\n    public final int getAndIncrement()\r\n    {\r\n        int current;\r\n        int next;\r\n        do\r\n        {\r\n            current = this.atomicInteger.get();\r\n            next = current >= 2147483647 ? 0 : current + 1;\r\n        } while(!this.atomicInteger.compareAndSet(current, next));       //JUC内容，使用CAS+自旋锁减少锁的使用（当atomicInteger.get()==current,atomicInteger.set(next)）\r\n        System.out.println(\"*****next: \"+next);\r\n        return next;\r\n    }\r\n\r\n\r\n    @Override\r\n    public ServiceInstance instances(List<ServiceInstance> serviceInstances)\r\n    {\r\n        int index = getAndIncrement() % serviceInstances.size();\r\n        return serviceInstances.get(index);\r\n    }\r\n}\r\n```\r\n\r\n5、客户端80/8080改造\r\n\r\n```java\r\n	@Resource\r\n    private LoadBalancer loadBalancer;      //引入自己的写的loadBalancer\r\n    \r\n    @Resource\r\n    private DiscoveryClient discoveryClient;\r\n    \r\n	//在实际生产中，调用的是实际的CRUD操作，只是在CRUD操作前加上了选取服务的java语句\r\n    @GetMapping(\"/consumer/payment/lb\")\r\n    public String getPaymentLB(){\r\n        List<ServiceInstance> instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\");\r\n        if (instances == null || instances.size() <= 0){\r\n            return null;\r\n        }\r\n\r\n        ServiceInstance serviceInstance = loadBalancer.instances(instances);\r\n        //自写算法获取的服务的uri，若使用的是Ribbon，则通过PAYMENT_URL设置的算法自动获取\r\n        URI uri = serviceInstance.getUri();\r\n        \r\n        return restTemplate.getForObject(uri + \"/payment/lb\",String.class);\r\n    }\r\n```\r\n\r\n\r\n\r\n# 服务调用2\r\n\r\n## OpenFeign（集成Ribbon，简化开发）\r\n\r\n**Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。**\r\n\r\n**它的使用方法是<span style=\"color:red;\">定义一个服务接口然后在上面添加注解</span>。Feign也支持可拔插式的编码器和解码器。Spring Cloud**\r\n\r\n**对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡**\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230511/image-20230511215514842-shareX-20230511215515.png\" alt=\"image-20230511215514842\"  />\r\n\r\n\r\n\r\n==不再使用restTemplate，使用@EnableFejgnClients + @FeignClient(value = \"服务注册名\")实现调用服务端==\r\n\r\n==OpenFeign自带负载均衡功能，不用再加@LoadBalance注解==\r\n\r\n\r\n\r\n### OpenFeign的使用：（客户端）\r\n\r\n1、新建module，该module是客户端，不再使用原客户端（原客户端是使用的restTemplate）\r\n\r\n2、改pom：（因为也是使用的eureka注册的服务，所以要加上eureka-client的依赖）\r\n\r\n```xml\r\n		<!--openfeign-->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n        </dependency>\r\n        <!--eureka client-->\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 80\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: false		//这里没有把自己注册到eureka服务中心\r\n    service-url:\r\n      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/\r\n```\r\n\r\n4、主启动类\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableFeignClients\r\npublic class OrderFeignMain80\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        SpringApplication.run(OrderFeignMain80.class,args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n业务逻辑接口+@FeignClient配置调用provider服务\r\n\r\n（1）新建PaymentFeignService接口并新增注解@FeignClient\r\n\r\n```java\r\n@Component\r\n@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")\r\npublic interface PaymentFeignService {\r\n    \r\n    @GetMapping(\"/payment/get/{id}\")\r\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\r\n}\r\n```\r\n\r\n（2）控制层Controller\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\npublic class OrderFeignController {\r\n    \r\n    @Resource\r\n    private PaymentFeignService paymentFeignService;\r\n    \r\n    @GetMapping(\"/consumer/payment/get/{id}\")\r\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id){\r\n        return paymentFeignService.getPaymentById(id);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 超时控制\r\n\r\n==默认Feign客户端只等待一秒钟==，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。\r\n\r\n为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。\r\n\r\n==yml文件中开启配置==\r\n\r\n\r\n\r\n服务提供方8001故意写暂停程序\r\n\r\n```java\r\n@GetMapping(value = \"/payment/feign/timeout\")\r\npublic String paymentFeignTimeOut()\r\n{\r\n    System.out.println(\"*****paymentFeignTimeOut from port: \"+serverPort);\r\n    //暂停几秒钟线程\r\n    try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }\r\n    return serverPort;\r\n}\r\n```\r\n\r\n服务消费方80添加超时方法PaymentFeignService\r\n\r\n```java\r\n@GetMapping(value = \"/payment/feign/timeout\")\r\npublic String paymentFeignTimeOut();\r\n```\r\n\r\n服务消费方80添加超时方法OrderFeignController\r\n\r\n```java\r\n@GetMapping(\"/consumer/payment/feign/timeout\")\r\npublic String paymentFeignTimeOut(){\r\n    return  paymentFeignService.paymentFeignTimeOut();\r\n}\r\n```\r\n\r\n测试：  测试错误：Read timed out executing GET http://CLOUD-PAYMENT-SERVICE/payment/feign/timeout\r\n\r\n\r\n\r\n网站客户端YML文件里需要开启OpenFeign客户端超时控制\r\n\r\n```yaml\r\nfeign:\r\n  client:\r\n    config:\r\n      default:\r\n        read-timeout: 5000\r\n        connect-timeout: 5000\r\n        \r\n##爆黄，没有这个属性   也可以使用，但推荐使用feign中的属性\r\n##设置feign客户端超时时间(OpenFeign默认支持ribbon)\r\n#ribbon:\r\n#  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间\r\n#  ReadTimeout: 5000\r\n#  #指的是建立连接后从服务器读取到可用资源所用的时间\r\n#  ConnectTimeout: 5000\r\n```\r\n\r\n\r\n\r\n### OpenFeign日志打印功能\r\n\r\nFeign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。\r\n\r\n说白了就是<span style=\"color:red;\">对Feign接口的调用情况进行监控和输出</span>\r\n\r\n日志级别：\r\n\r\nNONE：默认的，不显示任何日志；\r\n\r\nBASIC：仅记录请求方法、URL、响应状态码及执行时间；\r\n\r\nHEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；\r\n\r\nFULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。\r\n\r\n\r\n\r\n\r\n\r\n开启OpenFeign日志打印功能：\r\n\r\n配置日志bean：\r\n\r\n```java\r\n@Configuration\r\npublic class FeignConfig\r\n{\r\n    @Bean\r\n    Logger.Level feignLoggerLevel()		//Logger是feign下的\r\n    {\r\n        return Logger.Level.FULL;\r\n    }\r\n}\r\n```\r\n\r\nYML文件里需要开启日志的Feign客户端：\r\n\r\n```yaml\r\nlogging:\r\n  level:\r\n    # feign日志以什么级别监控哪个接口\r\n    com.spongehah.springcloud.service.PaymentFeignService: debug\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 服务降级、熔断、限流\r\n\r\n分布式系统面临的问题\r\n\r\n<span style=\"color:red;\">复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</span>\r\n\r\n\r\n\r\n<span style=\"color:blue;\">**服务雪崩**</span>\r\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的<span style=\"color:red;\">“扇出”</span>。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.\r\n\r\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\r\n所以，\r\n通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\r\n\r\n\r\n\r\n## Hystrix\r\n\r\nHystrix是一个用于处理分布式系统的<span style=\"color:red;\">延迟</span>和<span style=\"color:red;\">容错</span>的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<span style=\"color:red;\">不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</span>\r\n\r\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），<span style=\"color:red;\">向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常</span>，这样就<span style=\"color:red;\">保证了服务调用方的线程不会被长时间、不必要地占用</span>，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\r\n\r\n\r\n\r\n**Hystrix重要概念：**\r\n\r\n服务降级(fallback)：服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示\r\n\r\n服务熔断(break)：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示\r\n\r\n服务限流(flowlimit)：秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行\r\n\r\n\r\n\r\n**哪些情况会触发服务降级：**\r\n\r\n程序运行异常\r\n\r\n超时\r\n\r\n服务熔断触发服务降级\r\n\r\n线程池/信号量打满也会导致服务降级\r\n\r\n\r\n\r\n### Hystrix新建案例模块\r\n\r\n1、新建cloud-provider-hystrix-payment8001\r\n\r\n改pom\r\n\r\n```xml\r\n<!--hystrix-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n</dependency>\r\n<!--eureka client-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n写yaml\r\n\r\n```YAML\r\nserver:\r\n  port: 8001\r\n\r\nspring:\r\n  application:\r\n    name: cloud-provider-hystrix-payment\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: true\r\n    fetch-registry: true\r\n    service-url:\r\n      #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\r\n      defaultZone: http://eureka7001.com:7001/eureka	\r\n```\r\n\r\n主启动类\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\npublic class PaymentHystrixMain8001 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentHystrixMain8001.class, args);\r\n    }\r\n    \r\n}\r\n```\r\n\r\n业务类：\r\n\r\n```java\r\n@Service\r\npublic class PaymentServiceImpl implements PaymentService {\r\n\r\n    /**\r\n     * 正常访问，一切OK\r\n     */\r\n    @Override\r\n    public String paymentInfo_OK(Integer id) {\r\n        return \"线程池:\"+Thread.currentThread().getName()+\"paymentInfo_OK,id: \"+id+\"\\t\"+\"O(∩_∩)O\";\r\n    }\r\n\r\n    /**\r\n     * 超时访问，演示降级\r\n     */\r\n    @Override\r\n    public String paymentInfo_TimeOut(Integer id) {\r\n        int timeout = 3;\r\n        try { TimeUnit.SECONDS.sleep(timeout); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        return \"线程池:\"+Thread.currentThread().getName()+\"paymentInfo_TimeOut,id: \"+id+\"\\t\"+\"O(∩_∩)O，耗费(秒)   \" + timeout;\r\n    }\r\n}\r\n\r\n\r\n\r\n@RestController\r\n@Slf4j\r\npublic class PaymentController {\r\n    \r\n    @Resource\r\n    private PaymentService paymentService;\r\n    \r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n    \r\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\r\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id){\r\n        String result = paymentService.paymentInfo_OK(id);\r\n        log.info(\"****result: \"+result);\r\n        return result;\r\n    }\r\n\r\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) throws InterruptedException\r\n    {\r\n        String result = paymentService.paymentInfo_TimeOut(id);\r\n        log.info(\"****result: \"+result);\r\n        return result;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n2、新建客户端cloud-consumer-feign-hystrix-order8080\r\n\r\n改pom\r\n\r\n```xml\r\n<!--openfeign-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n</dependency>\r\n<!--hystrix-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n</dependency>\r\n<!--eureka client-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n写yaml\r\n\r\n```yaml\r\nserver:\r\n  port: 8080\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: false\r\n    service-url:\r\n      defaultZone: http://eureka7001.com:7001/eureka/\r\n \r\n```\r\n\r\n主启动类\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableFeignClients\r\npublic class OrderHystrixMain8080 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(OrderHystrixMain8080.class, args);\r\n    }\r\n}\r\n```\r\n\r\n业务类\r\n\r\n```java\r\n@Component\r\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\")\r\npublic interface PaymentHystrixService {\r\n\r\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\r\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\r\n\r\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n@RestController\r\n@Slf4j\r\npublic class OrderHystrixController {\r\n    \r\n    @Resource\r\n    private PaymentHystrixService paymentHystrixService;\r\n\r\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\r\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\r\n    {\r\n        String result = paymentHystrixService.paymentInfo_OK(id);\r\n        return result;\r\n    }\r\n\r\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\r\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id)\r\n    {\r\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n==通过jemeter高并发测试，使得服务拥挤==\r\n\r\n**解决方案：**\r\n\r\n对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级\r\n\r\n对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级\r\n\r\n对方服务(8001)OK，调用者(80)自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级\r\n\r\n\r\n\r\n### 服务端服务降级\r\n\r\n给服务端8001主启动类添加注解==@EnableCircuitBreaker==\r\n\r\n给服务端8001 service层需要服务降级的方法添加注解==@HystrixCommand==\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableCircuitBreaker       //Hystrix注解激活标签\r\npublic class PaymentHystrixMain8001 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentHystrixMain8001.class, args);\r\n    }\r\n    \r\n}\r\n```\r\n\r\n```java\r\n@HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",commandProperties = {     //指定服务降级fallback方法\r\n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")        //指定超时上限(ms)\r\n})\r\n@Override\r\npublic String paymentInfo_TimeOut(Integer id) {\r\n    int timeout = 3;\r\n    try { TimeUnit.SECONDS.sleep(timeout); } catch (InterruptedException e) { e.printStackTrace(); }\r\n    return \"线程池:\"+Thread.currentThread().getName()+\"paymentInfo_TimeOut,id: \"+id+\"\\t\"+\"O(∩_∩)O，耗费(秒)   \" + timeout;\r\n}\r\n\r\n//paymentInfo_TimeOut方法的备选方法\r\npublic String paymentInfo_TimeOutHandler(Integer id){\r\n    return \"/(ㄒoㄒ)/8001调用支付接口超时或异常：\\t\"+ \"\\t当前线程池名字\" + Thread.currentThread().getName();\r\n}\r\n```\r\n\r\n### 客户端降级（降级一般是客户端）\r\n\r\n改yaml：==坑！！这里记得配置feign的超时控制时间，避免覆盖fallback方法设定的时间==\r\n\r\n```yanl\r\nserver:\r\n  port: 8080\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: false\r\n    service-url:\r\n      defaultZone: http://eureka7001.com:7001/eureka/\r\n\r\n#设置Feign的超时控制，避免默认时长覆盖@HystrixProperty注解的设定时长\r\nfeign:\r\n  client:\r\n    config:\r\n      default:\r\n        connect-timeout: 5000\r\n        read-timeout: 5000\r\n#  #开启@FeignClient注解的Hystrix功能，能指定fallback类\r\n#  hystrix:\r\n#    enabled: true\r\n##设置@FeignClient注解的Hystrix功能的全局超时时间\r\n#hystrix:\r\n#  command:\r\n#    default:\r\n#      execution:\r\n#        isolation:\r\n#          thread:\r\n#            timeoutInMilliseconds: 5000\r\n```\r\n\r\n给客户端80/8080主启动类添加注解==@EnableHystrix==（@EnableHystrix包含了@EnableCircuitBreaker，即@EnableHystrix继承了@EnableCircuitBreaker）\r\n\r\n给服务端80/8080 controller/service层需要服务降级的方法添加注解==@HystrixCommand==\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableFeignClients\r\n@EnableHystrix\r\npublic class OrderHystrixMain8080 {\r\n    public static void main(String[] args){\r\n        SpringApplication.run(OrderHystrixMain8080.class,args);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\r\n@HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = {\r\n        //这里设置的时间被Feign/Ribbon的客户端默认最长等待时间覆盖，还需要修改配置文件yaml\r\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"5000\")\r\n})\r\npublic String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id){\r\n    String result = paymentHystrixService.paymentInfo_TimeOut(id);\r\n    return result;\r\n}\r\npublic String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id){\r\n    return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\r\n}\r\n```\r\n\r\n### 全局fallback方法配置（减少代码膨胀）\r\n\r\n==@DefaultProperties(defaultFallback = \"\")==\r\n\r\n  1：1 每个方法配置一个服务降级方法，技术上可以，实际上傻X\r\n\r\n  1：N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = \"\")  统一跳转到统一处理结果页面\r\n\r\n   <span style=\"color:blue;\">通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量，O(∩_∩)O哈哈~</span>\r\n\r\n\r\n\r\n在对应业务类上加注解@DefaultProperties(defaultFallback = \"\")指定全局通用fallback方法，再在改业务类中写一个全局通用fallback方法，加上了@Hystrix注解但未指明独有fallback方法的方法就调用全局通用fallback方法\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")       //指定通用fallback方法\r\npublic class OrderHystrixController {\r\n\r\n    @Resource\r\n    private PaymentHystrixService paymentHystrixService;\r\n\r\n    @GetMapping(\"/consumer/payment/hystrix/ok/{id}\")\r\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id) {\r\n        String result = paymentHystrixService.paymentInfo_OK(id);\r\n        return result;\r\n    }\r\n\r\n\r\n    @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\r\n//    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\", commandProperties = {\r\n//            //这里设置的时间被Feign/Ribbon的客户端默认最长等待时间覆盖，还需要修改配置文件yaml\r\n//            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"2000\")\r\n//    })\r\n    @HystrixCommand\r\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\r\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\r\n        return result;\r\n    }\r\n\r\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id) {\r\n        return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\r\n    }\r\n\r\n    //全局fallback方法\r\n    public String payment_Global_FallbackMethod()\r\n    {\r\n        return \"Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~\";\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Service层使用Feign配置fallback类（实现解耦）\r\n\r\n==当服务端down机时，能够返回fallback类的fallback方法==\r\n\r\n\r\n\r\n改yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 8080\r\n\r\neureka:\r\n  client:\r\n    register-with-eureka: false\r\n    service-url:\r\n      defaultZone: http://eureka7001.com:7001/eureka/\r\n\r\n#设置Feign的超时控制，避免默认时长覆盖@HystrixProperty注解的设定时长\r\nfeign:\r\n  client:\r\n    config:\r\n      default:\r\n        connect-timeout: 5000\r\n        read-timeout: 5000\r\n  #开启@FeignClient注解的Hystrix功能，能指定fallback类\r\n  hystrix:\r\n    enabled: true\r\n#设置@FeignClient注解的Hystrix功能的全局超时时间\r\nhystrix:\r\n  command:\r\n    default:\r\n      execution:\r\n        isolation:\r\n          thread:\r\n            timeoutInMilliseconds: 5000\r\n```\r\n\r\n根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，\r\n重新新建一个类(PaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理\r\n\r\n```java\r\n@Component\r\npublic class PaymentFallbackService implements PaymentHystrixService{\r\n\r\n    @Override\r\n    public String paymentInfo_OK(Integer id) {\r\n        return \"-----PaymentFallbackservice fall back-paymentInfo_OK ,┭┮﹏┭┮\";\r\n    }\r\n\r\n    @Override\r\n    public String paymentInfo_TimeOut(Integer id) {\r\n        return \"-----PaymentFallbackservice fall back-paymentInfo_Timeout ,┭┮﹏┭┮\";\r\n    }\r\n}\r\n```\r\n\r\n原PaymentHystrixService接口更改@FeignClient注解，指定fallback类\r\n\r\n```java\r\n@Component\r\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\",fallback = PaymentFallbackService.class)  //使用fallback需开启feign.hystrix.enabled=true\r\npublic interface PaymentHystrixService {\r\n\r\n    @GetMapping(\"/payment/hystrix/ok/{id}\")\r\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\r\n\r\n    @GetMapping(\"/payment/hystrix/timeout/{id}\")\r\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\r\n    \r\n}\r\n```\r\n\r\n\r\n\r\n### 服务熔断break（熔断是服务端）\r\n\r\n<span style=\"color:blue;\">熔断机制概述</span>\r\n熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，\r\n会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。\r\n\r\n！！！！！！！！！！！！！\r\n\r\n==<span style=\"color:blue;\">当检测到该节点微服务调用响应正常后，恢复调用链路。</span>==\r\n\r\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，\r\n当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解也是==@HystrixCommand。==\r\n\r\n\r\n\r\n<span style=\"color:blue;\">熔断类型：</span>\r\n\r\n熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态\r\n\r\n熔断关闭：熔断关闭不会对服务进行熔断\r\n\r\n熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断\r\n\r\n\r\n\r\n涉及到断路器的三个重要参数：<span style=\"color:blue;\">快照时间窗、请求总数阀值、错误百分比阀值。</span>\r\n\r\n1：快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。\r\n\r\n2：请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。\r\n\r\n3：错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。\r\n\r\n\r\n\r\n断路器开启或者关闭的条件：\r\n\r\n​		当满足一定的阀值的时候（默认10秒内超过20个请求次数）且 当失败率达到一定的时候（默认10秒内超过50%的请求失败）\r\n\r\n​		到达以上阀值，断路器将会开启，当开启的时候，所有请求都不会进行转发\r\n\r\n​		一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5\r\n\r\n\r\n\r\n断路器打开之后：\r\n\r\n1：再有请求调用的时候，将不会调用主逻辑，而是<span style=\"color:blue;\">直接调用降级fallback</span>。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。\r\n\r\n2：原来的主逻辑要如何恢复呢？\r\n对于这一问题，hystrix也为我们实现了<span style=\"color:blue;\">自动恢复功能</span>。\r\n当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，\r\n当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，\r\n主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。\r\n\r\n\r\n\r\n修改cloud-provider-hystrix-payment8001：\r\n\r\n1、修改PaymentServiceImpl:\r\n\r\n添加以下代码：\r\n\r\n```java\r\n//=========服务熔断\r\n@Override\r\n//设置属性来源：HystrixCommandProperties类，如果不设置，有缺省值\r\n@HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\r\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),//是否开启断路器\r\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),//请求次数\r\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),//时间窗口期\r\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),//失败率达到多少后跳闸\r\n})\r\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\r\n    if(id < 0)\r\n    {\r\n        throw new RuntimeException(\"******id 不能负数\");\r\n    }\r\n    String serialNumber = IdUtil.simpleUUID();\r\n\r\n    return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\r\n}\r\npublic String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id){\r\n    return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\r\n}\r\n```\r\n\r\n2、修改PaymentController：\r\n\r\n添加以下代码：\r\n\r\n```java\r\n@GetMapping(\"/payment/circuit/{id}\")\r\npublic String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\r\n{\r\n    String result = paymentService.paymentCircuitBreaker(id);\r\n    log.info(\"****result: \"+result);\r\n    return result;\r\n}\r\n```\r\n\r\n\r\n\r\n所有的配置说明\r\n\r\n```java\r\n//========================All\r\n@HystrixCommand(fallbackMethod = \"str_fallbackMethod\",\r\n        groupKey = \"strGroupCommand\",\r\n        commandKey = \"strCommand\",\r\n        threadPoolKey = \"strThreadPool\",\r\n\r\n        commandProperties = {\r\n                // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离\r\n                @HystrixProperty(name = \"execution.isolation.strategy\", value = \"THREAD\"),\r\n                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）\r\n                @HystrixProperty(name = \"execution.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\r\n                // 配置命令执行的超时时间\r\n                @HystrixProperty(name = \"execution.isolation.thread.timeoutinMilliseconds\", value = \"10\"),\r\n                // 是否启用超时时间\r\n                @HystrixProperty(name = \"execution.timeout.enabled\", value = \"true\"),\r\n                // 执行超时的时候是否中断\r\n                @HystrixProperty(name = \"execution.isolation.thread.interruptOnTimeout\", value = \"true\"),\r\n                // 执行被取消的时候是否中断\r\n                @HystrixProperty(name = \"execution.isolation.thread.interruptOnCancel\", value = \"true\"),\r\n                // 允许回调方法执行的最大并发数\r\n                @HystrixProperty(name = \"fallback.isolation.semaphore.maxConcurrentRequests\", value = \"10\"),\r\n                // 服务降级是否启用，是否执行回调函数\r\n                @HystrixProperty(name = \"fallback.enabled\", value = \"true\"),\r\n                // 是否启用断路器\r\n                @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"),\r\n                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，\r\n                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。\r\n                @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"20\"),\r\n                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过\r\n                // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50,\r\n                // 就把断路器设置为 \"打开\" 状态，否则就设置为 \"关闭\" 状态。\r\n                @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\"),\r\n                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，\r\n                // 会将断路器置为 \"半开\" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 \"打开\" 状态，\r\n                // 如果成功就设置为 \"关闭\" 状态。\r\n                @HystrixProperty(name = \"circuitBreaker.sleepWindowinMilliseconds\", value = \"5000\"),\r\n                // 断路器强制打开\r\n                @HystrixProperty(name = \"circuitBreaker.forceOpen\", value = \"false\"),\r\n                // 断路器强制关闭\r\n                @HystrixProperty(name = \"circuitBreaker.forceClosed\", value = \"false\"),\r\n                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间\r\n                @HystrixProperty(name = \"metrics.rollingStats.timeinMilliseconds\", value = \"10000\"),\r\n                // 该属性用来设置滚动时间窗统计指标信息时划分\"桶\"的数量，断路器在收集指标信息的时候会根据\r\n                // 设置的时间窗长度拆分成多个 \"桶\" 来累计各度量值，每个\"桶\"记录了一段时间内的采集指标。\r\n                // 比如 10 秒内拆分成 10 个\"桶\"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常\r\n                @HystrixProperty(name = \"metrics.rollingStats.numBuckets\", value = \"10\"),\r\n                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。\r\n                @HystrixProperty(name = \"metrics.rollingPercentile.enabled\", value = \"false\"),\r\n                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。\r\n                @HystrixProperty(name = \"metrics.rollingPercentile.timeInMilliseconds\", value = \"60000\"),\r\n                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。\r\n                @HystrixProperty(name = \"metrics.rollingPercentile.numBuckets\", value = \"60000\"),\r\n                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，\r\n                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，\r\n                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。\r\n                @HystrixProperty(name = \"metrics.rollingPercentile.bucketSize\", value = \"100\"),\r\n                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。\r\n                @HystrixProperty(name = \"metrics.healthSnapshot.intervalinMilliseconds\", value = \"500\"),\r\n                // 是否开启请求缓存\r\n                @HystrixProperty(name = \"requestCache.enabled\", value = \"true\"),\r\n                // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中\r\n                @HystrixProperty(name = \"requestLog.enabled\", value = \"true\"),\r\n        },\r\n        threadPoolProperties = {\r\n                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量\r\n                @HystrixProperty(name = \"coreSize\", value = \"10\"),\r\n                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，\r\n                // 否则将使用 LinkedBlockingQueue 实现的队列。\r\n                @HystrixProperty(name = \"maxQueueSize\", value = \"-1\"),\r\n                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。\r\n                // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue\r\n                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。\r\n                @HystrixProperty(name = \"queueSizeRejectionThreshold\", value = \"5\"),\r\n        }\r\n)\r\npublic String strConsumer() {\r\n    return \"hello 2020\";\r\n}\r\npublic String str_fallbackMethod()\r\n{\r\n    return \"*****fall back str_fallbackMethod\";\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### Hystrix仪表盘HystrixDashboard9001\r\n\r\n新建module ： cloud-consumer-hystrix-dashboard9001\r\n\r\n改pom：	<span style=\"color:blue;\">（actuator指标监控是各种监控的必备依赖）</span>\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-actuator</artifactId>\r\n</dependency>\r\n```\r\n\r\n目前学到的拥有可视化界面的组件：\r\n\r\ndruid\r\n\r\nactuator\r\n\r\neureka\r\n\r\nswagger\r\n\r\nconsul\r\n\r\nhystrix\r\n\r\nrabbitmq\r\n\r\nzipkin\r\n\r\nnacos\r\n\r\n\r\n\r\n写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 9001\r\n\r\nhystrix:\r\n  dashboard:\r\n    proxy-stream-allow-list: \"*\"\r\n```\r\n\r\n主启动类：加上注解==@EnableHystrixDashboard==\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableHystrixDashboard\r\npublic class HystrixDashboardMain9001 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HystrixDashboardMain9001.class, args);\r\n    }\r\n}\r\n```\r\n\r\n所有Provider微服务提供类(8001/8002/8003)也都需要监控依赖配置\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-actuator</artifactId>\r\n</dependency>\r\n```\r\n\r\n注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径或者在yaml中开启hystrix.stream的指标监控\r\n\r\n```java\r\n/**\r\n *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\r\n *ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"，\r\n *只要在自己的项目里配置上下面的servlet就可以了\r\n */\r\n@Bean\r\npublic ServletRegistrationBean getServlet() {\r\n    HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\r\n    ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\r\n    registrationBean.setLoadOnStartup(1);\r\n    registrationBean.addUrlMappings(\"/hystrix.stream\");\r\n    registrationBean.setName(\"HystrixMetricsStreamServlet\");\r\n    return registrationBean;\r\n}\r\n```\r\n\r\n```yaml\r\n#与上面加Bean二选一即可\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"hystrix.stream\"\r\n```\r\n\r\n启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001：\r\n\r\nhttp://localhost:9001/hystrix\r\n\r\ndashboard中输入http://localhost:8001/actuator/hystrix.stream访问对应实例查看监控\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230513/image-20230513224938718-shareX-20230513224947.png\" alt=\"image-20230513224938718\" style=\"zoom:50%;\" />\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230513/image-20230513225002774-shareX-20230513225004.png\" alt=\"image-20230513225002774\"  />\r\n\r\n\r\n\r\n# 服务网关\r\n\r\n## Gateway\r\n\r\nGateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。\r\nGateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等\r\n\r\nSpring Cloud Gateway的目标提供统一的路由方式且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。\r\n\r\nSpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。\r\n\r\n\r\n\r\n能干嘛？    		反向代理、鉴权、流量控制、熔断、日志监控。。。。。。\r\n\r\n\r\n\r\nSpring Cloud Gateway 具有如下特性：\r\n\r\n基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；\r\n动态路由：能够匹配任何请求属性；\r\n可以对路由指定 Predicate（断言）和 Filter（过滤器）；\r\n集成Hystrix的断路器功能；\r\n集成 Spring Cloud 服务发现功能；\r\n易于编写的 Predicate（断言）和 Filter（过滤器）；\r\n请求限流功能；\r\n支持路径重写。\r\n\r\n\r\n\r\n三大核心概念：\r\n\r\nRoute(路由)：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\r\n\r\nPredicate(断言)：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，<span style=\"color:red;\">如果请求与断言相匹配则进行路由</span>\r\n\r\nFilter(过滤)：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\r\n\r\n\r\n\r\n微服务通用架构：\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230513/image-20230513225258009-shareX-20230513225300.png\" alt=\"image-20230513225258009\" style=\"zoom: 67%;\" />\r\n\r\n\r\n\r\n### 路由和断言配置（yaml）：\r\n\r\n1、新建module 	cloud-gateway-gateway9527：\r\n\r\n2、改pom：（不需要引入web-starter和actuator）\r\n\r\n```xml\r\n<!--gateway-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-gateway</artifactId>\r\n</dependency>\r\n<!--eureka-client-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 9527\r\n\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client: #服务提供者provider注册进eureka服务列表内\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\npublic class GateWayMain9527 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(GateWayMain9527.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、没有业务类\r\n\r\n6、9527网关路由映射：\r\n\r\n```yaml\r\nserver:\r\n  port: 9527\r\n\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n  cloud:\r\n    gateway:\r\n      routes:\r\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\r\n            \r\n            #访问路径localhost:9527+path的实际访问路径为：uri+path\r\n\r\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client: #服务提供者provider注册进eureka服务列表内\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n```\r\n\r\n\r\n\r\n### 路由和断言配置（Bean注入）：\r\n\r\n```java\r\n@Configuration\r\npublic class GateWayConfig\r\n{\r\n    /**\r\n     * 配置了一个id为route-name的路由规则，\r\n     * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei\r\n     * @param builder\r\n     * @return\r\n     */\r\n    @Bean\r\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder)\r\n    {\r\n        RouteLocatorBuilder.Builder routes = builder.routes();\r\n\r\n        routes.route(\"path_route_atguigu\", r -> r.path(\"/guonei\").uri(\"http://news.baidu.com/guonei\")).build();\r\n\r\n        return routes.build();\r\n\r\n    }\r\n    @Bean\r\n    public RouteLocator customRouteLocator2(RouteLocatorBuilder builder)\r\n    {\r\n        RouteLocatorBuilder.Builder routes = builder.routes();\r\n        routes.route(\"path_route_atguigu2\", r -> r.path(\"/guoji\").uri(\"http://news.baidu.com/guoji\")).build();\r\n        return routes.build();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 通过微服务名实现动态路由\r\n\r\n在上列基础上，修改yaml文件，实现动态路由和负载均衡：\r\n\r\n```yaml\r\nserver:\r\n  port: 9527\r\n\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n  cloud:\r\n    gateway:\r\n      discovery:\r\n        locator:\r\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\r\n      routes:\r\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          # uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\r\n\r\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          # uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client: #服务提供者provider注册进eureka服务列表内\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n```\r\n\r\n\r\n\r\n### 断言的具体使用：\r\n\r\n（一共九种）\r\n\r\n```yaml\r\nserver:\r\n  port: 9527\r\n\r\nspring:\r\n  application:\r\n    name: cloud-gateway\r\n  cloud:\r\n    gateway:\r\n      discovery:\r\n        locator:\r\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\r\n      routes:\r\n        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          # uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\r\n\r\n        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\r\n          # uri: http://localhost:8001          #匹配后提供服务的路由地址\r\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\r\n          predicates:\r\n            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由\r\n            - After=2023-05-14T14:42:57.342+08:00[Asia/Shanghai]      #满足这些断言才能放行\r\n            #- Before=2020-02-05T15:10:03.685+08:00[Asia/Shanghai]\r\n            #- Between=2020-02-02T17:45:06.206+08:00[Asia/Shanghai],2020-03-25T18:59:06.206+08:00[Asia/Shanghai]\r\n            #- Cookie=username,zzyy\r\n            #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\r\n            #- Host=**.atguigu.com\r\n            #- Method=GET\r\n            #- Query=username, \\d+  # 要有参数名username并且值还要是整数才能路由\r\n\r\neureka:\r\n  instance:\r\n    hostname: cloud-gateway-service\r\n  client: #服务提供者provider注册进eureka服务列表内\r\n    service-url:\r\n      register-with-eureka: true\r\n      fetch-registry: true\r\n      defaultZone: http://eureka7001.com:7001/eureka\r\n  \r\n```\r\n\r\n\r\n\r\n### 过滤器\r\n\r\n![image-20230514151736394](http://47.115.207.49/shareX/20230514/image-20230514151736394-shareX-20230514151744.png)\r\n\r\n自带的过滤GatewayFilter和Gloabal过滤器都太多，且不常用，主要用的是==自定义全局过滤器：==\r\n\r\n\r\n\r\n自认为：可以充当过滤器的：servlet原生filter，springboot-interceptor，网关的断言，网关的过滤器\r\n\r\n​				网关的过滤器是所有微服务的过滤器，而interceptor只是某个微服务自己的过滤器\r\n\r\n\r\n\r\n自定义GlobalFilter：\r\n\r\n```java\r\n@Component\r\n@Slf4j\r\npublic class MyLogGateWayFilter implements GlobalFilter, Ordered {\r\n    @Override\r\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\r\n        log.info(\"*************come in MyLogGateWayFilter:  \" + new Date());\r\n\r\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\r\n\r\n        if (uname == null) {\r\n            log.info(\"*******用户为null，非法用户，┭┮﹏┭┮\");\r\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\r\n            return exchange.getResponse().setComplete();\r\n        }\r\n\r\n        return chain.filter(exchange);\r\n    }\r\n\r\n    //设置优先级\r\n    @Override\r\n    public int getOrder() {\r\n        return 0;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 服务配置\r\n\r\n## Config\r\n\r\n![image-20230514171341136](http://47.115.207.49/shareX/20230514/image-20230514171341136-shareX-20230514171342.png)\r\n\r\n\r\n\r\n### config服务端配置与测试\r\n\r\n准备工作：\r\n\r\n1、用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository\r\n\r\n2、由上一步获得刚新建的git地址  				git@github.com:spongehah/springcloud-config.git\r\n\r\n3、本地硬盘目录上新建git仓库并clone		git clone git@github.com:spongehah/springcloud-config.git（不行使用http）\r\n\r\n\r\n\r\n新建Module模块cloud-config-center-3344\r\n它即为Cloud的配置中心模块cloudConfig Center\r\n\r\n==这里有坑==：解决踩坑参考帖子：https://blog.csdn.net/Learning_xzj/article/details/124472210?spm=1001.2014.3001.5506\r\n\r\n改pom：（需要注册进eureka）\r\n\r\n```xml\r\n<!--\r\n    坑！！！！！\r\n    这里需要引入新的依赖，因为springcloudconfig不支持较新版本的rsa公钥            \r\n-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-config-server</artifactId>\r\n    <!-- 不引入这个较旧的、没有维护的库，因为该版本不支持较新版本的RSA加密 -->\r\n    <exclusions>\r\n        <exclusion>\r\n            <groupId>com.jcraft</groupId>\r\n            <artifactId>jsch</artifactId>\r\n        </exclusion>\r\n    </exclusions>\r\n</dependency>\r\n<!-- 该版本支持较新版本的RSA（sha2-256 / sha2-512） -->\r\n<dependency>\r\n    <groupId>com.github.mwiede</groupId>\r\n    <artifactId>jsch</artifactId>\r\n    <version>0.2.0</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n写解析rsa公钥的配置：\r\n\r\n```java\r\n@Configuration\r\npublic class JschConfig {\r\n    //Shim to fix the way jGit configures JSch\r\n    static{\r\n        JSch.setConfig(\"signature.rsa\", \"com.jcraft.jsch.jce.SignatureRSA\");\r\n    }\r\n}\r\n```\r\n\r\n写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 3344\r\n\r\nspring:\r\n  application:\r\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\r\n  cloud:\r\n    config:\r\n      server:\r\n        git:\r\n          uri: git@github.com:spongehah/springcloud-config.git #GitHub上面的git仓库名字\r\n          ####搜索目录\r\n          search-paths:\r\n            - springcloud-config\r\n      ####读取分支\r\n      label: main		#新git主分支变为main\r\n\r\n#服务注册到eureka地址\r\neureka:\r\n  client:\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n \r\n```\r\n\r\n主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableConfigServer\r\npublic class ConfigCenterMain3344 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(ConfigCenterMain3344.class, args);\r\n    }\r\n}\r\n```\r\n\r\nwindows下修改hosts文件，增加映射： 	 		127.0.0.1  config-3344.com（可选）\r\n\r\n\r\n\r\n### 配置读取规则\r\n\r\n1、/{label}/{application}-{profile}.yml		eg：http://config-3344.com:3344/master/config-dev.yml\r\n\r\n2、/{application}-{profile}.yml					eg：http://config-3344.com:3344/config-dev.yml\r\n\r\n3、/{application}/{profile}[/{label}]			eg：http://config-3344.com:3344/config/dev/master\r\n\r\n\r\n\r\n### config客户端配置与测试\r\n\r\n<span style=\"color:red;\">bootstrap.yml</span>: \r\n\r\napplicaiton.yml是用户级的资源配置项\r\nbootstrap.yml是系统级的，<span style=\"color:red;\">优先级更加高</span>\r\n\r\nSpring Cloud会创建一个“Bootstrap Context”，作为Spring应用的`Application Context`的<span style=\"color:red;\">父上下文</span>。初始化的时候，`Bootstrap Context`负责从<span style=\"color:red;\">外部源</span>加载配置属性并解析配置。这两个上下文共享一个从外部获取的`Environment`。\r\n\r\n`Bootstrap`属性有高优先级，默认情况下，它们不会被本地配置覆盖。 `Bootstrap context`和`Application Context`有着不同的约定，所以新增了一个`bootstrap.yml`文件，保证`Bootstrap Context`和`Application Context`配置的分离。\r\n\r\n<span style=\"color:red;\">要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，</span>\r\n因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml\r\n\r\n\r\n\r\n1、新建cloud-config-client-3355\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-config</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写bootstrap.yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 3355\r\n\r\nspring:\r\n  application:\r\n    name: config-client\r\n  cloud:\r\n    #Config客户端配置\r\n    config:\r\n      label: main #分支名称\r\n      name: config #配置文件名称\r\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml\r\n      uri: http://localhost:3344 #配置中心地址k\r\n\r\n#服务注册到eureka地址\r\neureka:\r\n  client:\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\npublic class ConfigClientMain3355 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(ConfigClientMain3355.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n```java\r\n@RestController\r\npublic class ConfigClientController {\r\n    \r\n    @Value(\"${config.info}\")\r\n    private String configInfo;\r\n    \r\n    @GetMapping(\"/configInfo\")\r\n    public String getConfigInfo(){\r\n        return configInfo;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n坑！！！！！！！！！！！！！！！\r\n\r\n==修改git上的配置文件时，一定要注意yaml格式，冒号后面要加空格，否则config-client无法启动成功，@Value读取不到值==\r\n\r\n### config客户端之动态刷新\r\n\r\n当在github修改配置文件后，config-server会立即响应，而config-client只能重启或者重新加载才会更新\r\n\r\n所以需要动态刷新：\r\n\r\n修改3355模块：\r\n\r\npom引入actuator依赖：（除了网关都需要引入）\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-actuator</artifactId>\r\n</dependency>\r\n```\r\n\r\n修改YML，暴露监控端口：\r\n\r\n```yaml\r\n# 暴露监控端点(用于动态刷新)\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"*\"\r\n```\r\n\r\n==@RefreshScope==业务类Controller修改：\r\n\r\n```java\r\n@RestController\r\n@RefreshScope\r\npublic class ConfigClientController {\r\n    \r\n    @Value(\"${config.info}\")\r\n    private String configInfo;\r\n    \r\n    @GetMapping(\"/configInfo\")\r\n    public String getConfigInfo(){\r\n        return configInfo;\r\n    }\r\n}\r\n```\r\n\r\n需要运维人员发送Post请求刷新3355：\r\n\r\ncurl -X POST \"http://localhost:3355/actuator/refresh\"\r\n\r\n\r\n\r\n若想一次刷新，处处生效，就需要用到服务总线：看下节\r\n\r\n\r\n\r\n# 服务总线\r\n\r\n什么是总线\r\n在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。\r\n\r\n## Bus\r\n\r\nSpring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。\r\n\r\n基本原理\r\nConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。\r\n\r\nSpring Cloud Bus 配合 Spring Cloud Config 使用可以实现配置的动态刷新。\r\n\r\nSpring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，\r\n它整合了Java的事件处理机制和消息中间件的功能。\r\nSpring Clud Bus目前支持<span style=\"color:red;\">RabbitMQ和Kafka</span>\r\n\r\n### Erl+RabbitMQ环境配置\r\n\r\n安装Erlang，下载地址：http://erlang.org/download/otp_win64_21.3.exe\r\n\r\n安装RabbitMQ，下载地址：https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe\r\n\r\n进入RabbitMQ安装目录下的sbin目录，输入以下命令启动管理功能和可视化插件：rabbitmq-plugins enable rabbitmq_management\r\n\r\n访问地址查看是否安装成功：http://localhost:15672/			输入账号密码并登录：guest guest\r\n\r\n### SpringCloud Bus动态刷新全局广播\r\n\r\n设计思想：\r\n\r\n1）利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置\r\n\r\n2）<span style=\"color:red;\">利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置</span>\r\n\r\n二的架构显然更加适合，一不适合的原因如下：\r\n\r\n打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。\r\n\r\n破坏了微服务各节点的对等性。\r\n\r\n有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改\r\n\r\n\r\n\r\n1、必须先具备良好的RabbitMQ环境\r\n\r\n2、新建cloud-config-client-3366，拥有两个config-client\r\n\r\n3、改pom：\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-config</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n4、写bootstrap.yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 3366\r\n\r\nspring:\r\n  application:\r\n    name: config-client\r\n  cloud:\r\n    #Config客户端配置\r\n    config:\r\n      label: main #分支名称\r\n      name: config #配置文件名称\r\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml\r\n      uri: http://localhost:3344 #配置中心地址\r\n\r\n#服务注册到eureka地址\r\neureka:\r\n  client:\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n\r\n# 暴露监控端点(用于动态刷新)\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"*\"\r\n```\r\n\r\n5、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\npublic class ConfigClientMain3366 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(ConfigClientMain3366.class, args);\r\n    }\r\n}\r\n \r\n```\r\n\r\n6、业务类：和3355一样：\r\n\r\n```java\r\n@RestController\r\n@RefreshScope\r\npublic class ConfigClientController {\r\n    \r\n    @Value(\"${config.info}\")\r\n    private String configInfo;\r\n    \r\n    @GetMapping(\"/configInfo\")\r\n    public String getConfigInfo(){\r\n        return configInfo;\r\n    }\r\n}\r\n```\r\n\r\n7、给config-server3344	和   	config-client3355、3366添加mq-bus依赖：\r\n\r\n```xml\r\n<!--添加消息总线RabbitMQ支持-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\r\n</dependency>\r\n```\r\n\r\n8、给config-server3344添加yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 3344\r\n\r\nspring:\r\n  application:\r\n    name: cloud-config-center #注册进Eureka服务器的微服务名\r\n  cloud:\r\n    config:\r\n      server:\r\n        git:\r\n#          uri: https://github.com/spongehah/springcloud-config.git #GitHub上面的git仓库名字\r\n          uri: git@gitee.com:zhaoyingjiehaha/springcloud-config.git\r\n          ####搜索目录\r\n          search-paths:\r\n            - springcloud-config\r\n          default-label: main\r\n      ####读取分支\r\n      label: main\r\n  #rabbitmq相关配置\r\n  rabbitmq:\r\n    host: localhost\r\n    port: 5672\r\n    username: guest\r\n    password: guest \r\n      \r\n#服务注册到eureka地址\r\neureka: \r\n  client:\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n      \r\n##rabbitmq相关配置,暴露bus刷新配置的端点\r\nmanagement:\r\n  endpoints: #暴露bus刷新配置的端点\r\n    web:\r\n      exposure:\r\n        include: \'bus-refresh\'\r\n```\r\n\r\n9、给config-client3355、3366添加yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 3355/3366\r\n\r\nspring:\r\n  application:\r\n    name: config-client\r\n  cloud:\r\n    #Config客户端配置\r\n    config:\r\n      label: main #分支名称\r\n      name: config #配置文件名称\r\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://localhost:3344/master/config-dev.yml\r\n      uri: http://localhost:3344 #配置中心地址\r\n  #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口\r\n  rabbitmq:\r\n    host: localhost\r\n    port: 5672\r\n    username: guest\r\n    password: guest\r\n\r\n#服务注册到eureka地址\r\neureka:\r\n  client:\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n      \r\n# 暴露监控端点(用于动态刷新)\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"*\"\r\n```\r\n\r\n10、全局广播：git上修改配置文件后，给config-server发送post请求：curl -X POST \"http://localhost:3344/actuator/bus-refresh\"\r\n\r\n### SpringCloud Bus动态刷新定点通知\r\n\r\n指定具体某一个实例生效而不是全部 \r\n\r\n公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}\r\n\r\n我们这里以刷新运行在3355端口上的config-client为例：curl -X POST \"http://localhost:3344/actuator/bus-refresh/config-client:3355\"\r\n\r\n\r\n\r\n坑！！！！！！！！！！！！！！！\r\n\r\n==修改git上的配置文件时，一定要注意yaml格式，冒号后面要加空格，否则config-client无法启动成功，@Value读取不到值==\r\n\r\n\r\n\r\n\r\n\r\n# 服务优化\r\n\r\n## Stream消息驱动\r\n\r\n<span style=\"color:blue;\">什么是SpringCloudStream</span>：<span style=\"color:red;\">屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型</span>\r\n官方定义 Spring Cloud Stream 是一个构建消息驱动微服务的框架。\r\n\r\n应用程序通过 inputs 或者 outputs 来与 Spring Cloud Stream中binder对象交互。\r\n通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。\r\n所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。\r\n\r\n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。\r\nSpring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。\r\n\r\n目前仅支持<span style=\"color:red;\">RabbitMQ和Kafka</span>\r\n\r\n\r\n\r\n通过定义绑定器作为中间层，完美地实现了<span style=\"color:red;\">应用程序与消息中间件细节之间的隔离</span>。\r\n通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。\r\n\r\n![image-20230516132509415](http://47.115.207.49/shareX/20230516/image-20230516132509415-shareX-20230516132517.png)\r\n\r\n==Stream中的消息通信方式遵循了发布-订阅模式，Topic主题进行广播，在RabbitMQ就是Exchange，在Kakfa中就是Topic==\r\n\r\n\r\n\r\nSpring Cloud Stream标准流程套路：\r\n\r\nBinder：很方便的连接中间件，屏蔽差异\r\n\r\nChannel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置\r\n\r\nSource和Sink：简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230516/image-20230516132942813-shareX-20230516132944.png\" alt=\"image-20230516132942813\"  />\r\n\r\n![image-20230516133057166](http://47.115.207.49/shareX/20230516/image-20230516133057166-shareX-20230516133058.png)\r\n\r\n### 消息驱动之生产者配置\r\n\r\n先搭建好kafka或者rabbitMQ的环境\r\n\r\n1、新建module		cloud-stream-rabbitmq-provider8801\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：（爆红不管）\r\n\r\n```yaml\r\nserver:\r\n  port: 8801\r\n\r\nspring:\r\n  application:\r\n    name: cloud-stream-provider\r\n  cloud:\r\n    stream:\r\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\r\n        defaultRabbit: # 表示定义的名称，用于于binding整合\r\n          type: rabbit # 消息组件类型\r\n          environment: # 设置rabbitmq的相关的环境配置\r\n            spring:\r\n              rabbitmq:\r\n                host: localhost\r\n                port: 5672\r\n                username: guest\r\n                password: guest\r\n      bindings: # 服务的整合处理\r\n        output: # 这个名字是一个通道的名称\r\n          destination: studyExchange # 表示要使用的Exchange名称定义\r\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\r\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\r\n\r\neureka:\r\n  client: # 客户端进行Eureka注册的配置\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n  instance:\r\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\r\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\r\n    instance-id: send-8801.com  # 在信息列表时显示主机名称\r\n    prefer-ip-address: true     # 访问的路径变为IP地址\r\n```\r\n\r\n4、主启动类\r\n\r\n```java\r\n@SpringBootApplication\r\npublic class StreamMQMain8801 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(StreamMQMain8801.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类\r\n\r\n发送消息接口IMessageProvider\r\n\r\n```java\r\npublic interface IMessageProvider {\r\n    public String send();\r\n}\r\n```\r\n\r\n发送消息接口实现类MessageProviderImpl \r\n\r\n```java\r\npackage com.spongehah.springcloud.service.impl;\r\n\r\nimport com.spongehah.springcloud.service.IMessageProvider;\r\nimport org.springframework.cloud.stream.annotation.EnableBinding;\r\nimport org.springframework.cloud.stream.messaging.Source;\r\nimport org.springframework.integration.support.MessageBuilder;\r\nimport org.springframework.messaging.MessageChannel;\r\n\r\nimport javax.annotation.Resource;\r\nimport java.util.UUID;\r\n\r\n@EnableBinding(Source.class)// 可以理解为是一个消息的发送管道的定义\r\npublic class MessageProviderImpl implements IMessageProvider {\r\n    \r\n    @Resource\r\n    private MessageChannel output;\r\n\r\n    @Override\r\n    public String send() {\r\n        String serial = UUID.randomUUID().toString();\r\n        this.output.send(MessageBuilder.withPayload(serial).build()); // 创建并发送消息\r\n        System.out.println(\"***serial: \" + serial);\r\n        return serial;\r\n    }\r\n}\r\n```\r\n\r\nController\r\n\r\n```java\r\n@RestController\r\npublic class SendMessageController {\r\n    \r\n    @Resource\r\n    private IMessageProvider messageProvider;\r\n    \r\n    @GetMapping(\"/sendMessage\")\r\n    public String sendMessage(){\r\n        return messageProvider.send();\r\n    }\r\n}\r\n```\r\n\r\n### 消息驱动之消费者配置\r\n\r\n1、新建module		cloud-stream-rabbitmq-consumer8802\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 8802\r\n\r\nspring:\r\n  application:\r\n    name: cloud-stream-consumer\r\n  cloud:\r\n    stream:\r\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\r\n        defaultRabbit: # 表示定义的名称，用于于binding整合\r\n          type: rabbit # 消息组件类型\r\n          environment: # 设置rabbitmq的相关的环境配置\r\n            spring:\r\n              rabbitmq:\r\n                host: localhost\r\n                port: 5672\r\n                username: guest\r\n                password: guest\r\n      bindings: # 服务的整合处理\r\n        input: # 这个名字是一个通道的名称\r\n          destination: studyExchange # 表示要使用的Exchange名称定义\r\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\r\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\r\n\r\neureka:\r\n  client: # 客户端进行Eureka注册的配置\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n  instance:\r\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\r\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\r\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\r\n    prefer-ip-address: true     # 访问的路径变为IP地址\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\npublic class StreamMQMain8802 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(StreamMQMain8802.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n```java\r\npackage com.spongehah.springcloud.listener;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.cloud.stream.annotation.EnableBinding;\r\nimport org.springframework.cloud.stream.annotation.StreamListener;\r\nimport org.springframework.cloud.stream.messaging.Sink;\r\nimport org.springframework.messaging.Message;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\n@EnableBinding(Sink.class)\r\npublic class ReceiveMessageListener {\r\n    \r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n    \r\n    @StreamListener(Sink.INPUT)\r\n    public void input(Message<String> message){\r\n        System.out.println(\"消费者1号，------->接收到的消息：\" + message.getPayload()+\"\\t port: \"+serverPort);\r\n    }\r\n}\r\n```\r\n\r\n测试8801看8802能不能收到消息\r\n\r\n\r\n\r\n### 分组消费与持久化\r\n\r\n==重复消费问题：==\r\n\r\n不指定消费者group时，系统会自动分配给两个消费者不同的组别，若两个微服务属于同一种微服务类型，就会造成重复消费，所以要把相同类型的微服务放到同一个group中\r\n\r\n\r\n\r\n1、将8802复制一份为8803，更改名字和端口号即可\r\n\r\n2、http://localhost:8801/sendMessage				目前是8802/8803同时都收到了，存在重复消费问题\r\n\r\n3、分组：\r\n\r\n==微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。==\r\n不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。\r\n\r\n更改group：\r\n\r\n```yaml\r\nserver:\r\n  port: 8802\r\n\r\nspring:\r\n  application:\r\n    name: cloud-stream-consumer\r\n  cloud:\r\n    stream:\r\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\r\n        defaultRabbit: # 表示定义的名称，用于于binding整合\r\n          type: rabbit # 消息组件类型\r\n          environment: # 设置rabbitmq的相关的环境配置\r\n            spring:\r\n              rabbitmq:\r\n                host: localhost\r\n                port: 5672\r\n                username: guest\r\n                password: guest\r\n      bindings: # 服务的整合处理\r\n        input: # 这个名字是一个通道的名称\r\n          destination: studyExchange # 表示要使用的Exchange名称定义\r\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\r\n          binder: defaultRabbit # 设置要绑定的消息服务的具体设置\r\n          group: spongehahA   #设置消费组，避免重复消费问题和消息丢失问题\r\n\r\neureka:\r\n  client: # 客户端进行Eureka注册的配置\r\n    service-url:\r\n      defaultZone: http://localhost:7001/eureka\r\n  instance:\r\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\r\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\r\n    instance-id: receive-8802.com  # 在信息列表时显示主机名称\r\n    prefer-ip-address: true     # 访问的路径变为IP地址\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n==持久化：==\r\n\r\n当配置好group时，就拥有了持久化，配置好group后，当消费者down机重启时，未消费过的消息也会被读取到\r\n\r\n若未配置group，当消费者down机重启时，未消费过的消息不会再被读取到，出现消息==丢失问题==\r\n\r\n\r\n\r\n## Sleuth分布式请求链路跟踪\r\n\r\n 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。\r\n\r\nSpring Cloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin\r\n\r\n\r\n\r\n一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来\r\n\r\nTrace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识\r\n\r\nspan:表示调用链路来源，通俗的理解span就是一次请求信息\r\n\r\n### zipkin环境安装\r\n\r\nhttps://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/下载jar包\r\n\r\n目录下找到jar包，使用java -jar命令运行jar包\r\n\r\n网页控制台：http://localhost:9411/zipkin/\r\n\r\n### 案例\r\n\r\n在cloud-provider-payment8001中：\r\n\r\n改pom：\r\n\r\n```xml\r\n<!--包含了sleuth+zipkin-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\r\n</dependency>\r\n```\r\n\r\n改yaml：（spring：下加入zipkin和sleuth部分）\r\n\r\n```yaml\r\nspring:\r\n  application:\r\n    name: cloud-payment-service\r\n  zipkin:\r\n    base-url: http://localhost:9411\r\n  sleuth:\r\n    sampler:\r\n      #采样率值介于 0 到 1 之间，1 则表示全部采集,一般写0.5\r\n      probability: 1\r\n  datasource:\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/db_test?useUnicode=true&characterEncoding=utf-8&userSSL-false\r\n    username: root\r\n    password: 123456\r\n```\r\n\r\ncontroller：\r\n\r\n```java\r\n@GetMapping(\"/payment/zipkin\")\r\npublic String paymentZipkin() {\r\n    return \"hi ,i\'am paymentzipkin server fall back，welcome to atguigu，O(∩_∩)O哈哈~\";\r\n}\r\n```\r\n\r\n\r\n\r\n在cloud-consumer-order80中：\r\n\r\n改pom：\r\n\r\n```xml\r\n<!--包含了sleuth+zipkin-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\r\n</dependency>\r\n```\r\n\r\n改yaml：\r\n\r\n```yaml\r\nspring:\r\n  application:\r\n    name: cloud-order-service\r\n  zipkin:\r\n    base-url: http://localhost:9411\r\n  sleuth:\r\n    sampler:\r\n      #采样率值介于 0 到 1 之间，1 则表示全部采集,一般写0.5\r\n      probability: 1\r\n```\r\n\r\ncontroller：\r\n\r\n```java\r\n// ====================> zipkin+sleuth\r\n@GetMapping(\"/consumer/payment/zipkin\")\r\npublic String paymentZipkin() {\r\n    String result = restTemplate.getForObject(\"http://localhost:8001\"+\"/payment/zipkin/\", String.class);\r\n    return result;\r\n}\r\n```\r\n\r\n\r\n\r\n# SpringcloudAlibaba-2.2.8RELEASE\r\n\r\n![image-20230516203908008](http://47.115.207.49/shareX/20230516/image-20230516203908008-shareX-20230516203910.png)\r\n\r\n# Nacos\r\n\r\n版本参考目录		SpringcloudAlibaba		处的表格对照，这里选用的是2.1.0\r\n\r\n\r\n\r\nNacos就是注册中心 + 配置中心的组合\r\n\r\nNacos = Eureka+Config +Bus\r\n\r\n\r\n\r\n安装运行Nacos：\r\n\r\n本地Java8+Maven环境已经OK\r\n\r\n先从官网下载Nacos\r\n\r\n解压安装包，直接运行bin目录下的startup.cmd\r\n\r\n（较新版本的nacos默认启动方式为集群cluster模式，运行前先修改startup.cmd文件，将mode修改为standalone）且安装目录不能有中文\r\n\r\n命令运行成功后直接访问http://localhost:8848/nacos		默认账号密码都是nacos\r\n\r\n## Nacos作为注册中心（AP）\r\n\r\n### 网站服务端\r\n\r\n1、新建module：	cloudalibaba-provider-payment9001\r\n\r\n2、改pom：\r\n\r\n父项目pom：\r\n\r\n```xml\r\n<!--spring cloud alibaba 2.2.8.RELEASE-->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-alibaba-dependencies</artifactId>\r\n    <version>${spring-cloud-alibaba.version}</version>\r\n    <type>pom</type>\r\n    <scope>import</scope>\r\n</dependency>\r\n```\r\n\r\nmodule的pom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 9001\r\n\r\nspring:\r\n  application:\r\n    name: nacos-payment-provider\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #配置Nacos地址\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class PaymentMain9001 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentMain9001.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n```java\r\n@RestController\r\npublic class PaymentController {\r\n\r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n\r\n    @GetMapping(value = \"/payment/nacos/{id}\")\r\n    public String getPayment(@PathVariable(\"id\") Integer id) {\r\n        return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id;\r\n    }\r\n}\r\n```\r\n\r\n6、新建9002构成网站服务端集群，因为配置和9001完全一样，故使用copy configuration复制一个相同的环境使用虚拟端口映射，使用9002号端口进行启动\r\n\r\nname：PaymentMain9002 CopyOf 9001\r\n\r\nVM options：-DServer.port=9002\r\n\r\n\r\n\r\n### 网站客户端/消费端ribbon版（使用restRemplate）\r\n\r\n1、新建module：		cloudalibaba-consumer-nacos-order83\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 83\r\n\r\n\r\nspring:\r\n  application:\r\n    name: nacos-order-consumer\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848\r\n\r\n\r\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\r\nservice-url:\r\n  nacos-user-service: http://nacos-payment-provider \r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class OrderNacosMain83 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(OrderNacosMain83.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：ribbon版（使用restRemplate）\r\n\r\n写config：\r\n\r\n```java\r\n@Configuration\r\npublic class ApplicationContextConfig {\r\n    \r\n    @Bean\r\n    @LoadBalanced\r\n    public RestTemplate getRestTemplate(){\r\n        return new RestTemplate();\r\n    }\r\n}\r\n```\r\n\r\ncontroller：\r\n\r\n```java\r\n@RestController\r\npublic class OrderNacosController {\r\n    \r\n    @Resource\r\n    private RestTemplate restTemplate;\r\n    \r\n    @Value(\"${service-url.nacos-user-service}\")\r\n    private String serverURL;\r\n\r\n    @GetMapping(\"/consumer/payment/nacos/{id}\")\r\n    public String paymentInfo(@PathVariable(\"id\") Long id) {\r\n        return restTemplate.getForObject(serverURL+\"/payment/nacos/\"+id,String.class);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### 网站客户端/消费端Feign版\r\n\r\n1、新建module：			cloudalibaba-consumer-nacos-feign-order83\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n<!--openfeign-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 83\r\n\r\n\r\nspring:\r\n  application:\r\n    name: nacos-order-consumer\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableFeignClients\r\n@EnableDiscoveryClient\r\npublic class OrderNacosFeignMain83 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(OrderNacosFeignMain83.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n业务逻辑接口+@FeignClient配置调用provider服务\r\n\r\n（1）新建PaymentFeignService接口并新增注解@FeignClient\r\n\r\n```java\r\n@Component\r\n@FeignClient(name = \"nacos-payment-provider\")\r\npublic interface PaymentFeignService {\r\n    \r\n    @GetMapping(value = \"/payment/nacos/{id}\")\r\n    public String getPayment(@PathVariable(\"id\") Integer id);\r\n}\r\n```\r\n\r\n（2）controller：\r\n\r\n```java\r\n@RestController\r\npublic class OrderNacosFeignController {\r\n    \r\n    @Resource\r\n    private PaymentFeignService paymentFeignService;\r\n\r\n    @GetMapping(\"/consumer/payment/nacos/{id}\")\r\n    public String paymentInfo(@PathVariable(\"id\") Integer id) {\r\n        return paymentFeignService.getPayment(id);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### Nacos与其他服务注册中心的对比\r\n\r\n<span style=\"color:red;\">C是所有节点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。</span>\r\n\r\n何时选择使用何种模式？\r\n一般来说，\r\n如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如 Spring cloud 和 Dubbo 服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。\r\n\r\n如果需要在服务级别编辑或者存储配置信息，那么 CP 是必须，K8S服务和DNS服务则适用于CP模式。\r\nCP模式下则支持注册持久化实例，此时则是以 Raft 协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。\r\n\r\n<span style=\"color:red;\">Nacos 支持AP和CP模式的切换</span>\r\n\r\n\r\ncurl -X PUT \'$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&value=CP\'\r\n\r\n## Nacos作为配置中心\r\n\r\n### 基础配置\r\n\r\n1、新建module：			cloudalibaba-config-nacos-client3377\r\n\r\n2、改pom：\r\n\r\n```xml\r\n<!--nacos-config-->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\r\n</dependency>\r\n<!--nacos-discovery-->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n```\r\n\r\n3、写yaml：\r\n\r\nNacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，\r\n拉取配置之后，才能保证项目的正常启动。\r\n\r\nspringboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application\r\n\r\n这里要写bootstrap.yaml + application.yaml:\r\n\r\nbootstrap.yaml:\r\n\r\n```yaml\r\n# nacos配置\r\nserver:\r\n  port: 3377\r\n\r\nspring:\r\n  application:\r\n    name: nacos-config-client\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #Nacos服务注册中心地址\r\n      config:\r\n        server-addr: localhost:8848 #Nacos作为配置中心地址\r\n        file-extension: yaml #指定yaml格式的配置\r\n\r\n\r\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\r\n```\r\n\r\napplication.yaml:\r\n\r\n```yaml\r\nspring:\r\n  profiles:\r\n    active: dev # 表示开发环境\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class NacosConfigClientMain3377 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(NacosConfigClientMain3377.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、业务类：\r\n\r\n```java\r\n@RestController\r\n@RefreshScope//在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。\r\npublic class ConfigClientController {\r\n\r\n    @Value(\"${config.info}\")\r\n    private String configInfo;\r\n\r\n    @GetMapping(\"/config/info\")\r\n    public String getConfigInfo() {\r\n        return configInfo;\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 配置读取规则\r\n\r\n新增、修改配置：\r\n\r\n==注意前面的坑：注意yaml文件的缩进格式，冒号后面不要漏写空格==\r\n\r\n在http://localhost:8848/nacos/页面新增修改配置文件\r\n\r\n公式：		${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230517/image-20230517170901825-shareX-20230517170902.png\" alt=\"image-20230517170901825\" style=\"zoom: 80%;\" />\r\n\r\nNacos会记录配置文件的历史版本默认保留30天，此外还有==一键回滚==功能，回滚操作将会触发配置更新\r\n\r\n==自带动态刷新：==（	已经加上了@RefreshScope）\r\n\r\n修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新\r\n\r\n\r\n\r\n### 三种方案加载配置\r\n\r\nNamespace+Group+Data ID三者关系？为什么这么设计？\r\n\r\n默认情况：\r\nNamespace=public，Group=DEFAULT_GROUP, 默认Cluster是DEFAULT\r\n\r\nNacos默认的命名空间是public，Namespace主要用来实现隔离。\r\n比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。\r\n\r\nGroup默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去\r\n\r\nService就是微服务；一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。\r\n比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，\r\n这时就可以给杭州机房的Service微服务起一个集群名称（HZ），\r\n给广州机房的Service微服务起一个集群名称（GZ），还可以尽量让同一个机房的微服务互相调用，以提升性能。\r\n\r\n最后是Instance，就是微服务的实例。\r\n\r\n\r\n\r\n==DataID方案==：\r\n\r\n指定application.yaml配置文件中spring.profile.active的值和Nacos服务端配置文件的DataID来使不同环境下读取不同的配置\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230517/image-20230517175103150-shareX-20230517175104.png\" alt=\"image-20230517175103150\" style=\"zoom: 67%;\" />\r\n\r\n==Group方案==：\r\n\r\n通过Group实现环境区分\r\n\r\n在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP\r\n\r\n\r\n\r\n指定bootstrap.yaml下nacos.config.group的值和application.yaml中spring.profile.active的值且与nacos中心的对应值相等\r\n\r\n修改bootstrap.yaml：\r\n\r\n```yaml\r\n# nacos配置\r\nserver:\r\n  port: 3377\r\n\r\nspring:\r\n  application:\r\n    name: nacos-config-client\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #Nacos服务注册中心地址\r\n      config:\r\n        server-addr: localhost:8848 #Nacos作为配置中心地址\r\n        file-extension: yaml #指定yaml格式的配置\r\n        group: DEV_GROUP #指定nacos中心配置文件的分组\r\n\r\n\r\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\r\n# nacos-config-client-dev.yaml\r\n```\r\n\r\napplication.yaml：\r\n\r\n```yaml\r\nspring:\r\n  profiles:\r\n    active: dev # 表示开发环境\r\n#    active: test # 表示测试环境\r\n```\r\n\r\n==Namespace方案==：\r\n\r\n指定bootstrap.yaml下nacos.config.group和namespace的值和application.yaml中spring.profile.active的值且与nacos中心的对应值相等\r\n\r\nbootstrap.yaml：\r\n\r\n```yaml\r\n# nacos配置\r\nserver:\r\n  port: 3377\r\n\r\nspring:\r\n  application:\r\n    name: nacos-config-client\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #Nacos服务注册中心地址\r\n      config:\r\n        server-addr: localhost:8848 #Nacos作为配置中心地址\r\n        file-extension: yaml #指定yaml格式的配置\r\n        group: DEV_GROUP #指定nacos中心配置文件的分组\r\n        namespace: deve9a0eac7-5df9-4a4b-beae-5ac71df2e76e   #指定nacos中心配置文件的命名空间\r\n\r\n\r\n# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}\r\n# nacos-config-client-dev.yaml\r\n```\r\n\r\napplication.yaml：\r\n\r\n```yaml\r\nspring:\r\n  profiles:\r\n    active: dev # 表示开发环境\r\n#    active: test # 表示测试环境\r\n```\r\n\r\n\r\n\r\n## Nacos集群和持久化配置\r\n\r\n### Windows版持久化（设置为mysql数据库）\r\n\r\nNacos默认自带的是嵌入式数据库derby，nacos集群中一台nacos一个数据库，按照上述，我们需要mysql数据库，统一nacos集群之间的数据来源\r\n\r\n![image-20230517193253725](http://47.115.207.49/shareX/20230517/image-20230517193253725-shareX-20230517193255.png)\r\n\r\nnacos-server-1.1.4\\nacos\\conf目录下找到nacos-mysql.sql脚本，在mysql中执行脚本\r\n```sql\r\n/*\r\n * Copyright 1999-2018 Alibaba Group Holding Ltd.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = config_info   */\r\n/******************************************/\r\nCREATE TABLE `config_info` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\r\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\r\n  `group_id` varchar(255) DEFAULT NULL,\r\n  `content` longtext NOT NULL COMMENT \'content\',\r\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\r\n  `src_user` text COMMENT \'source user\',\r\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\r\n  `app_name` varchar(128) DEFAULT NULL,\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\r\n  `c_desc` varchar(256) DEFAULT NULL,\r\n  `c_use` varchar(64) DEFAULT NULL,\r\n  `effect` varchar(64) DEFAULT NULL,\r\n  `type` varchar(64) DEFAULT NULL,\r\n  `c_schema` text,\r\n  `encrypted_data_key` text NOT NULL COMMENT \'秘钥\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info\';\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = config_info_aggr   */\r\n/******************************************/\r\nCREATE TABLE `config_info_aggr` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\r\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\r\n  `group_id` varchar(255) NOT NULL COMMENT \'group_id\',\r\n  `datum_id` varchar(255) NOT NULL COMMENT \'datum_id\',\r\n  `content` longtext NOT NULL COMMENT \'内容\',\r\n  `gmt_modified` datetime NOT NULL COMMENT \'修改时间\',\r\n  `app_name` varchar(128) DEFAULT NULL,\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'增加租户字段\';\r\n\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = config_info_beta   */\r\n/******************************************/\r\nCREATE TABLE `config_info_beta` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\r\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\r\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\r\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\r\n  `content` longtext NOT NULL COMMENT \'content\',\r\n  `beta_ips` varchar(1024) DEFAULT NULL COMMENT \'betaIps\',\r\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\r\n  `src_user` text COMMENT \'source user\',\r\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\r\n  `encrypted_data_key` text NOT NULL COMMENT \'秘钥\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info_beta\';\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = config_info_tag   */\r\n/******************************************/\r\nCREATE TABLE `config_info_tag` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\r\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\r\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'tenant_id\',\r\n  `tag_id` varchar(128) NOT NULL COMMENT \'tag_id\',\r\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\r\n  `content` longtext NOT NULL COMMENT \'content\',\r\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\r\n  `src_user` text COMMENT \'source user\',\r\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info_tag\';\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = config_tags_relation   */\r\n/******************************************/\r\nCREATE TABLE `config_tags_relation` (\r\n  `id` bigint(20) NOT NULL COMMENT \'id\',\r\n  `tag_name` varchar(128) NOT NULL COMMENT \'tag_name\',\r\n  `tag_type` varchar(64) DEFAULT NULL COMMENT \'tag_type\',\r\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\r\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'tenant_id\',\r\n  `nid` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  PRIMARY KEY (`nid`),\r\n  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),\r\n  KEY `idx_tenant_id` (`tenant_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_tag_relation\';\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = group_capacity   */\r\n/******************************************/\r\nCREATE TABLE `group_capacity` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'主键ID\',\r\n  `group_id` varchar(128) NOT NULL DEFAULT \'\' COMMENT \'Group ID，空字符表示整个集群\',\r\n  `quota` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'配额，0表示使用默认值\',\r\n  `usage` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'使用量\',\r\n  `max_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个配置大小上限，单位为字节，0表示使用默认值\',\r\n  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'聚合子配置最大个数，，0表示使用默认值\',\r\n  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值\',\r\n  `max_history_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'最大变更历史数量\',\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_group_id` (`group_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'集群、各Group容量信息表\';\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = his_config_info   */\r\n/******************************************/\r\nCREATE TABLE `his_config_info` (\r\n  `id` bigint(64) unsigned NOT NULL,\r\n  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `data_id` varchar(255) NOT NULL,\r\n  `group_id` varchar(128) NOT NULL,\r\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\r\n  `content` longtext NOT NULL,\r\n  `md5` varchar(32) DEFAULT NULL,\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\r\n  `src_user` text,\r\n  `src_ip` varchar(50) DEFAULT NULL,\r\n  `op_type` char(10) DEFAULT NULL,\r\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\r\n  `encrypted_data_key` text NOT NULL COMMENT \'秘钥\',\r\n  PRIMARY KEY (`nid`),\r\n  KEY `idx_gmt_create` (`gmt_create`),\r\n  KEY `idx_gmt_modified` (`gmt_modified`),\r\n  KEY `idx_did` (`data_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'多租户改造\';\r\n\r\n\r\n/******************************************/\r\n/*   数据库全名 = nacos_config   */\r\n/*   表名称 = tenant_capacity   */\r\n/******************************************/\r\nCREATE TABLE `tenant_capacity` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'主键ID\',\r\n  `tenant_id` varchar(128) NOT NULL DEFAULT \'\' COMMENT \'Tenant ID\',\r\n  `quota` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'配额，0表示使用默认值\',\r\n  `usage` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'使用量\',\r\n  `max_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个配置大小上限，单位为字节，0表示使用默认值\',\r\n  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'聚合子配置最大个数\',\r\n  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值\',\r\n  `max_history_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'最大变更历史数量\',\r\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_tenant_id` (`tenant_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'租户容量信息表\';\r\n\r\n\r\nCREATE TABLE `tenant_info` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\r\n  `kp` varchar(128) NOT NULL COMMENT \'kp\',\r\n  `tenant_id` varchar(128) default \'\' COMMENT \'tenant_id\',\r\n  `tenant_name` varchar(128) default \'\' COMMENT \'tenant_name\',\r\n  `tenant_desc` varchar(256) DEFAULT NULL COMMENT \'tenant_desc\',\r\n  `create_source` varchar(32) DEFAULT NULL COMMENT \'create_source\',\r\n  `gmt_create` bigint(20) NOT NULL COMMENT \'创建时间\',\r\n  `gmt_modified` bigint(20) NOT NULL COMMENT \'修改时间\',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),\r\n  KEY `idx_tenant_id` (`tenant_id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'tenant_info\';\r\n\r\nCREATE TABLE `users` (\r\n	`username` varchar(50) NOT NULL PRIMARY KEY,\r\n	`password` varchar(500) NOT NULL,\r\n	`enabled` boolean NOT NULL\r\n);\r\n\r\nCREATE TABLE `roles` (\r\n	`username` varchar(50) NOT NULL,\r\n	`role` varchar(50) NOT NULL,\r\n	UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE\r\n);\r\n\r\nCREATE TABLE `permissions` (\r\n    `role` varchar(50) NOT NULL,\r\n    `resource` varchar(255) NOT NULL,\r\n    `action` varchar(8) NOT NULL,\r\n    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE\r\n);\r\n\r\nINSERT INTO users (username, password, enabled) VALUES (\'nacos\', \'$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu\', TRUE);\r\n\r\nINSERT INTO roles (username, role) VALUES (\'nacos\', \'ROLE_ADMIN\');\r\n\r\n```\r\n\r\nnacos-server-1.1.4\\nacos\\conf目录下找到application.properties:\r\n\r\n```properties\r\nspring.datasource.platform=mysql\r\n\r\ndb.num=1\r\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&serverTimezone=GMT%2B8\r\ndb.user=root		#自己的mysql用户名\r\ndb.password=123456		#自己的mysql密码\r\n```\r\n\r\n重新启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby\r\n\r\n\r\n\r\n### Nacos2.x集群配置步骤(重点)\r\n\r\n\r\n\r\n<span style=\"color:red;\">因选用的是nacos2.x版本，采用网上很多教学踩了很多坑，用了两天才把坑圆过来呜呜呜</span>(主要是nginx/VIP转发的配置)\r\n\r\n\r\n\r\n#### ==linux安装Nacos：==\r\n\r\n下载nacos.tar.gz包到/opt/下\r\n\r\n使用tar -zxvf nacos.tar.gz命令解压\r\n\r\n将解压出来的nacos包复制到/mynacos/nacos				cp -r nacos /mynacos/nacos\r\n\r\ncd /mynacos/bin\r\n\r\n./startup.sh\r\n\r\n\r\n\r\n#### ==nacos2.x集群配置：==(三台才能构成集群)\r\n\r\n1、修改nacos持久化：\r\n\r\n```shell\r\nvim /mynacos/nacos/conf/application.properties\r\n```\r\n\r\n```properties\r\nspring.datasource.platform=mysql\r\n\r\ndb.num=1\r\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&serverTimezone=GMT%2B8\r\ndb.user.0=root		#自己的mysql用户名\r\ndb.password.0=123456		#自己的mysql密码\r\n```\r\n\r\n2、创建nacos_config数据库，并执行nacos提供的nacos-mysql.sql脚本 ，脚本文件放在 conf/nacos-mysql.sql:\r\n\r\n3、修改 nacos 的集群配置:\r\n\r\n进入到 conf 目录中，将集群文件拷贝一份以便进行后续的操作:\r\n\r\n```shell\r\ncp cluster.conf.example cluster.conf\r\n```\r\n\r\n对集群配置文件进行修改:\r\n\r\n```shell\r\nvim cluster.conf\r\n```\r\n\r\n在一台机器上部署nacos集群时，==不能将运行端口设置为连续端口==，比如8841、8842、8843，否则会发生端口冲突。\r\n运行在8841端口nacos服务实际上会占用8841、8941、8942三个端口；\r\n\r\n修改 ip 配置（如果是不同机器的同端口）\r\n\r\n```\r\nip1:端口\r\nip2\r\nip3\r\n```\r\n\r\n修改ip配置（如果是同一台机器的不同端口，端口号不能连续）\r\n\r\n```\r\nip1:端口1\r\nip1:端口2\r\nip1:端口3\r\n```\r\n\r\n4、 修改配置文件中的 nacos 启动端口:\r\n\r\n```shell\r\nvim conf/application.properties\r\n```\r\n\r\n修改server.port:\r\n\r\n```properties\r\nserver.port=集群端口1\r\n```\r\n\r\n5、进入bin目录，修改运行内存，默认的 nacos 启动配置的消耗资源很大，如果服务器支持则可以不进行修改，服务器资源不支持可能会出现启动之后 nacos 集群循环重启\r\n\r\n```shell\r\nvim startup.sh\r\n```\r\n\r\n![image-20230518113700571](http://47.115.207.49/shareX/20230518/image-20230518113700571-shareX-20230518113702.png)\r\n\r\n6、复制出两份 nacos 文件夹，制作集群：\r\n\r\n```shell\r\ncp -r /mynacos/nacos /mynacos/nacos-2\r\ncp -r /mynacos/nacos /mynacos/nacos-3\r\n```\r\n\r\n分别进入nacos-2/conf、nacos-3/conf目录下，将其application.properties配置文件中的server.port修改为自定义集群端口2、自定义集群端口3\r\n\r\n7、启动 | 停止 nacos 集群\r\n分别进入/nacos/bin、/nacos-2/bin、/nacos-3/bin目录下，执行命令./startup.sh启动nacos服务。\r\n\r\n分别进入/nacos/bin、/nacos-2/bin、/nacos-3/bin目录下，执行命令./shutdown.sh停止nacos服务。\r\n\r\n至此，基于 tar 包的 nacos 2.x 集群部署就结束了\r\n\r\n还要布置ngnix环境，才能通过ngnix访问到nacos集群\r\n\r\n\r\n\r\n#### ==nginx环境配置==\r\n\r\n从官网下载tar.gz包后，放到/opt目录下\r\n\r\n使用tar -zxvf xxx.tar.gz解压\r\n\r\ncd nginx-1.21.6\r\n\r\n```shell\r\n#使用改命令配置nginx，若出现依赖项缺少，复制出错内容上网搜索对应依赖项安装后继续执行该语句\r\n./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-stream\r\n```\r\n\r\n执行成功后：执行make && make install安装，安装的默认路径是	/usr/local/nginx\r\n\r\n修改ngnix配置文件：\r\n\r\n```shell\r\ncd /usr/local/nginx/conf\r\ncp nginx.conf nginx.conf.bk		#备份配置文件\r\nvim nginx.conf\r\n```\r\n\r\n![image-20230518215622709](http://47.115.207.49/shareX/20230518/image-20230518215622709-shareX-20230518215624.png)\r\n\r\n详细配置看：https://blog.csdn.net/qq_42971035/article/details/127243864\r\n\r\n找到对应模块，修改内容如下：		#代表修改过的地方\r\n\r\n若为nacos1.x：只需要配置http服务即可\r\n\r\n若为nacos2.x：则==http服务和tcp服务==都必须配置，缺一不可，坑：没配置tcp服务，将会出现浏览器能访问，而项目无法启动\r\n\r\n```properties\r\n# http服务\r\nhttp {\r\n	...其他...\r\n\r\n    upstream cluster{\r\n        server 127.0.0.1:3333;\r\n        server 127.0.0.1:4444;\r\n        server 127.0.0.1:5555;\r\n\r\n    }   \r\n\r\n    server {\r\n        listen       1111;\r\n        server_name  192.168.111.100;\r\n\r\n        location / { \r\n            #root   html;\r\n            #index  index.html index.htm;\r\n            proxy_pass http://cluster;\r\n        }\r\n\r\n        error_page   500 502 503 504  /50x.html;\r\n        location = /50x.html {\r\n            root   html;\r\n        }\r\n\r\n    }\r\n\r\n	...其他...\r\n}\r\n# tpc服务\r\nstream{\r\n\r\n    # tcp负载均衡\r\n    upstream nacos-grpc {\r\n         server 192.168.111.100:4333;\r\n         server 192.168.111.100:5444;\r\n         server 192.168.111.100:6555;\r\n    }\r\n    # Nacos客户端gRPC请求服务端端口\r\n    server {\r\n        #listen 5444;\r\n        listen 2111;\r\n        proxy_pass nacos-grpc;\r\n    }\r\n\r\n    # tcp负载均衡\r\n    upstream nacos-tcp-5445 {\r\n         server 192.168.111:4334 weight=1;\r\n         server 192.168.111:5445 weight=1;\r\n         server 192.168.111:6556 weight=1;\r\n    }\r\n    # Nacos服务端gRPC请求服务端端口\r\n    server {\r\n        #listen 5445;\r\n        listen 2112;\r\n        proxy_pass nacos-tcp-5445;\r\n    }\r\n}\r\n\r\n```\r\n\r\n启动nacos集群后，启动nginx：\r\n\r\n```shell\r\ncd /usr/local/nginx/sbin\r\n./nginx -c /usr/local/nginx/conf/nginx.conf\r\n\r\n#nginx其他命令：\r\n./nginx -V			#可查看nginx安装的插件\r\n./nginx -s reload	#重载配置文件\r\n./nginx -s stop		#强制中断\r\n./nginx -s quit		#安全退出\r\n```\r\n\r\n关闭防火墙：\r\n\r\n```shell\r\nsystemctl stop firewalld\r\n```\r\n\r\n这样，就可以通过自己的虚拟机ip：\r\n\r\n==192.168.111.100:1111/nacos访问到nacos集群了==\r\n\r\n也可以通过指定端口号访问集群中的某台主机：\r\n\r\n192.168.111.100:3333/nacos\r\n\r\n\r\n\r\n踩坑结束\r\n\r\n\r\n\r\n\r\n\r\n# Sentinel\r\n\r\n版本参考目录		SpringcloudAlibaba		处的表格对照		这里选用的是1.8.4\r\n\r\n\r\n\r\n官网下载https://github.com/alibaba/Sentinel/releases对应版本后，\r\n\r\n直接用java -jar命令运行，默认运行端口为8080，若端口被占用，可使用--server.port=xxx更改启动端口\r\n\r\n访问sentinel管理界面：http://localhost:8080		登录账号密码均为sentinel\r\n\r\n\r\n\r\n启动nacos\r\n\r\n## sentinel新建案例模块\r\n\r\n1、新建网站服务端：		cloudalibaba-sentinel-service8401\r\n\r\n改pom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n<!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->\r\n<dependency>\r\n    <groupId>com.alibaba.csp</groupId>\r\n    <artifactId>sentinel-datasource-nacos</artifactId>\r\n</dependency>\r\n<!--SpringCloud ailibaba sentinel -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\r\n</dependency>\r\n<!--openfeign-->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n</dependency>\r\n```\r\n\r\n写yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 8401\r\n\r\nspring:\r\n  application:\r\n    name: cloudalibaba-sentinel-service\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        #Nacos服务注册中心地址\r\n        server-addr: localhost:8848\r\n    sentinel:\r\n      transport:\r\n        #配置Sentinel dashboard地址\r\n        dashboard: localhost:8080\r\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\r\n        port: 8719\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class MainApp8401 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(MainApp8401.class, args);\r\n    }\r\n}\r\n```\r\n\r\n业务类：\r\n\r\n```java\r\n@RestController\r\npublic class FlowLimitController {\r\n\r\n    @GetMapping(\"/testA\")\r\n    public String testA() {\r\n        return \"------testA\";\r\n    }\r\n\r\n    @GetMapping(\"/testB\")\r\n    public String testB() {\r\n        return \"------testB\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n启动8401微服务后查看sentienl控制台：空空如也，啥都没有\r\n\r\nSentinel采用的懒加载，执行一次访问即可\r\n\r\n\r\n\r\n## 流量控制\r\n\r\n- 资源名：唯一名称，默认请求路径\r\n\r\n- 针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)\r\n\r\n- 阈值类型单机阈值：\r\n\r\n  - QPS(每秒钟的请求数量)：当调用该pi的QPS达到阈值的时候，进行限流\r\n  - 线程数：当调用该pi的线程数达到阈值的时候，进行限流\r\n\r\n- 是否集群：不需要集群\r\n\r\n- 流控模式：\r\n\r\n  - 直接：api达到限流条件时，直接限流\r\n  - 关联：当关联的资源达到阈值时，就限流自己\r\n  - 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】\r\n\r\n- 流控效果：\r\n\r\n  - 快速失败：直接失败，抛异常\r\n\r\n  - Warm Up:根据codeFactor(冷加载因子，默认3)的值，从阈值/codeFactor,经过预热时长，才达到设置的QPS阈值\r\n\r\n  - 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS,否则无效\r\n\r\n    \r\n\r\n### 流控模式（流控效果默认快速失败）\r\n\r\n#### 直接\r\n\r\n该设置表示1秒钟内查询1（阈值）次就是OK，若超过次数1，就直接-快速失败，报默认错误：\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519174812532-shareX-20230519174820.png\" alt=\"image-20230519174812532\" style=\"zoom: 67%;\" />\r\n\r\n测试：\r\n\r\n快速点击访问http://localhost:8401/testA\r\n\r\n结果：Blocked by Sentinel (flow limiting)\r\n\r\n\r\n\r\n#### 关联\r\n\r\n当关联的资源达到阈值时，就限流自己\r\n\r\neg：当与A关联的资源B达到阀值后，就限流A自己\r\n\r\n该设置表示当关联资源/testB的qps阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519175109657-shareX-20230519175110.png\" alt=\"image-20230519175109657\" style=\"zoom:67%;\" />\r\n\r\n测试：\r\n\r\n快速点击访问http://localhost:8401/testB过后，在一秒内访问http://localhost:8401/testA将会出现Blocked by Sentinel (flow limiting)\r\n\r\n大批量线程高并发访问B，导致A失效了\r\n\r\n或者用jemter或postman测试\r\n\r\n\r\n\r\n#### 链路\r\n\r\n新建接口OrderService：\r\n\r\n```java\r\n@Service\r\npublic class OrderService {\r\n    \r\n    //Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解\r\n    @SentinelResource(\"goods\")\r\n    public String queryGoods(){\r\n        return \"查询商品。。。。\";\r\n    }\r\n}\r\n```\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@Resource\r\nprivate OrderService orderService;\r\n\r\n@GetMapping(\"/query\")\r\npublic String query(){\r\n    return orderService.queryGoods();\r\n}\r\n\r\n@GetMapping(\"/save\")\r\npublic String save(){\r\n    return orderService.queryGoods();\r\n}\r\n```\r\n\r\nyaml将  	web-context-unify		设置为false，关闭context整合\r\n\r\n```yaml\r\nserver:\r\n  port: 8401\r\n\r\nspring:\r\n  application:\r\n    name: cloudalibaba-sentinel-service\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        #Nacos服务注册中心地址\r\n        server-addr: localhost:8848\r\n    sentinel:\r\n      transport:\r\n        #配置Sentinel dashboard地址\r\n        dashboard: localhost:8080\r\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\r\n        port: 8719\r\n      web-context-unify: false  #关闭context整合\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n在controller中，query和save方法都调用了orderService.queryGoods()方法，那么query和save方法的==uri就是queryGoods()方法的入口资源==，流控的资源名由@SentinelResource注解设置\r\n\r\n链路模式依赖 /a /b这样的路径，而做整合后，原始的/a /b被隐藏掉了，无法判断上下游直接的关系了\r\n\r\n所以这里要将web-context-unify设置为false，因为Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效\r\n\r\n参考：https://blog.csdn.net/m0_45406092/article/details/123303275\r\n\r\n\r\n\r\n该设置表示设置入口资源为		/save   	时，对goods进行限流\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519204610131-shareX-20230519204611.png\" alt=\"image-20230519204610131\" style=\"zoom: 50%;\" />\r\n\r\n测试：\r\n\r\n快速访问localhost:8401/query时，不会限流\r\n\r\n快速访问localhost:84save时，会限流\r\n\r\n\r\n\r\n### 流控效果\r\n\r\n#### 快速失败：\r\n\r\n若限流，直接失败，抛出异常，默认为		Blocked by Sentinel (flow limiting)\r\n\r\n\r\n\r\n#### 预热WarmUp\r\n\r\n如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。\r\n\r\n即限流，冷启动\r\n\r\n公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值\r\n\r\n默认coldFactor为3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。\r\n\r\n\r\n\r\n案例，阀值为10+预热时长设置5秒。\r\n系统初始化的阀值为10 / 3 约等于3,即阀值刚开始为3；然后过了5秒后阀值才慢慢升高恢复到10\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519210017823-shareX-20230519210019.png\" alt=\"image-20230519210017823\" style=\"zoom:67%;\" />\r\n\r\n多次点击http://localhost:8401/testB，刚开始不行，后续慢慢OK\r\n\r\n\r\n\r\n#### 排队等待\r\n\r\n匀速排队，阈值必须设置为QPS\r\n\r\n匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。\r\n\r\n\r\n\r\n案例：设置含义：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519210444352-shareX-20230519210445.png\" alt=\"image-20230519210444352\" style=\"zoom:67%;\" />\r\n\r\n\r\n\r\n## 熔断降级（无blockHandler）\r\n\r\nSentinel 提供以下几种熔断策略：\r\n\r\n- 慢调用比例 (`SLOW_REQUEST_RATIO`)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入==探测恢复状态（HALF-OPEN 状态）==，若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。\r\n- 异常比例 (`ERROR_RATIO`)：当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入==探测恢复状态（HALF-OPEN 状态）==，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 `[0.0, 1.0]`，代表 0% - 100%。\r\n- 异常数 (`ERROR_COUNT`)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入==探测恢复状态（HALF-OPEN 状态）==，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。\r\n\r\n\r\n\r\n探测恢复状态（HALF-OPEN 状态）：\r\n\r\n==Sentinel1.8之前的断路器是没有半开状态的，1.8之后和hystrix一样有了==\r\n\r\n\r\n\r\n<span style=\"color:blue;\">RT （1.8过后变为慢调用比例）（平均响应时间，秒级）</span>\r\n      平均响应时间   <span style=\"color:blue;\">超出响应阈值的比例超过比例阈值  且   在时间窗口内通过的请求>=5</span>，两个条件同时满足后触发降级\r\n      窗口期过后关闭断路器\r\n      RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效）\r\n\r\n<span style=\"color:blue;\">异常比列（秒级）</span>\r\n    QPS >= 5 且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级\r\n\r\n<span style=\"color:blue;\">异常数（分钟级）</span>\r\n     异常数（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级\r\n\r\n\r\n\r\nSentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，\r\n让请求快速失败，避免影响到其它的资源而导致级联错误。\r\n\r\n当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。\r\n\r\n\r\n\r\n### 慢调用比例\r\n\r\n是什么：看上面大标题  熔断降级  统一介绍\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@GetMapping(\"/testD\")\r\npublic String testD()\r\n{\r\n    //暂停几秒钟线程\r\n    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n    log.info(\"testD 测试RT\");\r\n    return \"------testD\";\r\n}\r\n```\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519214010926-shareX-20230519214012.png\" alt=\"image-20230519214010926\" style=\"zoom: 50%;\" />\r\n\r\n这里设置的是完成请求的最大响应时间为200ms，若未在200ms内完成响应，则把该次请求统计为慢调用，\r\n\r\n当统计时长2000ms内，有>=5个请求时，且满调用占总请求次数的0.5以上，就触发熔断限流，熔断时间为2秒\r\n\r\n\r\n\r\n测试：\r\n\r\n上面controller中testD方法执行时间永远大于1秒，那么每次调用都会是慢调用\r\n\r\n使用工具或者狂点localhost:8401/testD，2000ms内大于5个请求调用testD，我们希望200毫秒处理完本次任务，\r\n如果超过200毫秒还没处理完，在未来2秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了\r\n\r\n\r\n\r\n### 异常比例\r\n\r\n是什么：看上面大标题  熔断降级  统一介绍，类似hystrix的熔断规则\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@GetMapping(\"/testC\")\r\npublic String testC()\r\n{\r\n    log.info(\"testC 测试异常比例\");\r\n    int age = 10/0;\r\n    return \"------testD\";\r\n}\r\n```\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519224208453-shareX-20230519224210.png\" alt=\"image-20230519224208453\" style=\"zoom:50%;\" />\r\n\r\n按照上述配置，统计时长1000ms内，>=5次请求且错误比例大于0.5就发生熔断降级\r\ntestC方法单独访问一次，必然来一次报错一次(int age  = 10/0)，调一次错一次；\r\n\r\n\r\n\r\n### 异常数\r\n\r\n是什么：看上面大标题  熔断降级  统一介绍\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@GetMapping(\"/testE\")\r\npublic String testE()\r\n{\r\n    log.info(\"testE 测试异常比例\");\r\n    int age = 10/0;\r\n    return \"------testE 测试异常比例\";\r\n}\r\n```\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519225050615-shareX-20230519225052.png\" alt=\"image-20230519225050615\" style=\"zoom:50%;\" />\r\n\r\n==Sentinel1.8之前异常数是按照分钟统计的，统计时长必须>=60s，1.8之后变为秒级==\r\n\r\n http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，\r\n我们看到error窗口，但是达到5次报错后，进入熔断后降级。\r\n\r\n\r\n\r\n## 热点key\r\n\r\n何为热点\r\n热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作\r\n\r\n兜底方法\r\n分为系统默认和客户自定义，两种\r\n\r\n  之前的case，限流出问题后，都是用sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\r\n\r\n\r\n  我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？\r\n\r\n结论\r\n    ==@HystrixCommand 到@SentinelResource==\r\n\r\n\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@GetMapping(\"/testHotKey\")\r\n@SentinelResource(value = \"testHotKey\",blockHandler = \"dealHandler_testHotKey\")\r\npublic String testHotKey(@RequestParam(value = \"p1\",required = false) String p1,\r\n                         @RequestParam(value = \"p2\",required = false) String p2){\r\n    return \"------testHotKey\";\r\n}\r\npublic String dealHandler_testHotKey(String p1, String p2, BlockException exception) {\r\n    return \"-----dealHandler_testHotKey\";\r\n}\r\n```\r\n\r\n![image-20230519230220145](http://47.115.207.49/shareX/20230519/image-20230519230220145-shareX-20230519230221.png)\r\n\r\n@SentinelResource(value = \"testHotKey\",blockHandler = \"dealHandler_testHotKey\")\r\n\r\n方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理，用了我们自己定义的降级方法\r\n\r\n若为设置blockHandler ，将会返回异常页面给用户，非常不友好\r\n\r\n\r\n\r\n\r\n\r\n上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流\r\n\r\n==特例情况：==\r\n\r\n我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样\r\n\r\n假如当p1的值等于5时，它的阈值可以达到200\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230519/image-20230519230806988-shareX-20230519230808.png\" alt=\"image-20230519230806988\" style=\"zoom: 67%;\" />\r\n\r\n访问http://localhost:8401/testHotKey?p1=5的阈值变为200\r\n\r\n==热点参数的注意点，参数必须是基本类型或者String==\r\n\r\n@SentinelResource\r\n处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理；\r\n\r\nRuntimeException\r\nint age = 10/0,这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管\r\n\r\n总结\r\n ==@SentinelResource主管配置出错，运行出错该走异常走异常==，hystrix的@HystrixCommand都管\r\n\r\n\r\n\r\n\r\n\r\n## 系统规则\r\n\r\n系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\r\n\r\n系统保护规则是应用整体维度的，而不是资源维度的，并且**仅对入口流量生效**。入口流量指的是进入应用的流量（`EntryType.IN`），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。\r\n\r\n系统规则支持以下的模式：\r\n\r\n- **Load 自适应**（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 `maxQps * minRt` 估算得出。设定参考值一般是 `CPU cores * 2.5`。\r\n- **CPU usage**（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。\r\n- **平均 RT**：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。\r\n- **并发线程数**：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。\r\n- **入口 QPS**：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。\r\n\r\n==上面的是对具体某个请求或资源进行流控，这里是对整个微服务进行流控==\r\n\r\n\r\n\r\n## @SentinelResource的使用\r\n\r\n==Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解==\r\n\r\n比如前面链路流控模式中在service中添加过该注解，将service中的方法也标记为资源\r\n\r\n\r\n\r\n<span style=\"color:red;\">@SentinelResource属性介绍：</span>\r\n\r\nvalue：设置资源名\r\n\r\nblockHandler：只负责sentinel控制台配置违规（当未满足配置违规时，<span style=\"color:red;\">若java程序有异常，将不会处理</span>，返回error页，当满足配置违规时，即使java程序有异常，也会进行处理，返回配置的blockHandler方法处理的值）且未设置sentinel持久化时，项目重启后，sentinel控制台配置将失效丢失\r\n\r\nfallback：类似于hystrix的fallback，会处理java程序异常\r\n\r\n\r\n\r\n### 按资源名称限流+后续处理\r\n\r\n给cloudalibaba-sentinel-service的\r\n\r\npom添加依赖：\r\n\r\n```xml\r\n<dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\r\n    <groupId>com.spongehah.springcloud</groupId>\r\n    <artifactId>cloud-api-commons</artifactId>\r\n    <version>${project.version}</version>\r\n</dependency>\r\n```\r\n\r\ncontroller添加：\r\n\r\n```java\r\n@RestController\r\npublic class RateLimitController {\r\n    @GetMapping(\"/byResource\")\r\n    /**\r\n     * value：设置资源名称\r\n     * blockHandler：设置专有限流方法，只处理sentinel设置的规则，不处理运行时异常，与hystrix的fallback方法区分\r\n     */\r\n    @SentinelResource(value = \"byResource\",blockHandler = \"handleException\")\r\n    public CommonResult byResource() {\r\n        return new CommonResult(200,\"按资源名称限流测试OK\",new Payment(2020L,\"serial001\"));\r\n    }\r\n    public CommonResult handleException(BlockException exception) {\r\n        return new CommonResult(444,exception.getClass().getCanonicalName()+\"\\t 服务不可用\");\r\n    }\r\n}\r\n```\r\n\r\n![image-20230520170352540](http://47.115.207.49/shareX/20230520/image-20230520170352540-shareX-20230520170401.png)\r\n\r\n\r\n\r\n==未作持久化配置时，此时关闭问服务8401看看，Sentinel控制台，流控规则消失了？？？？？sentinel设置的规则是临时的，持久化配置在后面==\r\n\r\n\r\n\r\n### 按照Url地址限流+后续处理\r\n\r\n通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息\r\n\r\nRateLimitController添加：\r\n\r\n```java\r\n@GetMapping(\"/rateLimit/byUrl\")\r\n@SentinelResource(value = \"byUrl\")\r\npublic CommonResult byUrl() {\r\n    return new CommonResult(200,\"按url限流测试OK\",new Payment(2020L,\"serial002\"));\r\n}\r\n```\r\n\r\n控制台中添加资源名时，使用/rateLimit/byUrl，是带 	/		的，而不是@SentinelResource中的value属性\r\n\r\n\r\n\r\n### 客户自定义通用限流处理逻辑\r\n\r\n上面兜底方案面临的问题：\r\n\r\n1    系统默认的，没有体现我们自己的业务要求。\r\n\r\n2  依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。\r\n\r\n3  每个业务方法都添加一个兜底的，那代码膨胀加剧。\r\n\r\n4  全局统一的处理方法没有体现。\r\n\r\n\r\n\r\n创建myhandler.CustomerBlockHandler类用于自定义限流处理逻辑\r\n\r\n```java\r\npublic class CustomerBlockHandler {\r\n    //必须为static\r\n    public static CommonResult handleException(BlockException exception){\r\n        return new CommonResult(2020,\"自定义的限流处理信息......CustomerBlockHandler-------1\");\r\n    }\r\n\r\n    public static CommonResult handleException2(BlockException exception){\r\n        return new CommonResult(2020,\"自定义的限流处理信息......CustomerBlockHandler-------2\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nRateLimitController添加：\r\n\r\n```java\r\n/**\r\n * 自定义通用的限流处理逻辑，\r\n * blockHandlerClass = CustomerBlockHandler.class\r\n * blockHandler = handleException2\r\n * 上述配置：找CustomerBlockHandler类里的handleException2方法进行兜底处理\r\n * \r\n * \r\n * 自定义通用的限流处理逻辑\r\n */\r\n@GetMapping(\"/rateLimit/customerBlockHandler\")\r\n@SentinelResource(value = \"customerBlockHandler\",\r\n        blockHandlerClass = CustomerBlockHandler.class, blockHandler = \"handleException2\")\r\npublic CommonResult customerBlockHandler() {\r\n    return new CommonResult(200, \"按客户自定义限流处理逻辑\");\r\n}\r\n```\r\n\r\n配置好sentinel控制台的规则后进行测试\r\n\r\n这里只是指定了一个blockHandlerClass，其blockHandler方法去这个类里面找\r\n\r\n\r\n\r\n### 服务熔断功能（设置blockHandler和fallback）\r\n\r\n#### 整合ribbon\r\n\r\n1、新建网站服务端提供者\r\n\r\n新建cloudalibaba-provider-payment9003/9004两个一样的做法，可使用-DServer.port=9004复制9003启动\r\n\r\npom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n<dependency><!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\r\n    <groupId>com.spongehah.springcloud</groupId>\r\n    <artifactId>cloud-api-commons</artifactId>\r\n    <version>${project.version}</version>\r\n</dependency>\r\n```\r\n\r\nyaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 9003\r\n\r\nspring:\r\n  application:\r\n    name: nacos-payment-provider\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #配置Nacos地址\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class PaymentMain9003 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentMain9003.class, args);\r\n    }\r\n}\r\n```\r\n\r\ncontroller：\r\n\r\n```java\r\n@RestController\r\npublic class PaymentController {\r\n\r\n    @Value(\"${server.port}\")\r\n    private String serverPort;\r\n\r\n    public static HashMap<Long, Payment> hashMap = new HashMap<>();\r\n    static {\r\n        hashMap.put(1L,new Payment(1L,\"28a8c1e3bc2742d8848569891fb42181\"));\r\n        hashMap.put(2L,new Payment(2L,\"bba8c1e3bc2742d8848569891ac32182\"));\r\n        hashMap.put(3L,new Payment(3L,\"6ua8c1e3bc2742d8848569891xt92183\"));\r\n    }\r\n\r\n    @GetMapping(value = \"/paymentSQL/{id}\")\r\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id) {\r\n        Payment payment = hashMap.get(id);\r\n        CommonResult<Payment> result = new CommonResult(200,\"from mysql,serverPort:  \"+serverPort,payment);\r\n        return result;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n2、网站客户端消费者：\r\n\r\n新建cloudalibaba-consumer-nacos-order84：\r\n\r\npom：\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n<!--SpringCloud ailibaba sentinel -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\r\n</dependency>\r\n<!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\r\n<dependency>\r\n    <groupId>com.spongehah.springcloud</groupId>\r\n    <artifactId>cloud-api-commons</artifactId>\r\n    <version>${project.version}</version>\r\n</dependency>\r\n```\r\n\r\nyaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 84\r\n\r\n\r\nspring:\r\n  application:\r\n    name: nacos-order-consumer\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848\r\n    sentinel:\r\n      transport:\r\n        #配置Sentinel dashboard地址\r\n        dashboard: localhost:8080\r\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\r\n        port: 8719\r\n\r\n\r\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\r\nservice-url:\r\n  nacos-user-service: http://nacos-payment-provider \r\n```\r\n\r\n主启动类：\r\n\r\n```java、\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\npublic class OrderNacosMain84 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(OrderNacosMain84.class, args);\r\n    }   \r\n}\r\n```\r\n\r\n业务类：\r\n\r\nconfig：\r\n\r\n```java\r\n@Configuration\r\npublic class ApplicationContextConfig {\r\n\r\n    @Bean\r\n    @LoadBalanced\r\n    public RestTemplate getRestTemplate()\r\n    {\r\n        return new RestTemplate();\r\n    }\r\n}\r\n```\r\n\r\ncontroller：\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\npublic class CircleBreakerController {\r\n\r\n    @Value(\"${service-url.nacos-user-service}\")\r\n    private String SERVICE_URL;\r\n\r\n    @Resource\r\n    private RestTemplate restTemplate;\r\n\r\n    @RequestMapping(\"/consumer/fallback/{id}\")\r\n    @SentinelResource(value = \"fallback\")\r\n    public CommonResult<Payment> fallback(@PathVariable Long id)\r\n    {\r\n        CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\"+id, CommonResult.class,id);\r\n\r\n        if (id == 4) {\r\n            throw new IllegalArgumentException (\"IllegalArgumentException,非法参数异常....\");\r\n        }else if (result.getData() == null) {\r\n            throw new NullPointerException (\"NullPointerException,该ID没有对应记录,空指针异常\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n3、测试：\r\n\r\n当@SentinelResource(value = \"fallback\")注解不配置任何兜底方法时，给客户error页面，不友好\r\n\r\n（1）只配置fallback方法时：\r\n\r\n```java\r\n@SentinelResource(value = \"fallback\", fallback = \"handlerFallback\") //fallback负责业务异常\r\npublic CommonResult<Payment> fallback(@PathVariable Long id) {\r\n    CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\" + id, CommonResult.class, id);\r\n\r\n    if (id == 4) {\r\n        throw new IllegalArgumentException(\"IllegalArgumentException,非法参数异常....\");\r\n    } else if (result.getData() == null) {\r\n        throw new NullPointerException(\"NullPointerException,该ID没有对应记录,空指针异常\");\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\npublic CommonResult handlerFallback(@PathVariable Long id, Throwable e) {\r\n    Payment payment = new Payment(id, \"null\");\r\n    return new CommonResult<>(444, \"兜底异常handlerFallback,exception内容  \" + e.getMessage(), payment);\r\n}\r\n```\r\n\r\n测试http://localhost:84/consumer/fallback/{id}\r\n\r\n当id=4和id>4时，会报异常，由fallback兜底方法handlerFallback进行处理，当设置了sentinel流控规则时，违规后返回默认处理\r\n\r\n\r\n\r\n（2）只配置blockHandler时：\r\n\r\n```java\r\n@RequestMapping(\"/consumer/fallback/{id}\")\r\n@SentinelResource(value = \"fallback\", blockHandler = \"blockHandler\") //blockHandler负责在sentinel里面配置的降级限流\r\npublic CommonResult<Payment> fallback(@PathVariable Long id) {\r\n    CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\" + id, CommonResult.class, id);\r\n    if (id == 4) {\r\n        throw new IllegalArgumentException(\"非法参数异常....\");\r\n    } else if (result.getData() == null) {\r\n        throw new NullPointerException(\"NullPointerException,该ID没有对应记录\");\r\n    }\r\n    return result;\r\n}\r\n\r\npublic CommonResult blockHandler(@PathVariable Long id, BlockException blockException) {\r\n    Payment payment = new Payment(id, \"null\");\r\n    return new CommonResult<>(445, \"blockHandler-sentinel限流,无此流水: blockException  \" + blockException.getMessage(), payment);\r\n}\r\n```\r\n\r\nsentinel控制台进行限流配置\r\n\r\n测试http://localhost:84/consumer/fallback/{id}\r\n\r\n当查询id>=4时，会返回error页，因为无fallback方法兜底，但当违反sentinel设定规则时，将会由blockHandler方法兜底，无论有没有运行时异常\r\n\r\n\r\n\r\n（3）fallback和blockHandler都配置\r\n\r\n```java\r\n@RequestMapping(\"/consumer/fallback/{id}\")\r\n@SentinelResource(value = \"fallback\", fallback = \"handlerFallback\", blockHandler = \"blockHandler\")\r\npublic CommonResult<Payment> fallback(@PathVariable Long id) {\r\n    CommonResult<Payment> result = restTemplate.getForObject(SERVICE_URL + \"/paymentSQL/\" + id, CommonResult.class, id);\r\n    if (id == 4) {\r\n        throw new IllegalArgumentException(\"非法参数异常....\");\r\n    } else if (result.getData() == null) {\r\n        throw new NullPointerException(\"NullPointerException,该ID没有对应记录\");\r\n    }\r\n    return result;\r\n}\r\n\r\npublic CommonResult handlerFallback(@PathVariable Long id, Throwable e) {\r\n    Payment payment = new Payment(id, \"null\");\r\n    return new CommonResult<>(444, \"fallback,无此流水,exception  \" + e.getMessage(), payment);\r\n}\r\n\r\npublic CommonResult blockHandler(@PathVariable Long id, BlockException blockException) {\r\n    Payment payment = new Payment(id, \"null\");\r\n    return new CommonResult<>(445, \"blockHandler-sentinel限流,无此流水: blockException  \" + blockException.getMessage(), payment);\r\n}\r\n```\r\n\r\n测试http://localhost:84/consumer/fallback/{id}\r\n\r\n不违反设定sentinel限流规则时，若发生异常，由fallback兜底，\r\n\r\n违反先流规则，blockHandler优先级高，发生异常也是blockHandler兜底\r\n\r\n\r\n\r\n\r\n\r\n（4）忽略异常属性\r\n\r\n```java\r\n@SentinelResource(value = \"fallback\", fallback = \"handlerFallback\", blockHandler = \"blockHandler\",\r\n        exceptionsToIgnore = {IllegalArgumentException.class})\r\n```\r\n\r\n忽略指定异常，发生该种异常时不进行处理\r\n\r\n\r\n\r\n#### 整合Feign\r\n\r\n==feign的fallback类只对服务端down机时使用==\r\n\r\n修改cloudalibaba-consumer-nacos-order84：\r\n\r\n==坑！！！！！！这里会启动报错，需要把devtools的依赖注释掉==\r\n\r\npom\r\n\r\n```xml\r\n<!--SpringCloud ailibaba nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n</dependency>\r\n<!--SpringCloud ailibaba sentinel -->\r\n<dependency>\r\n    <groupId>com.alibaba.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\r\n</dependency>\r\n<!--SpringCloud openfeign -->\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n</dependency>\r\n```\r\n\r\nyaml		激活Sentinel对Feign的支持\r\n\r\n```yaml\r\nserver:\r\n  port: 84\r\n\r\nspring:\r\n  application:\r\n    name: nacos-order-consumer\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        #Nacos服务注册中心地址\r\n        server-addr: localhost:8848\r\n    sentinel:\r\n      transport:\r\n        #配置Sentinel dashboard地址\r\n        dashboard: localhost:8080\r\n        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口\r\n        port: 8719\r\n\r\n#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)\r\nservice-url:\r\n  nacos-user-service: http://nacos-payment-provider\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n# 激活Sentinel对Feign的支持\r\nfeign:\r\n  sentinel:\r\n    enabled: true  \r\n```\r\n\r\n主启动类：添加@EnableFeignClients启动Feign的功能\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\n@EnableFeignClients\r\npublic class OrderNacosMain84 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(OrderNacosMain84.class, args);\r\n    }   \r\n}\r\n```\r\n\r\nPaymentService：\r\n\r\n```java\r\n@Component\r\n@FeignClient(value = \"nacos-payment-provider\",fallback = PaymentFallbackService.class)\r\npublic interface PaymentService {\r\n\r\n    @GetMapping(value = \"/paymentSQL/{id}\")\r\n    public CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id);\r\n\r\n}\r\n```\r\n\r\nPaymentFallbackService implements PaymentService：\r\n\r\n```java\r\n@Component\r\npublic class PaymentFallbackService implements PaymentService {\r\n\r\n    @Override\r\n    public CommonResult<Payment> paymentSQL(Long id) {\r\n        return new CommonResult<>(444, \"服务降级返回,没有该流水信息\", new Payment(id, \"errorSerial......\"));\r\n    }\r\n\r\n}\r\n```\r\n\r\ncontroller添加：\r\n\r\n```java\r\n//==================OpenFeign\r\n@Resource\r\nprivate PaymentService paymentService;\r\n\r\n@GetMapping(value = \"/consumer/openfeign/{id}\")\r\npublic CommonResult<Payment> paymentSQL(@PathVariable(\"id\") Long id) {\r\n    if (id == 4) {\r\n        throw new RuntimeException(\"没有该id\");\r\n    }\r\n    return paymentService.paymentSQL(id);\r\n}\r\n```\r\n\r\n测试http://localhost:84/consumer/openfeign/1\r\n\r\n当网站服务端正常时：返回信息\r\n\r\n当网站服务端down机时，返回fallback信息\r\n\r\n\r\n\r\n#### 熔断框架比较\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230521/image-20230521161909295-shareX-20230521161917.png\" alt=\"image-20230521161909295\"  />\r\n\r\n\r\n\r\n## sentinel规则持久化\r\n\r\n一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化\r\n\r\n\r\n\r\n思路：\r\n\r\n将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台\r\n的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效\r\n\r\n\r\n\r\n修改cloudalibaba-sentinel-service8401：\r\n\r\npom添加：		前面已经添加\r\n\r\n```xml\r\n<!--SpringCloud ailibaba sentinel-datasource-nacos -->\r\n<dependency>\r\n    <groupId>com.alibaba.csp</groupId>\r\n    <artifactId>sentinel-datasource-nacos</artifactId>\r\n</dependency>\r\n```\r\n\r\nyaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 8401\r\n\r\nspring:\r\n  application:\r\n    name: cloudalibaba-sentinel-service\r\n  cloud:\r\n    nacos:\r\n      discovery:\r\n        server-addr: localhost:8848 #Nacos服务注册中心地址\r\n    sentinel:\r\n      transport:\r\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\r\n        port: 8719\r\n      #sentinel持久化配置\r\n      datasource:\r\n        ds1:\r\n          nacos:\r\n            server-addr: localhost:8848\r\n            dataId: ${spring.application.name}\r\n            groupId: DEFAULT_GROUP\r\n            data-type: json\r\n            rule-type: flow\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \'*\'\r\n```\r\n\r\n\r\n\r\nnacos中新建配置文件：\r\n\r\n<img src=\"http://47.115.207.49/shareX/20230521/image-20230521162658614-shareX-20230521162659.png\" alt=\"image-20230521162658614\"  />\r\n\r\n```json\r\n/*\r\n设置sentinel限流规则\r\nresource：资源名称；\r\nlimitApp：来源应用；\r\ngrade：阈值类型，0表示线程数，1表示QPS；\r\ncount：单机阈值；\r\nstrategy：流控模式，0表示直接，1表示关联，2表示链路；\r\ncontrolBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；\r\nclusterMode：是否集群。\r\n*/\r\n[\r\n    {\r\n        \"resource\": \"/rateLimit/byUrl\",\r\n        \"limitApp\": \"default\",\r\n        \"grade\": 1,\r\n        \"count\": 1,\r\n        \"strategy\": 0,\r\n        \"controlBehavior\": 0,\r\n        \"clusterMode\": false\r\n    }\r\n]\r\n```\r\n\r\n持久化设置成功\r\n\r\n重新启动8401再看sentinel，规则也还在\r\n\r\n\r\n\r\n\r\n\r\n# Seata\r\n\r\n从1：1  ->  1：N  ->  N：N\r\n\r\n单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，\r\n业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。\r\n\r\n一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题\r\n\r\n\r\n\r\nSeata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。\r\n\r\n\r\n\r\n==1+3模型：==	\r\n\r\n分布式事务处理过程的一ID+三组件模型\r\n\r\n1：Transaction ID XID： 全局唯一的事务ID\r\n\r\n3：\r\n\r\nTransaction Coordinator (TC)：	事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；\r\n\r\nTransaction Manager (TM)：		 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；\r\n\r\nResource Manager (RM)：			 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚	\r\n\r\n\r\n\r\n处理过程：\r\n\r\n![image-20230521225711614](http://47.115.207.49/shareX/20230521/image-20230521225711614-shareX-20230521225713.png)\r\n\r\n## Seata安装配置启动（MySQL8）\r\n\r\n版本参考目录		SpringcloudAlibaba		处的表格对照		这里选用searta1.5.1适配cloudalibaba2.2.8RELEASE\r\n\r\n\r\n\r\n参考文章：https://blog.csdn.net/yanzhenjingfan/article/details/125472153\r\n\r\n​				   https://blog.csdn.net/sun9087/article/details/126484540\r\n\r\n​				   https://www.jianshu.com/p/37c3640284cc			主要参考seataServer.properties\r\n\r\n\r\n\r\n下载地址：https://github.com/seata/seata/releases\r\n\r\n\r\n修改conf目录下的application.yml配置文件\r\n\r\n```yaml\r\nserver:\r\n  port: 7091\r\n\r\nspring:\r\n  application:\r\n    name: seata-server\r\n\r\nlogging:\r\n  config: classpath:logback-spring.xml\r\n  file:\r\n    path: ${user.home}/logs/seata\r\n  extend:\r\n    logstash-appender:\r\n      destination: 127.0.0.1:4560\r\n    kafka-appender:\r\n      bootstrap-servers: 127.0.0.1:9092\r\n      topic: logback_to_logstash\r\n\r\nconsole:\r\n  user:\r\n    username: seata\r\n    password: seata\r\n\r\nseata:\r\n  config:\r\n    # support: nacos, consul, apollo, zk, etcd3\r\n    type: nacos\r\n    nacos:\r\n      server-addr: 127.0.0.1:8848\r\n      namespace:\r\n      group: SEATA_GROUP\r\n      username: nacos\r\n      password: nacos\r\n      ##if use MSE Nacos with auth, mutex with username/password attribute\r\n      #access-key: \"\"\r\n      #secret-key: \"\"\r\n      data-id: seataServer.properties\r\n  registry:\r\n    # support: nacos, eureka, redis, zk, consul, etcd3, sofa\r\n    type: nacos\r\n    nacos:\r\n      application: seata-server\r\n      server-addr: 127.0.0.1:8848\r\n      group: SEATA_GROUP\r\n      namespace: \r\n      cluster: default\r\n      username: nacos\r\n      password: nacos\r\n# 以下存储配置，可以配置在nacos的seataServer.properties\r\n#  store:\r\n    # support: file 、 db 、 redis\r\n#    mode: db\r\n#    db:\r\n#      datasource: druid\r\n#      db-type: mysql\r\n#      driver-class-name: com.mysql.cj.jdbc.Driver\r\n#      url: jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true\r\n#      user: root\r\n#      password: admin\r\n#      min-conn: 5\r\n#      max-conn: 100\r\n#      global-table: global_table\r\n#      branch-table: branch_table\r\n#      lock-table: lock_table\r\n#      distributed-lock-table: distributed_lock\r\n#      query-limit: 100\r\n#      max-wait: 5000\r\n#  server:\r\n#    service-port: 8091 #If not configured, the default is \'${server.port} + 1000\'\r\n  security:\r\n    secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017\r\n    tokenValidityInMilliseconds: 1800000\r\n    ignore:\r\n      urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login\r\n\r\n```\r\n\r\n\r\n\r\n启动nacos，在nacos面板中，添加**seataServer.properties**和service.vgroupMapping.default_tx_group两个配置\r\n\r\n**seataServer.properties**：\r\n\r\n```\r\nData ID:	seataServer.properties\r\nGroup:	SEATA_GROUP\r\n配置格式:	properties\r\n```\r\n\r\n```properties\r\n# 事务组要和yml保持一致\r\nseata.tx-service-group=default_tx_group\r\nseata.service.vgroup-mapping.default_tx_group=default\r\n\r\nstore.mode=db\r\n#-----db-----\r\nstore.db.datasource=druid\r\nstore.db.dbType=mysql\r\n# 需要根据mysql的版本调整driverClassName\r\n# mysql8及以上版本对应的driver：com.mysql.cj.jdbc.Driver\r\n# mysql8以下版本的driver：com.mysql.jdbc.Driver\r\nstore.db.driverClassName=com.mysql.cj.jdbc.Driver\r\nstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&rewriteBatchedStatements=true&characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useSSL=false\r\nstore.db.user=root\r\nstore.db.password=123456\r\n# 数据库初始连接数\r\nstore.db.minConn=5\r\n# 数据库最大连接数\r\nstore.db.maxConn=30\r\n# 全局事务表名 默认global_table\r\nstore.db.globalTable=global_table\r\n# 分支事务表名 默认branch_table\r\nstore.db.branchTable=branch_table\r\n# 全局锁表名 默认lock_table\r\nstore.db.lockTable=lock_table\r\n# \r\nstore.db.distributedLockTable=distributed_lock\r\n# 查询全局事务一次的最大条数 默认100\r\nstore.db.queryLimit=100\r\n# 获取连接时最大等待时间 默认5000，单位毫秒\r\nstore.db.maxWait=5000\r\n\r\n\r\nclient.undo.dataValidation=true\r\nclient.undo.logSerialization=jackson\r\nclient.undo.onlyCareUpdateColumns=true\r\nclient.undo.logTable=undo_log\r\nclient.undo.compress.enable=true\r\nclient.undo.compress.type=zip\r\nclient.undo.compress.threshold=64k\r\n# undo保留天数 默认7天,log_status=1（附录3）和未正常清理的undo\r\nserver.undo.logSaveDays=7\r\n# undo清理线程间隔时间 默认86400000，单位毫秒\r\nserver.undo.logDeletePeriod=86400000\r\n# 二阶段提交重试超时时长 单位ms,s,m,h,d,对应毫秒,秒,分,小时,天,默认毫秒。默认值-1表示无限重试\r\n# 公式: timeout>=now-globalTransactionBeginTime,true表示超时则不再重试\r\n# 注: 达到超时时间后将不会做任何重试,有数据不一致风险,除非业务自行可校准数据,否者慎用\r\nserver.maxCommitRetryTimeout=-1\r\n# 二阶段回滚重试超时时长\r\nserver.maxRollbackRetryTimeout=-1\r\n# 二阶段提交未完成状态全局事务重试提交线程间隔时间 默认1000，单位毫秒\r\nserver.recovery.committingRetryPeriod=1000\r\n# 二阶段异步提交状态重试提交线程间隔时间 默认1000，单位毫秒\r\nserver.recovery.asynCommittingRetryPeriod=1000\r\n# 二阶段回滚状态重试回滚线程间隔时间  默认1000，单位毫秒\r\nserver.recovery.rollbackingRetryPeriod=1000\r\n# 超时状态检测重试线程间隔时间 默认1000，单位毫秒，检测出超时将全局事务置入回滚会话管理器\r\nserver.recovery.timeoutRetryPeriod=1000\r\n\r\n#Transaction rule configuration, only for the server\r\nserver.rollbackRetryTimeoutUnlockEnable=false\r\nserver.distributedLockExpireTime=10000\r\nserver.xaerNotaRetryTimeout=60000\r\nserver.session.branchAsyncQueueSize=5000\r\nserver.session.enableBranchAsyncRemove=false\r\n\r\n#Transaction rule configuration, only for the client\r\nclient.rm.asyncCommitBufferLimit=10000\r\nclient.rm.lock.retryInterval=10\r\nclient.rm.lock.retryTimes=30\r\nclient.rm.lock.retryPolicyBranchRollbackOnConflict=true\r\nclient.rm.reportRetryCount=5\r\nclient.rm.tableMetaCheckEnable=true\r\nclient.rm.tableMetaCheckerInterval=60000\r\nclient.rm.sqlParserType=druid\r\nclient.rm.reportSuccessEnable=false\r\nclient.rm.sagaBranchRegisterEnable=false\r\nclient.rm.sagaJsonParser=fastjson\r\nclient.rm.tccActionInterceptorOrder=-2147482648\r\nclient.tm.commitRetryCount=5\r\nclient.tm.rollbackRetryCount=5\r\nclient.tm.defaultGlobalTransactionTimeout=60000\r\nclient.tm.degradeCheck=false\r\nclient.tm.degradeCheckAllowTimes=10\r\nclient.tm.degradeCheckPeriod=2000\r\nclient.tm.interceptorOrder=-2147482648\r\n\r\n#For TCC transaction mode\r\ntcc.fence.logTableName=tcc_fence_log\r\ntcc.fence.cleanPeriod=1h\r\n\r\n#Log rule configuration, for client and server\r\nlog.exceptionRate=100\r\n\r\n#Metrics configuration, only for the server\r\nmetrics.enabled=false\r\nmetrics.registryType=compact\r\nmetrics.exporterList=prometheus\r\nmetrics.exporterPrometheusPort=9898\r\n\r\ntransport.type=TCP\r\ntransport.server=NIO\r\ntransport.heartbeat=true\r\ntransport.enableTmClientBatchSendRequest=false\r\ntransport.enableRmClientBatchSendRequest=true\r\ntransport.enableTcServerBatchSendResponse=false\r\ntransport.rpcRmRequestTimeout=30000\r\ntransport.rpcTmRequestTimeout=30000\r\ntransport.rpcTcRequestTimeout=30000\r\ntransport.threadFactory.bossThreadPrefix=NettyBoss\r\ntransport.threadFactory.workerThreadPrefix=NettyServerNIOWorker\r\ntransport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandler\r\ntransport.threadFactory.shareBossWorker=false\r\ntransport.threadFactory.clientSelectorThreadPrefix=NettyClientSelector\r\ntransport.threadFactory.clientSelectorThreadSize=1\r\ntransport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThread\r\ntransport.threadFactory.bossThreadSize=1\r\ntransport.threadFactory.workerThreadSize=default\r\ntransport.shutdown.wait=3\r\ntransport.serialization=seata\r\ntransport.compressor=none\r\n```\r\n\r\nservice.vgroupMapping.default_tx_group，值为default。如果不新建这个文件，客户端启动，控制台会报错can not get cluster name in registry config \'service.vgroupMapping.default_tx_group\', please make sure registry config correct\r\n\r\nservice.vgroupMapping.default_tx_group：\r\n\r\n```\r\nData ID:	service.vgroupMapping.default_tx_group\r\nGroup:	SEATA_GROUP\r\n配置格式:	text\r\n配置内容：default\r\n```\r\n\r\n我的数据库是mysql8.0.29，数据库新建数据库库seata\r\n\r\n前往官网复制sql代码：https://github.com/seata/seata/tree/1.5.0/script/server/db\r\n\r\n在新建的seata数据库中运行复制的sql代码\r\n```sql\r\n-- -------------------------------- The script used when storeMode is \'db\' --------------------------------\r\n-- the table to store GlobalSession data\r\nCREATE TABLE IF NOT EXISTS `global_table`\r\n(\r\n    `xid`                       VARCHAR(128) NOT NULL,\r\n    `transaction_id`            BIGINT,\r\n    `status`                    TINYINT      NOT NULL,\r\n    `application_id`            VARCHAR(32),\r\n    `transaction_service_group` VARCHAR(32),\r\n    `transaction_name`          VARCHAR(128),\r\n    `timeout`                   INT,\r\n    `begin_time`                BIGINT,\r\n    `application_data`          VARCHAR(2000),\r\n    `gmt_create`                DATETIME,\r\n    `gmt_modified`              DATETIME,\r\n    PRIMARY KEY (`xid`),\r\n    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),\r\n    KEY `idx_transaction_id` (`transaction_id`)\r\n) ENGINE = InnoDB\r\n  DEFAULT CHARSET = utf8mb4;\r\n\r\n-- the table to store BranchSession data\r\nCREATE TABLE IF NOT EXISTS `branch_table`\r\n(\r\n    `branch_id`         BIGINT       NOT NULL,\r\n    `xid`               VARCHAR(128) NOT NULL,\r\n    `transaction_id`    BIGINT,\r\n    `resource_group_id` VARCHAR(32),\r\n    `resource_id`       VARCHAR(256),\r\n    `branch_type`       VARCHAR(8),\r\n    `status`            TINYINT,\r\n    `client_id`         VARCHAR(64),\r\n    `application_data`  VARCHAR(2000),\r\n    `gmt_create`        DATETIME(6),\r\n    `gmt_modified`      DATETIME(6),\r\n    PRIMARY KEY (`branch_id`),\r\n    KEY `idx_xid` (`xid`)\r\n) ENGINE = InnoDB\r\n  DEFAULT CHARSET = utf8mb4;\r\n\r\n-- the table to store lock data\r\nCREATE TABLE IF NOT EXISTS `lock_table`\r\n(\r\n    `row_key`        VARCHAR(128) NOT NULL,\r\n    `xid`            VARCHAR(128),\r\n    `transaction_id` BIGINT,\r\n    `branch_id`      BIGINT       NOT NULL,\r\n    `resource_id`    VARCHAR(256),\r\n    `table_name`     VARCHAR(32),\r\n    `pk`             VARCHAR(36),\r\n    `status`         TINYINT      NOT NULL DEFAULT \'0\' COMMENT \'0:locked ,1:rollbacking\',\r\n    `gmt_create`     DATETIME,\r\n    `gmt_modified`   DATETIME,\r\n    PRIMARY KEY (`row_key`),\r\n    KEY `idx_status` (`status`),\r\n    KEY `idx_branch_id` (`branch_id`),\r\n    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)\r\n) ENGINE = InnoDB\r\n  DEFAULT CHARSET = utf8mb4;\r\n\r\nCREATE TABLE IF NOT EXISTS `distributed_lock`\r\n(\r\n    `lock_key`       CHAR(20) NOT NULL,\r\n    `lock_value`     VARCHAR(20) NOT NULL,\r\n    `expire`         BIGINT,\r\n    primary key (`lock_key`)\r\n) ENGINE = InnoDB\r\n  DEFAULT CHARSET = utf8mb4;\r\n\r\nINSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\'AsyncCommitting\', \' \', 0);\r\nINSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\'RetryCommitting\', \' \', 0);\r\nINSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\'RetryRollbacking\', \' \', 0);\r\nINSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (\'TxTimeoutCheck\', \' \', 0);\r\n```\r\n\r\n\r\n\r\n\r\nSeata1.5.1默认使用的是mysql5，需要将jar包换为mysql8的\r\n\r\nSeata1.5.2及以后默认使用的是mysql8\r\n\r\n\r\n\r\n更换jar包：\r\n\r\n==jar包不能直接复制/更换进去，因为会导致jar包压缩而无法使用==\r\n\r\n参考：https://blog.csdn.net/educast/article/details/106659197\r\n\r\n若是在windows环境下，将	seata/target/seata-server.jar包和所要更换的mysql-connector-java-8.0.29.jar传送到Linux服务器/虚拟机\r\n\r\n在linux环境找到传输过来的jar报所在目录，依次运行下列命令：\r\n\r\n具体文件名称根据自己实际情况来：\r\n\r\n```shell\r\njar -xvf seata-server.jar	#先解压jar包\r\nrm -rf BOOT-INF/lib/mysql-connector-java-5.1.35.jar		#先移除mysql5jar报\r\nmv mysql-connector-java-8.0.29.jar BOOT-INF/lib/		#将mysql8jar包移动过去\r\nrm -rf seata-server.jar		#删除原seata-server.jar\r\njar -cfM0 seata-server.jar BOOT-INF/ META-INF/ org/		#重新将这三个目录打包为seata-server.jar\r\n```\r\n\r\n然后将seata-server.jar传回windows原位置即可\r\n\r\n\r\n\r\n启动：\r\n\r\n先启动nacos\r\n\r\n再启动seata：/seata/bin/seata-serve\r\n\r\n\r\n\r\n\r\n\r\n## seata-client微服务新建配置启动\r\n\r\n### 案例演示数据库准备\r\n\r\n这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。\r\n\r\n当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，\r\n再通过远程调用账户服务来扣减用户账户里面的余额，\r\n最后在订单服务中修改订单状态为已完成。\r\n\r\n该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。\r\n\r\n下订单--->扣库存--->减账户(余额)\r\n\r\n创建业务数据库：\r\n\r\nseata_order：存储订单的数据库；		CREATE DATABASE seata_order;\r\n\r\nseata_storage：存储库存的数据库；		CREATE DATABASE seata_storage;\r\n\r\nseata_account：存储账户信息的数据库。		CREATE DATABASE seata_account;\r\n\r\n建表：\r\n\r\nseata_order库下建t_order表：\r\n\r\n```sql\r\nCREATE TABLE t_order (\r\n  `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,\r\n  `user_id` BIGINT(11) DEFAULT NULL COMMENT \'用户id\',\r\n  `product_id` BIGINT(11) DEFAULT NULL COMMENT \'产品id\',\r\n  `count` INT(11) DEFAULT NULL COMMENT \'数量\',\r\n  `money` DECIMAL(11,0) DEFAULT NULL COMMENT \'金额\',\r\n  `status` INT(1) DEFAULT NULL COMMENT \'订单状态：0：创建中；1：已完结\' \r\n) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;\r\n\r\nSELECT * FROM t_order;\r\n```\r\n\r\nseata_storage库下建t_storage 表：\r\n\r\n```sql\r\nCREATE TABLE t_storage (\r\n `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,\r\n `product_id` BIGINT(11) DEFAULT NULL COMMENT \'产品id\',\r\n `total` INT(11) DEFAULT NULL COMMENT \'总库存\',\r\n `used` INT(11) DEFAULT NULL COMMENT \'已用库存\',\r\n `residue` INT(11) DEFAULT NULL COMMENT \'剩余库存\'\r\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\r\n\r\n\r\nINSERT INTO seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`)\r\nVALUES (\'1\', \'1\', \'100\', \'0\', \'100\');\r\n\r\nSELECT * FROM t_storage;\r\n```\r\n\r\nseata_account库下建t_account 表：\r\n\r\n```sql\r\nCREATE TABLE t_account (\r\n  `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT \'id\',\r\n  `user_id` BIGINT(11) DEFAULT NULL COMMENT \'用户id\',\r\n  `total` DECIMAL(10,0) DEFAULT NULL COMMENT \'总额度\',\r\n  `used` DECIMAL(10,0) DEFAULT NULL COMMENT \'已用余额\',\r\n  `residue` DECIMAL(10,0) DEFAULT \'0\' COMMENT \'剩余可用额度\'\r\n) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\r\n \r\nINSERT INTO seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`)  VALUES (\'1\', \'1\', \'1000\', \'0\', \'1000\');\r\n \r\nSELECT * FROM t_account;\r\n```\r\n\r\n\r\n\r\n三个业务库下都分别建一个==undo_log==表：\r\n\r\n```sql\r\nCREATE TABLE `undo_log` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  `branch_id` bigint(20) NOT NULL,\r\n  `xid` varchar(100) NOT NULL,\r\n  `context` varchar(128) NOT NULL,\r\n  `rollback_info` longblob NOT NULL,\r\n  `log_status` int(11) NOT NULL,\r\n  `log_created` datetime NOT NULL,\r\n  `log_modified` datetime NOT NULL,\r\n  `ext` varchar(100) DEFAULT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\r\n```\r\n\r\n\r\n\r\n数据库准备完成，一共四个数据库，seata总库，和上面三个新建的数据库\r\n\r\n### 新建订单Order-Module\r\n\r\n参考文章：目录Seata处三篇加下面一篇\r\n\r\n​			 https://blog.csdn.net/Jason_We/article/details/113538673		mysql-druid启动报错参考\r\n\r\n-Ddruid.mysql.usePingMethod=false\r\n\r\n1、新建module		seata-order-service2001\r\n\r\n2、pom：		父工程下：\r\n\r\n```xml\r\n<dependencies>\r\n    <!--nacos-->\r\n    <dependency>\r\n        <groupId>com.alibaba.cloud</groupId>\r\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\r\n    </dependency>\r\n    <!--seata-->\r\n    <dependency>\r\n        <groupId>com.alibaba.cloud</groupId>\r\n        <artifactId>spring-cloud-starter-alibaba-seata</artifactId>\r\n    </dependency>\r\n    <!--feign-->\r\n    <dependency>\r\n        <groupId>org.springframework.cloud</groupId>\r\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n    </dependency>\r\n    <!--web-actuator-->\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-actuator</artifactId>\r\n    </dependency>\r\n    <!--mysql-druid-->\r\n    <dependency>\r\n        <groupId>mysql</groupId>\r\n        <artifactId>mysql-connector-java</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>com.alibaba</groupId>\r\n        <artifactId>druid-spring-boot-starter</artifactId>\r\n        <version>1.1.17</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.mybatis.spring.boot</groupId>\r\n        <artifactId>mybatis-spring-boot-starter</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-test</artifactId>\r\n        <scope>test</scope>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.projectlombok</groupId>\r\n        <artifactId>lombok</artifactId>\r\n        <optional>true</optional>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n3、application.yaml：\r\n\r\n```yaml\r\nserver:\r\n  port: 2001\r\n\r\nspring:\r\n  application:\r\n    name: seata-order-service\r\n  cloud:\r\n    nacos:\r\n      server-addr: localhost:8848\r\n      discovery:\r\n        group: SEATA_GROUP\r\n        register-enabled: true\r\n\r\n  datasource:\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/seata_order\r\n    username: root\r\n    password: 123456\r\n    \r\nseata:\r\n  application-id: ${spring.application.name}\r\n  tx-service-group: default_tx_group\r\n  service:\r\n    vgroup-mapping:\r\n      default_tx_group: default\r\n  config:\r\n    # support: nacos, consul, apollo, zk, etcd3\r\n    type: nacos\r\n    nacos:\r\n      server-addr: 127.0.0.1:8848\r\n#      namespace:\r\n      group: SEATA_GROUP\r\n      username: nacos\r\n      password: nacos\r\n      data-id: \"seataServer.properties\"\r\n  registry:\r\n    # support: nacos, eureka, redis, zk, consul, etcd3, sofa\r\n    type: nacos\r\n    nacos:\r\n      application: seata-server\r\n      server-addr: 127.0.0.1:8848\r\n      group: SEATA_GROUP\r\n#      namespace:\r\n      cluster: default\r\n      username: nacos\r\n      password: nacos\r\n\r\n\r\nfeign:\r\n  hystrix:\r\n    enabled: false\r\n\r\nlogging:\r\n  level:\r\n    io:\r\n      seata: info\r\n\r\nmybatis:\r\n  mapperLocations: classpath:mapper/*.xml\r\n```\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\n@EnableFeignClients\r\npublic class SeataOrderMainApp2001 {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SeataOrderMainApp2001.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、domain：\r\n\r\nCommonResult：\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class CommonResult<T> {\r\n    private Integer code;\r\n    private String message;\r\n    private T data;\r\n\r\n    public CommonResult(Integer code, String message) {\r\n        this(code, message, null);\r\n    }\r\n}\r\n```\r\n\r\nOrder		订单\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Order {\r\n    private Long id;\r\n\r\n    private Long userId;\r\n\r\n    private Long productId;\r\n\r\n    private Integer count;\r\n\r\n    private BigDecimal money;\r\n\r\n    /**\r\n     * 订单状态：0：创建中；1：已完结\r\n     */\r\n    private Integer status;\r\n}\r\n```\r\n\r\n6、dao：\r\n\r\nOrderDao\r\n\r\n```java\r\n@Mapper\r\npublic interface OrderDao {\r\n    /**\r\n     * 创建订单\r\n     */\r\n    void create(Order order);\r\n\r\n    /**\r\n     * 修改订单金额\r\n     */\r\n    void update(@Param(\"userId\") Long userId, @Param(\"status\") Integer status);\r\n}\r\n```\r\n\r\n7、resources文件夹下新建mapper文件夹后添加		OrderMapper.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.spongehah.seata.dao.OrderDao\">\r\n\r\n    <resultMap id=\"BaseResultMap\" type=\"com.spongehah.seata.domain.Order\">\r\n        <id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"user_id\" property=\"userId\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"product_id\" property=\"productId\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"count\" property=\"count\" jdbcType=\"INTEGER\"/>\r\n        <result column=\"money\" property=\"money\" jdbcType=\"DECIMAL\"/>\r\n        <result column=\"status\" property=\"status\" jdbcType=\"INTEGER\"/>\r\n    </resultMap>\r\n\r\n    <insert id=\"create\">\r\n        INSERT INTO `t_order` (`id`, `user_id`, `product_id`, `count`, `money`, `status`)\r\n        VALUES (NULL, #{userId}, #{productId}, #{count}, #{money}, 0);\r\n    </insert>\r\n\r\n    <update id=\"update\">\r\n        UPDATE `t_order`\r\n        SET status = 1\r\n        WHERE user_id = #{userId} AND status = #{status};\r\n    </update>\r\n\r\n</mapper>\r\n```\r\n\r\n8、Service接口及实现\r\n\r\nOrderService：\r\n\r\n```java\r\npublic interface OrderService {\r\n    /**\r\n     * 创建订单\r\n     */\r\n    void create(Order order);\r\n}\r\n```\r\n\r\nOrderServiceImpl ：\r\n\r\n```java\r\n@Service\r\n@Slf4j\r\npublic class OrderServiceImpl implements OrderService {\r\n    @Resource\r\n    private OrderDao orderDao;\r\n\r\n    @Resource\r\n    private StorageService storageService;\r\n\r\n    @Resource\r\n    private AccountService accountService;\r\n\r\n    /**\r\n     * 创建订单->调用库存服务扣减库存->调用账户服务扣减账户余额->修改订单状态\r\n     * 简单说：\r\n     * 下订单->减库存->减余额->改状态\r\n     */\r\n    @Override\r\n    public void create(Order order) {\r\n        log.info(\"------->下单开始\");\r\n        //本应用创建订单\r\n        orderDao.create(order);\r\n\r\n        //远程调用库存服务扣减库存\r\n        log.info(\"------->order-service中扣减库存开始\");\r\n        storageService.decrease(order.getProductId(),order.getCount());\r\n        log.info(\"------->order-service中扣减库存结束\");\r\n\r\n        //远程调用账户服务扣减余额\r\n        log.info(\"------->order-service中扣减余额开始\");\r\n        accountService.decrease(order.getUserId(),order.getMoney());\r\n        log.info(\"------->order-service中扣减余额结束\");\r\n\r\n        //修改订单状态为已完成\r\n        log.info(\"------->order-service中修改订单状态开始\");\r\n        orderDao.update(order.getUserId(),0);\r\n        log.info(\"------->order-service中修改订单状态结束\");\r\n\r\n        log.info(\"------->下单结束\");\r\n    }\r\n}\r\n```\r\n\r\nAccountService：\r\n\r\n```java\r\n@FeignClient(value = \"seata-account-service\")\r\npublic interface AccountService {\r\n\r\n    /**\r\n     * 扣减账户余额\r\n     */\r\n    @PostMapping(\"/account/decrease\")\r\n    public CommonResult decrease(@RequestParam(\"id\") Long userId, @RequestParam(\"money\") BigDecimal money);\r\n\r\n}\r\n```\r\n\r\nStorageService：\r\n\r\n```java\r\n@FeignClient(value = \"seata-storage-service\")\r\npublic interface StorageService {\r\n\r\n    /**\r\n     * 扣减库存\r\n     */\r\n    @PostMapping(\"/storage/decrease\")\r\n    public CommonResult decrease(@RequestParam(\"productId\")Long productId,@RequestParam(\"count\") Integer count);\r\n}\r\n```\r\n\r\n9、controller：\r\n\r\n```java\r\n@RestController\r\n@Slf4j\r\npublic class OrderController {\r\n    \r\n    @Resource\r\n    private OrderService orderService;\r\n\r\n    /**\r\n     * 创建订单\r\n     */\r\n    @GetMapping(\"/order/create\")\r\n    public CommonResult create(Order order){\r\n        orderService.create(order);\r\n        return new CommonResult(200,\"订单创建成功！\");\r\n    }\r\n    \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 新建库存Storage-Module\r\n\r\n1、新建module：		seata-storage-service2002\r\n\r\n2、pom：和订单模块Order-Module一致\r\n\r\n3、yaml：和订单模块Order-Module一致，就修改端口号为2002，数据库url: jdbc:mysql://localhost:3306/seata_storage\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableFeignClients\r\n@EnableDiscoveryClient\r\npublic class SeataStorageServiceApplication2002 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SeataStorageServiceApplication2002 .class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、domian：\r\n\r\nCommonResult\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class CommonResult<T> {\r\n\r\n    private Integer code;\r\n    private String message;\r\n    private T data;\r\n\r\n    public CommonResult(Integer code, String message) {\r\n        this(code, message, null);\r\n    }\r\n\r\n}\r\n```\r\n\r\nStorage\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Storage {\r\n\r\n    private Long id;\r\n\r\n    /**\r\n     * 产品id\r\n     */\r\n    private Long productId;\r\n\r\n    /**\r\n     * 总库存\r\n     */\r\n    private Integer total;\r\n\r\n    /**\r\n     * 已用库存\r\n     */\r\n    private Integer used;\r\n\r\n    /**\r\n     * 剩余库存\r\n     */\r\n    private Integer residue;\r\n}\r\n```\r\n\r\n6、dao：\r\n\r\n```java\r\n@Mapper\r\npublic interface StorageDao {\r\n    /**\r\n     * 扣减库存\r\n     */\r\n    void decrease(@Param(\"productId\") Long productId, @Param(\"count\") Integer count);\r\n}\r\n```\r\n\r\n7、mapper.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.spongehah.seata.dao.StorageDao\">\r\n\r\n    <resultMap id=\"BaseResultMap\" type=\"com.spongehah.seata.domain.Storage\">\r\n        <id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"product_id\" property=\"productId\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"total\" property=\"total\" jdbcType=\"INTEGER\"/>\r\n        <result column=\"used\" property=\"used\" jdbcType=\"INTEGER\"/>\r\n        <result column=\"residue\" property=\"residue\" jdbcType=\"INTEGER\"/>\r\n    </resultMap>\r\n\r\n    <update id=\"decrease\">\r\n        UPDATE t_storage\r\n        SET used    = used + #{count},\r\n            residue = residue - #{count}\r\n        WHERE product_id = #{productId}\r\n    </update>\r\n\r\n</mapper>\r\n```\r\n\r\n8、service：\r\n\r\nStorageService\r\n\r\n```java\r\npublic interface StorageService {\r\n    /**\r\n     * 扣减库存\r\n     */\r\n    void decrease(Long productId, Integer count);\r\n}\r\n```\r\n\r\nStorageServiceImpl implements StorageService\r\n\r\n```java\r\n@Service\r\npublic class StorageServiceImpl implements StorageService {\r\n    \r\n    private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class);\r\n    \r\n    @Resource\r\n    private StorageDao storageDao;\r\n\r\n    /**\r\n     * 扣减库存\r\n     */\r\n    @Override\r\n    public void decrease(Long productId, Integer count) {\r\n        LOGGER.info(\"------->storage-service中扣减库存开始\");\r\n        storageDao.decrease(productId,count);\r\n        LOGGER.info(\"------->storage-service中扣减库存结束\");\r\n    }\r\n}\r\n```\r\n\r\n9、controller：\r\n\r\n```java\r\n@RestController\r\npublic class StorageController {\r\n\r\n    @Resource\r\n    private StorageService storageService;\r\n\r\n    @PostMapping(\"/storage/decrease\")\r\n    public CommonResult decrease(@RequestParam(\"productId\")Long productId, @RequestParam(\"count\") Integer count) {\r\n        storageService.decrease(productId, count);\r\n        return new CommonResult(200, \"扣减库存成功！\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### 新建账户Account-Module\r\n\r\n1、新建module			seata-account-service2003\r\n\r\n2、pom：和订单模块Order-Module一致\r\n\r\n3、yaml：和订单模块Order-Module一致，就修改端口号为2003，数据库url: jdbc:mysql://localhost:3306/seata_account\r\n\r\n4、主启动类：\r\n\r\n```java\r\n@SpringBootApplication\r\n@EnableDiscoveryClient\r\n@EnableFeignClients\r\npublic class SeataAccountMainApp2003 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SeataAccountMainApp2003.class, args);\r\n    }\r\n}\r\n```\r\n\r\n5、domain：\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class CommonResult<T> {\r\n    private Integer code;\r\n    private String message;\r\n    private T data;\r\n\r\n    public CommonResult(Integer code, String message) {\r\n        this(code, message, null);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Account {\r\n\r\n    private Long id;\r\n\r\n    /**\r\n     * 用户id\r\n     */\r\n    private Long userId;\r\n\r\n    /**\r\n     * 总额度\r\n     */\r\n    private BigDecimal total;\r\n\r\n    /**\r\n     * 已用额度\r\n     */\r\n    private BigDecimal used;\r\n\r\n    /**\r\n     * 剩余额度\r\n     */\r\n    private BigDecimal residue;\r\n}\r\n```\r\n\r\n6、dao：\r\n\r\n```java\r\n@Mapper\r\npublic interface AccountDao {\r\n    /**\r\n     * 扣减账户余额\r\n     */\r\n    void decrease(@Param(\"userId\") Long userId, @Param(\"money\") BigDecimal money);\r\n    \r\n}\r\n```\r\n\r\n7、mapper\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.spongehah.seata.dao.AccountDao\">\r\n\r\n    <resultMap id=\"BaseResultMap\" type=\"com.spongehah.seata.domain.Account\">\r\n        <id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"user_id\" property=\"userId\" jdbcType=\"BIGINT\"/>\r\n        <result column=\"total\" property=\"total\" jdbcType=\"DECIMAL\"/>\r\n        <result column=\"used\" property=\"used\" jdbcType=\"DECIMAL\"/>\r\n        <result column=\"residue\" property=\"residue\" jdbcType=\"DECIMAL\"/>\r\n    </resultMap>\r\n\r\n    <update id=\"decrease\">\r\n        UPDATE t_account\r\n        SET residue = residue - #{money},\r\n            used    = used + #{money}\r\n        WHERE user_id = #{userId};\r\n    </update>\r\n</mapper>\r\n```\r\n\r\n8、service\r\n\r\n```java\r\npublic interface AccountService {\r\n    /**\r\n     * 扣减账户余额\r\n     * @param userId 用户id\r\n     * @param money 金额\r\n     */\r\n    void decrease(@RequestParam(\"userId\") Long userId, @RequestParam(\"money\") BigDecimal money);\r\n}\r\n```\r\n\r\n```java\r\n@Service\r\n@Slf4j\r\npublic class AccountServiceImpl implements AccountService {\r\n    \r\n    @Resource\r\n    private AccountDao accountDao;\r\n\r\n    /**\r\n     * 扣减账户余额\r\n     */\r\n    @Override\r\n    public void decrease(Long userId, BigDecimal money) {\r\n        log.info(\"------->account-service中扣减账户余额开始\");\r\n        //模拟超时异常，全局事务回滚\r\n        //暂停几秒钟线程\r\n        //try { TimeUnit.SECONDS.sleep(30); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        accountDao.decrease(userId,money);\r\n        log.info(\"------->account-service中扣减账户余额结束\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n9、controller：\r\n\r\n```java\r\n@RestController\r\npublic class AccountController {\r\n\r\n    @Resource\r\n    private AccountService accountService;\r\n\r\n    /**\r\n     * 扣减账户余额\r\n     */\r\n    @PostMapping(\"/account/decrease\")\r\n    public CommonResult decrease(@RequestParam(\"userId\") Long userId, @RequestParam(\"money\") BigDecimal money) {\r\n        accountService.decrease(userId, money);\r\n        return new CommonResult(200, \"扣减账户余额成功！\");\r\n    }\r\n}\r\n```\r\n\r\n### 测试：@GlobalTransactional的使用\r\n\r\n==注意事项：==\r\n\r\n1、mapper.xml中，insert语句不能含有主键，否则会找不到主键，调用该insert语句的微服务的undo会一直刷新，idea控制台会一直刷屏但是不报错，该微服务连接的数据库无法正常fallback，其他微服务的数据库正常fallback\r\n\r\n2、mapper.xml中，我是数据库已经设置自增主键，但是还设置了 useGeneratedKeys=\"true\" keyProperty=\"id\"，导致idea控制台也一直刷屏，导致即使程序没有异常，所有微服务的表都全部fallback，没有试过数据库没有设置自增主键的情况，若有请自行尝试\r\n\r\n\r\n\r\n在AccountServiceImpl的decrease方法中加入超时测试语句：\r\n\r\n```java\r\n//模拟超时测试\r\ntry {TimeUnit.SECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n```\r\n\r\n在OrderServiceImpl的create方法头上加上==@GlobalTransactional==注解：\r\n\r\n```java\r\n@Override\r\n//name：随意起，不重复即可\r\n//rollbackFor：哪些异常需要fallback\r\n@GlobalTransactional(name = \"create-order\",rollbackFor = Exception.class)\r\npublic void create(Order order) {\r\n    log.info(\"------->下单开始\");\r\n    ........\r\n\r\n    log.info(\"------->下单结束\");\r\n}\r\n```\r\n\r\n\r\n\r\n补充：若是不想要超时报错，则需要用到前面hystrix学到的超时异常处理，在2001yaml中加入：单位毫秒\r\n\r\n```yaml\r\n#feign:\r\n#  client:\r\n#    config:\r\n#      default:\r\n#        connect-timeout: 5000\r\n#        read-timeout: 5000\r\n```\r\n\r\n\r\n\r\n## Seata原理补充\r\n\r\nSimple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架\r\n\r\n\r\n\r\n分布式事务的执行流程：\r\n\r\nTM 开启分布式事务（TM 向 TC 注册全局事务记录）；\r\n\r\n按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）；\r\n\r\nTM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）；\r\n\r\nTC 汇总事务信息，决定分布式事务是提交还是回滚；\r\n\r\nTC 通知所有 RM 提交/回滚 资源，事务二阶段结束。\r\n\r\n\r\n\r\nAT模式如何做到对业务的无侵入\r\n\r\n一阶段加载：	在一阶段，Seata 会拦截“业务 SQL”，\r\n1  解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在<span style=\"color:red;\">业务数据被更新前，将其保存成“before image”，</span>\r\n2  执行“业务 SQL”更新业务数据，\r\n3  <span style=\"color:red;\">在业务数据更新之后，其保存成“after image”，最后生成行锁。</span>\r\n以上操作全部<span style=\"color:red;\">在一个数据库事务内完成</span>，这样保证了一阶段操作的原子性。\r\n\r\n二阶段提交：	\r\n\r\n二阶段如是顺利提交的话，\r\n因为“业务 SQL”在一阶段已经提交至数据库，所以Seata框架只需<span style=\"color:red;\">将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</span>\r\n\r\n二阶段回滚：\r\n\r\n二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。\r\n<span style=\"color:red;\">回滚方式便是用“before image”还原业务数据</span>；但在还原前要首先要校验脏写，<span style=\"color:red;\">对比“数据库当前业务数据”和 “after image”</span>，\r\n如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，<span style=\"color:red;\">出现脏写就需要转人工处理</span>。\r\n\r\n![image-20230524185108734](http://47.115.207.49/shareX/20230524/image-20230524185108734-shareX-20230524185116.png)\r\n\r\ndebug时，可以查看各业务数据库中的<span style=\"color:red;\">undo_log表中的rollback_info字段，里面存有前后镜像</span>的信息等\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','http://47.115.207.49/shareX/20230507/image-20230507205944262-shareX-20230507205945.png','原创',10,_binary '',_binary '',_binary '\0','2023-05-24 18:51:16','2023-08-11 20:23:42',2022576839,'包含SpringCloud+CloudAlibaba常用技术的基础使用，例如eureka、openfeign、getway、Hystrix、Nacos、Sentinel、Seata等',NULL,NULL,'0'),(1673371611320827905,'尚硅谷Nginx基础部分笔记','# nginx基本运行原理图\r\n\r\n![image-20230618145224781](image\\nginx.assets\\image-20230618145224781.png)\r\n\r\n# Nginx配置与应用场景\r\n\r\n## 最小配置\r\n\r\n**worker_processes**\r\n\r\nworker_processes 1; 默认为1，表示开启一个业务进程\r\n\r\n**worker_connections**\r\n\r\nworker_connections 1024; 单个业务进程可接受连接数\r\n\r\n**include mime.types;**\r\n\r\ninclude mime.types; 引入http mime类型\r\n\r\n**default_type application/octet-stream;**\r\n\r\ndefault_type application/octet-stream; 如果mime类型没匹配上，默认使用二进制流的方式传输。\r\n\r\n**sendfifile on;**\r\n\r\nsendfile on; 使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。\r\n\r\n未开启sendfifile时：\r\n\r\n![image-20230618151150474](image\\nginx.assets/image-20230618151150474.png)\r\n\r\n开启后：（<font color=\'red\'>nginx减少一次目标文件的复制</font>）\r\n\r\n![image-20230618151244976](image\\nginx.assets/image-20230618151244976.png)\r\n\r\n**keepalive_timeout 65;**\r\n\r\nkeepalive_timeout 65;\r\n\r\n**server**\r\n\r\n虚拟主机配置\r\n\r\n```nginx\r\n	#虚拟主机 vhost\r\n    server {\r\n        listen       80;\r\n        server_name  localhost;	#域名、主机名\r\n\r\n        # location用于匹配uri\r\n        location / {\r\n            #匹配目录：nginx根目录下的文件夹 这里是/nginx/index\r\n            root   html;\r\n\r\n            #默认页\r\n            index  index.html index.htm;\r\n        }\r\n\r\n        #错误页\r\n        error_page   500 502 503 504  /50x.html;\r\n        location = /50x.html {\r\n            root   html;\r\n        }\r\n\r\n    }\r\n```\r\n\r\n## 虚拟主机\r\n\r\n原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务\r\n\r\n### servername匹配规则\r\n\r\n我们需要注意的是servername匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。\r\n\r\n**完整匹配**\r\n\r\n我们可以在同一servername中匹配多个域名\r\n\r\n```\r\nserver_name vod.mmban.com www1.mmban.com;\r\n```\r\n\r\n**通配符匹配**\r\n\r\n```\r\nserver_name *.mmban.com\r\n```\r\n\r\n**通配符结束匹配**\r\n\r\n```\r\nserver_name vod.*;\r\n```\r\n\r\n**正则匹配**\r\n\r\n```\r\nserver_name ~^[0-9]+\\.mmban\\.com$;\r\n```\r\n\r\n### 配置多台虚拟主机\r\n\r\n- listen端口相同，server_name不能相同\r\n- server_name相同，listen端口不能相同\r\n\r\n	#虚拟主机 vhost1\r\n	server {\r\n	    listen       80;\r\n	    server_name  www1.test.com;	#域名、主机名\r\n	\r\n	```nginx\r\n	# location用于匹配uri\r\n	location / {\r\n	    #匹配目录：nginx根目录下的文件夹 这里是/nginx/index\r\n	    root   html;\r\n	\r\n	    #默认页\r\n	    index  index.html index.htm;\r\n	}\r\n	\r\n	#错误页\r\n	error_page   500 502 503 504  /50x.html;\r\n	location = /50x.html {\r\n	    root   html;\r\n	}\r\n	```\r\n	\r\n	}\r\n	\r\n	#虚拟主机 vhost2\r\n	server {\r\n	    listen       80;\r\n	    server_name  www2.test.com;	#域名、主机名\r\n	\r\n	```nginx\r\n	# location用于匹配uri\r\n	location / {\r\n	    #匹配目录：nginx根目录下的文件夹 这里是/nginx/index\r\n	    root   html;\r\n	\r\n	    #默认页\r\n	    index  index.html index.htm;\r\n	}\r\n	\r\n	#错误页\r\n	error_page   500 502 503 504  /50x.html;\r\n	location = /50x.html {\r\n	    root   html;\r\n	}\r\n	```\r\n	\r\n	}\r\n\r\n### 反向代理基础配置\r\n\r\n```\r\nproxy_pass http://baidu.com;\r\n```\r\n\r\n```nginx\r\nlocation / {\r\n\r\n	proxy_pass http://atguigu.com/;\r\n\r\n}\r\n```\r\n\r\n## 域名解析\r\n\r\n### 多用户二级域名和短网址\r\n\r\n![image-20230618225732811](image\\nginx.assets/image-20230618225732811.png)\r\n\r\n用户访问缩短后的URL时，通常将会重定向到原来的URL。\r\n\r\n利用键值对应方式，将网址对应成被缩短的代码来散布使用。 使用时，系统先查询出原本的网址，再以网址重导向（URL redirection）来将缩短后的地址重定向到原来的URL。\r\n\r\nxxx.test.com/xxxxxxxx\r\n\r\nxxx：二级域名\r\n\r\nxxxxxxxx：短网址、短链\r\n\r\n一句话：<font color=\'red\'>二级域名截前面查库，短链截后面查数据库</font>\r\n\r\n### httpdns\r\n\r\nHTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率。另外，由于 DNS 服务器端获取的是真实客户端 IP 而非 Local DNS 的 IP，能够精确定位客户端地理位置、运营商信息，从而有效改进调度精确性。\r\n\r\n正是由于传统的DNS存在诸多的缺点，所以现在稍微有点规模的公司都会自己搭建HTTPDNS服务器。HTTPDNS 的原理很简单，将 DNS 这种容易被劫持的协议，转为使用 HTTP 协议请求 Domain <-> IP 映射。 获得正确 IP 之后，Client 自己组装 HTTP 协议，从而避免 ISP 篡改数据。它的架构图也比较简单，如下图所示。\r\n\r\n![image-20230618231052692](image\\nginx.assets/image-20230618231052692.png)\r\n\r\n![image32132d123123](image\\nginx.assets/image-20230618231106954.png)\r\n\r\n使用HttpDns，可以有效解决传统DNS的DNS劫持、访问时间延迟等问题。 - **避免Local DNS 劫持**：由于 HttpDns 是通过 IP 直接请求 HTTP 获取服务器 A 记录地址，不存在向本地运营商询问 domain 解析过程，所以从根本避免了劫持问题。 - **平均访问延迟下降**：由于是 IP 直接访问省掉了一次 domain 解析过程，通过智能算法排序后找到最快节点进行访问。 - **用户连接失败率下降**：通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。\r\n\r\n# 基于反向代理的负载均衡\r\n\r\n## 代理与负载均衡的概念\r\n\r\n**正向代理**\r\n\r\n![image-20230619213804802](image\\nginx.assets/image-20230619213804802.png)\r\n\r\n用户和代理服务器是一家的，是用户主动配置的服务器，用于能够访问外网（A能ping通B，A不能ping通C，但是B能ping通C，A借助B访问C）\r\n\r\n**反向代理**：由服务提供方方向提供的服务器，让用户能够访问到应用服务器\r\n\r\n![image-20230619214246279](image\\nginx.assets/image-20230619214246279.png)\r\n\r\n隧道式代理\r\n\r\n**负载均衡**\r\n\r\n![image-20230619220304390](image\\nginx.assets/image-20230619220304390.png)\r\n\r\n这里是轮询算法，为了避免一台微服务承受不住压力，于是相同微服务为一个集群，将他们的压力分配在集群各台主机上\r\n\r\n## 配置反向代理\r\n\r\n\r\n\r\n****\r\n\r\n**前提注意：本机ip是192.168.111.100，浏览器输入本机ip或者hosts文件中配置的主机名，或者域名解析的地址**\r\n\r\n\r\n\r\n**注意：配置反向代理后，不会配置root路径，故改台主机将无法提供网页服务**\r\n\r\n****\r\n\r\n\r\n\r\n**1、反向代理到其他服务器网址——url不改变**\r\n\r\n```nginx\r\n    location / {\r\n        #反向代理\r\n        proxy_pass http://www.atguigu.com;\r\n\r\n        #root   /www/www;\r\n        #index  index.html index.htm;\r\n    }\r\n```\r\n\r\n**2、反向代理到其他服务器网址——url改变为真实网址**\r\n\r\n```nginx\r\nlocation / {\r\n    #反向代理\r\n    proxy_pass http://atguigu.com;	#相比上条没输入www\r\n\r\n    #root   /www/www;\r\n    #index  index.html index.htm;\r\n}\r\n```\r\n\r\n**3、反向代理到其他虚拟机**\r\n\r\n```nginx\r\nlocation / {\r\n    #反向代理\r\n    proxy_pass 192.168.111.101;		\r\n\r\n    #root   /www/www;\r\n    #index  index.html index.htm;\r\n}\r\n```\r\n\r\n## 配置负载均衡\r\n\r\n```nginx\r\n    #定义集群\r\n    upstream cluster {\r\n        server 192.168.111.101:80;\r\n        server 192.168.111.102:80;\r\n    }\r\n\r\n    server {\r\n        listen       80;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n\r\n            #反向代理到集群，配置负载均衡		用到上面定义的集群\r\n            proxy_pass http://cluster;		#不要忘记写http://\r\n\r\n            #root   /www/www;\r\n            #index  index.html index.htm;\r\n        }\r\n\r\n        error_page   500 502 503 504  /50x.html;\r\n        location = /50x.html {\r\n            root   html;\r\n        }\r\n    }\r\n```\r\n\r\n**负载均衡策略**\r\n\r\n**轮询**\r\n\r\n默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求\r\n\r\n**weight(权重)**\r\n\r\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\r\n\r\n```nginx\r\n	upstream cluster {\r\n        server 192.168.111.101:80 weight=4 down;\r\n        server 192.168.111.102:80 weight=8 backup;\r\n    }\r\n```\r\n\r\n- down：表示当前的server暂时不参与负载\r\n- **weight**：默认为1.weight越大，负载的权重就越大。\r\n- backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。\r\n\r\ndown和backup不常用\r\n\r\n\r\n\r\n**以下负载均衡算法均不常用：**\r\n\r\n**ip_hash**\r\n\r\n根据客户端的ip地址转发同一台服务器，可以保持回话。\r\n\r\n**least_conn**\r\n\r\n最少连接访问\r\n\r\n**url_hash**\r\n\r\n根据用户访问的url定向转发请求\r\n\r\n**fair**\r\n\r\n根据后端服务器响应时间转发请求\r\n\r\n![image-20230620195424300](image\\nginx.assets/image-20230620195424300.png)\r\n\r\n## 动静分离\r\n\r\n![image-20230620203844511](image\\nginx.assets/image-20230620203844511.png)\r\n\r\n只适合小型网站，静态资源较少，<font color=\'red\'>能起到系统加速的作用</font>\r\n\r\n将静态资源前置，网页请求静态资源时就不会把太多静态资源的请求打在后端tomcat服务器上，<font color=\'red\'>让后端服务器专心响应动态请求</font>\r\n\r\n![image-20230620204544669](image\\nginx.assets/image-20230620204544669.png)\r\n\r\n**动静配置配置**\r\n\r\n需要有一台虚拟机在tomcat上运行一个war包\r\n\r\n1 配置反向代理：\r\n\r\n```nginx\r\nlocation / {\r\n    proxy_pass http://192.168.111.102:8080;\r\n}\r\n```\r\n\r\n2 配置静态资源路径\r\n\r\n方式一：通用匹配：需要增加很多个location\r\n\r\n```nginx\r\nlocation /css {\r\n    root /usr/local/nginx/static;\r\n    index index.html index.htm;\r\n}\r\nlocation /images {\r\n    root /usr/local/nginx/static;\r\n    index index.html index.htm;\r\n}\r\nlocation /js {\r\n    root /usr/local/nginx/static;\r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n方式二：**正则匹配**：只需要一个location\r\n\r\n```nginx\r\nlocation ~*/(css|js|img) {		#~*表示正则匹配不区分大小写\r\n    root /usr/local/nginx/static;\r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n需要注意：<font color=\'red\'>正则匹配优先级大于通用匹配</font>\r\n\r\n**location前缀** \r\n\r\n- / 通用匹配，任何请求都会匹配到。\r\n\r\n- = 精准匹配，不是以指定模式开头\r\n- ~ 正则匹配，区分大小写\r\n- ~* 正则匹配，不区分大小写\r\n\r\n**location匹配顺序**\r\n\r\n- 多个正则location直接按书写顺序匹配，成功后就不会继续往后面匹配\r\n- 普通（非正则）location会一直往下，直到找到匹配度最高的（最大前缀匹配）\r\n- 当普通location与正则location同时存在，如果正则匹配成功,则不会再执行普通匹配\r\n- 所有类型location存在时，“=”匹配 > “^~”匹配 > 正则匹配 > 普通（最大前缀匹配）\r\n\r\n```js\r\n//location大致可以分为三类\r\n精准匹配：location = /{}\r\n一般匹配：location /{}\r\n正则匹配：location ~/{}\r\n\r\n//location常用的匹配规则：\r\n= ：进行普通字符精确匹配，也就是完全匹配。\r\n^~ ：表示前缀字符串匹配（不是正则匹配，需要使用字符串），如果匹配成功，则不再匹配其它 location。\r\n~ ：区分大小写的匹配（需要使用正则表达式）。\r\n~* ：不区分大小写的匹配（需要使用正则表达式）。\r\n!~ ：区分大小写的匹配取非（需要使用正则表达式）。\r\n!~* ：不区分大小写的匹配取非（需要使用正则表达式）。\r\n\r\n//正则规则：\r\n() ：表达式的开始和结束位置\r\n| ：或运算符  //例(js|img|css)\r\n\r\n//优先级\r\n首先精确匹配 =\r\n其次前缀匹配 ^~\r\n其次是按文件中顺序的正则匹配 ~或~*\r\n然后匹配不带任何修饰的前缀匹配\r\n最后是交给 / 通用匹配\r\n```\r\n\r\n**alias与root**\r\n\r\n```nginx\r\nlocation /css {\r\n    alias /usr/local/nginx/static/css;\r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\nroot用来设置根目录，而alias在接受请求的时候在路径上不会加上location。\r\n\r\n\r\n\r\n1）alias指定的目录是准确的，即location匹配访问的path目录下的文件直接是在alias目录下查找的； 2）root指定\r\n\r\n的目录是location匹配访问的path目录的上一级目录,这个path目录一定要是真实存在root指定目录下的； 3）使用\r\n\r\nalias标签的目录块中不能使用rewrite的break（具体原因不明）；另外，alias指定的目录后面必须要加上\"/\"符\r\n\r\n号！！ 4）alias虚拟目录配置中，location匹配的path目录如果后面不带\"/\"，那么访问的url地址中这个path目录后\r\n\r\n面加不加\"/\"不影响访问，访问时它会自动加上\"/\"； 但是如果location匹配的path目录后面加上\"/\"，那么访问的url地\r\n\r\n址中这个path目录必须要加上\"/\"，访问时它不会自动加上\"/\"。如果不加上\"/\"，访问就会失败！ 5）root目录配置\r\n\r\n中，location匹配的path目录后面带不带\"/\"，都不会影响访问。\r\n\r\n\r\n\r\n## **UrlRewrite**\r\n\r\n优点：掩藏真实的url以及url中可能暴露的参数，以及隐藏web使用的编程语言，提高安全性便于搜索引擎收录\r\n\r\n缺点：降低效率，影响性能。如果项目是内网使用，比如公司内部软件，则没有必要配置。\r\n\r\n**rewrite语法格式及参数语法:**\r\n\r\n```nginx\r\nrewrite是实现URL重写的关键指令，根据regex (正则表达式)部分内容，\r\n重定向到replacement，结尾是flag标记。\r\n\r\nrewrite <regex> <replacement> [flag];\r\n关键字 正则 替代内容 flag标记\r\n\r\n关键字：其中关键字error_log不能改变\r\n正则：perl兼容正则表达式语句进行规则匹配\r\n替代内容：将正则匹配的内容替换成replacement\r\nflag标记：rewrite支持的flag标记\r\n\r\nrewrite参数的标签段位置：\r\nserver,location,if\r\n\r\nflag标记说明：\r\nlast #本条规则匹配完成后，继续向下匹配新的location URI规则\r\nbreak #本条规则匹配完成即终止，不再匹配后面的任何规则\r\nredirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址\r\npermanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址\r\n```\r\n\r\n**实例：**\r\n\r\n```nginx\r\nlocation / {\r\n    \r\n	rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 break;\r\n    \r\n    #反向代理到集群，配置负载均衡\r\n    proxy_pass http://cluster;\r\n}\r\n```\r\n\r\n**解释：**\r\n\r\n```js\r\n正则：^/([0-9]+).html$\r\n^表示正则表达式开头\r\n$表示正则表达式结尾\r\n()表达式的开始和结束位置\r\n+表示匹配一次或多次\r\n\r\n替代内容：/index.jsp?pageNum=$1\r\n服务器解析uri时将正则匹配到的内容替换成/index.jsp?pageNum=$1\r\n$1表示正则表达式匹配到的第一个\r\n\r\nflag标记：break\r\n本条规则匹配完成即终止，不再匹配后面的任何规则\r\n```\r\n\r\n## 内网可访问防火墙配置\r\n\r\n![image-20230621144550679](image\\nginx.assets/image-20230621144550679.png)\r\n\r\n目前nginx已经可以实现反向代理、负载均衡、动静分离、UrlRewrite，因此我们将nginx服务器叫做网关服务器\r\n\r\n若要将应用服务器设置为外网无法访问，内网可以访问，需要进行以下防火墙配置：\r\n\r\n**开启防火墙**\r\n\r\n```shell\r\nsystemctl start firewalld\r\n```\r\n\r\n**指定端口和ip访问**\r\n\r\n```shell\r\nfirewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.111.100\" port protocol=\"tcp\" port=\"8080\" accept\"\r\n```\r\n\r\n若要移除规则：\r\n\r\n```shell\r\nfirewall-cmd --permanent --remove-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.111.100\" port protocol=\"tcp\" port=\"8080\" accept\"\r\n```\r\n\r\n**重载规则**\r\n\r\n```shell\r\nfirewall-cmd --reload\r\n```\r\n\r\n**查看已配置规则**\r\n\r\n```shell\r\nfirewall-cmd --list-all\r\n```\r\n\r\n\r\n\r\n**反向代理、负载均衡、动静分离、UrlRewrite综合实现：**\r\n\r\n**网关配置**\r\n\r\n```nginx\r\n    #定义集群	负载均衡\r\n    upstream cluster {\r\n        server 192.168.111.101:80 weight=4;\r\n        server 192.168.111.102:80 weight=8;\r\n    }\r\n\r\n    server {\r\n        listen       80;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n			\r\n			#UrlRewrite\r\n            rewrite ^/([0-9]+).html$ /index.jsp?pageNum=$1 break;\r\n\r\n            #反向代理到集群，配置负载均衡\r\n            proxy_pass http://cluster;\r\n\r\n            #root   /www/www;\r\n            #index  index.html index.htm;\r\n        }\r\n		\r\n		#动静分离\r\n        location ~*/(css|js|img) {\r\n\r\n            root   html;\r\n            index  index.html index.htm;\r\n        }\r\n	...\r\n	}\r\n```\r\n\r\n现在访问应用服务器本机，我这里是redis102，将不能访问，\r\n\r\n但访问nginx时，可以访问到redis102\r\n\r\n\r\n\r\n## 防盗链\r\n\r\n**配置**：在需要防盗链的location中配置，一般配置在动静分离location中的前面\r\n\r\n```\r\nvalid_referers none | blocked | server_names | strings ....;\r\n```\r\n\r\n- **none**， 检测 Referer 头域不存在的情况。\r\n- blocked，检测 Referer 头域的值被防火墙或者代理服务器删除或伪装的情况。这种情况该头域的值不以“http://” 或 “https://” 开头。\r\n- server_names ，设置一个或多个 URL ，检测 Referer 头域的值是否是这些 URL 中的某一个。\r\n\r\n**实例**：\r\n\r\n```nginx\r\n	location ~*/(css|js|img) {\r\n\r\n        valid_referers 192.168.44.100;		#实际中应该配置为域名而不是IP\r\n        if ($invalid_referer) {\r\n            return 403;		#return过后将不会再继续执行\r\n        }\r\n\r\n        root   html;\r\n        index  index.html index.htm;\r\n    }\r\n```\r\n\r\n浏览器请求referer中带192.168.44.100，则允许访问，否则返回403\r\n\r\n<font color=\'red\'>未授权的服务器和直接访问静态资源都不能访问</font>\r\n\r\n**若配置为：**\r\n\r\n```shell\r\nvalid_referers none 192.168.44.100;	 #添加了none\r\n```\r\n\r\n浏览器请求referer中带192.168.44.100或者为空时，允许访问\r\n\r\n<font color=\'red\'>即自己授权的服务器和直接访问静态资源时可以访问，未授权的服务器不能访问</font>\r\n\r\n\r\n\r\n**使用curl测试防盗链**\r\n\r\n安装curl\r\n\r\n```shell\r\nyum install -y curl\r\n```\r\n\r\n返回页面代码：\r\n\r\n```shell\r\ncurl http://192.168.44.101/img/logo.png\r\n```\r\n\r\n只返回响应头：\r\n\r\n```shell\r\ncurl -I http://192.168.44.101/img/logo.png\r\n```\r\n\r\n带引用：\r\n\r\n```shell\r\ncurl -e \"http://baidu.com\" -I http://192.168.44.101/img/logo.png\r\n```\r\n\r\n\r\n\r\n**配置错误提示页面**\r\n\r\n在nginx.conf配置文件对应server中添加错误页面location：\r\n\r\n```shell\r\n    error_page   403  /403.html;\r\n    location = /403.html {\r\n        root   html;\r\n    }\r\n```\r\n\r\n在nginx服务器403匹配目录下添加403.html:\r\n\r\n![image-20230621154718389](image\\nginx.assets/image-20230621154718389.png)\r\n\r\n**配置错误返回图片**\r\n\r\n在匹配图片的localtion的防盗链不匹配中添加rewrite：\r\n\r\n```shell\r\n    location ~*/(css|js|img) {\r\n\r\n        valid_referers 192.168.44.100;\r\n        if ($invalid_referer) {\r\n\r\n            rewrite ^/ /img/403.png break;		#返回错误图片\r\n            #return 403;\r\n        }\r\n\r\n        root   html;\r\n        index  index.html index.htm;\r\n    }\r\n```\r\n\r\n并在	/usr/local/nginx/html/img中添加图片403.png\r\n\r\n\r\n\r\n# 高可用keepalived\r\n\r\n![image-20230621161313025](image\\nginx.assets/image-20230621161313025.png)\r\n\r\n**nginx间的keepalived可以相互通信，共同虚拟出一个虚拟ip（vip），<font color=\'red\'>vip是可以在两台nginx中切换的</font>，根据实际情况漂移vip实现nginx的负载均衡**\r\n\r\n\r\n\r\n**配置keepalived**：\r\n\r\n先将原本的nginx虚拟机克隆一份，修改ip，保证nginx配置和环境相同\r\n\r\n两台虚拟机安装keepalived：\r\n\r\n```shell\r\nyum install keepalived -y\r\n```\r\n\r\n使用yum安装后配置文件在	/etc/keepalived/keepalived.conf\r\n\r\n最小配置：\r\n\r\n第一台机器：\r\n\r\n```nginx\r\n! Configuration File for keepalived\r\n\r\nglobal_defs {\r\n\r\n   router_id lb100		#该台机器的id，不能重复\r\n\r\n}\r\n\r\nvrrp_instance VI_1 {\r\n    state MASTER	#表示主机\r\n    interface ens33		#对方网卡名称，根据真实情况\r\n    virtual_router_id 51\r\n    priority 100	#优先级\r\n    advert_int 1\r\n    authentication {	#身份识别，相同为同一组\r\n        auth_type PASS\r\n        auth_pass 1111\r\n    }\r\n    virtual_ipaddress {		#虚拟ip，可配置多个\r\n        192.168.111.200\r\n    }\r\n}\r\n\r\n```\r\n\r\n第二台机器：\r\n\r\n```nginx\r\n! Configuration File for keepalived\r\n\r\nglobal_defs {\r\n\r\n   router_id lb101		#该台机器的id，不能重复\r\n\r\n}\r\n\r\nvrrp_instance VI_1 {\r\n    state BACKUP	#表示从机\r\n    interface ens33		#对方网卡名称，根据真实情况\r\n    virtual_router_id 51\r\n    priority 50		#优先级\r\n    advert_int 1\r\n    authentication {	#身份识别，相同为同一组\r\n        auth_type PASS\r\n        auth_pass 1111\r\n    }\r\n    virtual_ipaddress {		#虚拟ip，可配置多个\r\n        192.168.111.200\r\n    }\r\n}\r\n\r\n```\r\n\r\n启动两台机器的keepalived：\r\n\r\n```shell\r\nsystemctl start keepalived\r\n```\r\n\r\n可以使用ip a 查看ens33网卡的ip，可看到其中一个虚拟机多了一个虚拟ip，**若这台虚拟机down掉，vip将漂移到另一台虚拟机**\r\n\r\n\r\n\r\n<font color=\'red\'>**实际应用中，需要写对应的脚本监测本机的keepalived和nginx的服务运行状态，否则可能本机没有down掉，但是nginx服务关闭了，但是keepalived并没有关闭，则不会进行vip漂移，需要脚本监测到nginx down掉后，自动kill掉自己的keepalived**</font>\r\n\r\n**<font color=\'cornflowerblue\'>也适用于mysql、redis等其他服务</font>**\r\n\r\n\r\n\r\n# Https证书配置\r\n\r\n## 不安全的http协议与对称加密\r\n\r\n![image-20230621191710171](image\\nginx.assets/image-20230621191710171.png)\r\n\r\n- http协议不安全，因为采用的是明文方式发送数据\r\n- 防火墙只能拦截在服务器或客户端主机上的违法操作，但是无法处理网络传输过程中的拦截\r\n- 于是需要加密算法，比如凯撒加密算法，用户方将明文加密成密文后发送出去，服务方再采用相同的算法解密成明文\r\n- 像上面的两方使用相同的加密算法叫做<font color=\'cornflowerblue\'>**对称加密**</font>\r\n- 但是对称加密也**不安全**，因为对称加密的算法需要内置到服务器端，而例如nginx是开源的，拦截者也能知道内置了哪些加密算法\r\n\r\n## 非对称加密\r\n\r\n![image-20230621193226227](image\\nginx.assets/image-20230621193226227.png)\r\n\r\n- **用户先访问443端口下载公钥，再通过公钥发送后续真正的请求**\r\n- 用户 --》 服务端	公钥加密，私钥解密\r\n- 服务端 --》 用户	私钥加密，公钥解密\r\n\r\n![image-20230621194104815](image\\nginx.assets/image-20230621194104815.png)\r\n\r\n- 私钥不传输，一直在服务端，因此私钥安全\r\n- **公钥加密，但是拦截者拦截公钥后，<font color=\'cornflowerblue\'>用公钥解不开</font>**\r\n- 但是，非对称加密也是**不安全**的\r\n- 因为，虽然不能伪造客户端，但是可以**伪造服务端**，代替客户端与服务端通信，给客户端假公钥\r\n\r\n## HTTPS原理\r\n\r\n![image-20230621200836558](image\\nginx.assets/image-20230621200836558.png)\r\n\r\n- 引入了CA机构，具有公信度\r\n- 不再像非对称加密一样，传递服务端的公钥，而是**传递证书**\r\n- 服务端将公钥交给CA机构认证，经过**检测确实是真实服务器**后认证成功，然后CA机构通过自己的**私钥+加密算法**加密服务器的公钥生成**证书**，服务端发送给用户证书\r\n- 证书可以被截取解开，但是截取解开后，**没有CA机构的私钥再进行加密**，因此会显示是**不安全**的\r\n- 用户接收到证书后，通过**操作系统内置的ca.公钥**解开证书得到服务器的公钥，再用服务器的公钥加密数据进行传输，就算拦截者有服务器公钥，也无法解开用户传输的数据，因为**公钥加密，公钥解不开，公私对应才能解开**\r\n\r\n\r\n\r\n## 申请配置SSL证书\r\n\r\n**先购买自己的域名，和ECS云服务器，这里采用阿里云**\r\n\r\n**安装LNMP环境**\r\n\r\n使用下列网站\r\n\r\n[OneinStack - 一键PHP/JAVA安装工具](https://oneinstack.com/)\r\n\r\n自动安装 --》 若有mysql数据库则取消勾选mysql -- 》Nodejs、Pure-FTPd、phpMyAdmin、redis、memcached、iptables全部取消勾选--》 自己决定是否重启\r\n\r\n**配置云服务器安全组**\r\n\r\n将80端口和443端口为0.0.0.0开放，此时即可正常访问nginx主页\r\n\r\n**修改nginx网页默认位置**\r\n\r\n```shell\r\ncd /usr/local/nginx/conf\r\nvim nginx.conf\r\n```\r\n\r\n将server下的root修改为html\r\n\r\n```nginx\r\n  server {\r\n    listen 80;\r\n    server_name _;\r\n    access_log /data/wwwlogs/access_nginx.log combined;\r\n    root html;			#修改这里为html相对路径\r\n    .\r\n```\r\n\r\n本服务器没有完成备案，后续教程查看[【初探篇】申请阿里云免费SSL证书并配置https访问实战_ssl证书申请了不用在服务器上配置吗_潮浪之巅的博客-CSDN博客](https://hashnode.blog.csdn.net/article/details/124555303)\r\n\r\n\r\n\r\n## 安装discuz论坛\r\n\r\n[51-线上实战-安装Discuz与协议自动跳转_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yS4y1N76R?p=51&vd_source=34da131fa0b4ef9d62e5e0c78828f630)\r\n\r\n需要安装好上面的LNMP环境\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','http://47.115.207.49/shareX/20230627/image-20230627004745027-shareX-20230627004750.png','原创',21,_binary '',_binary '',_binary '\0','2023-06-21 20:08:36','2023-06-27 22:49:13',2022576839,'包含Nginx常用最小配置，包含反向代理、负载均衡、动静分离、UrlRewrite、防盗链、keepalived等等',NULL,NULL,'0'),(1674788938914480130,'友链','<div class=\"page-friends page-common\">\r\n<div class=\"link-title wow rollIn animated\" style=\"visibility: visible; animation-name: rollIn;\">博客友链</div>\r\n\r\n<center><div style=\"border: 1px solid orange; padding: 10px 0; font-size: 20px;\">\r\n<span>互换友链请留言</span>\r\n</div></center>\r\n\r\n<ul class=\"readers-list clearfix\">\r\n\r\n<li class=\"wow slideInUp animated\" style=\"visibility: visible; animation-name: slideInUp;\"><a rel=\"colleague\" title=\"\" target=\"_blank\" href=\"http://47.115.207.49/\"><div>HahHome</div><div>Happy Coding , Happy Life</div></a></li>\r\n\r\n</ul>\r\n\r\n<div class=\"link-title wow rollIn animated\" style=\"visibility: visible; animation-name: rollIn;\">学习教程</div>\r\n<ul class=\"readers-list clearfix\">\r\n\r\n<li class=\"wow slideInUp animated\" style=\"visibility: visible; animation-name: slideInUp;\"><a rel=\"\" title=\"学的不仅是技术，更是梦想\" target=\"_blank\" href=\"http://www.runoob.com/\"><div>菜鸟教程</div><div>学的不仅是技术，更是梦想</div></a></li>\r\n\r\n<li class=\"wow slideInUp animated\" style=\"visibility: visible; animation-name: slideInUp;\"><a rel=\"\" title=\"\" target=\"_blank\" href=\"https://tool.lu/\"><div>Tools</div><div>程序员的在线工具箱</div></a></li>\r\n\r\n<li class=\"wow slideInUp animated\" style=\"visibility: visible; animation-name: slideInUp;\"><a rel=\"\" title=\"在线学习教程\" target=\"_blank\" href=\"http://www.w3school.com.cn/\"><div>w3school</div><div>在线学习教程</div></a></li>\r\n\r\n<li class=\"wow slideInUp animated\" style=\"visibility: visible; animation-name: slideInUp;\"><a rel=\"\" title=\"有编程实战训练\" target=\"_blank\" href=\"https://www.w3cschool.cn/\"><div>w3cschool</div><div>有编程实战训练</div></a></li>\r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<style>\r\n    .clearfix {zoom:1;}\r\n    .clearfix:after {content:\'.\';display:block;visibility:hidden;height:0;clear:both;}\r\n    .readers-list {list-style:none;}\r\n    .readers-list *{margin:0;padding:0;}\r\n    .readers-list li{position:relative;float:left;margin-top:20px!important;padding:0 10px;}\r\n    .readers-list li a{display:block;border:1px solid #eee;border-left: 3px solid #FF002B;border-radius:7px;padding-left:15px;transition:all .3s;color: white;}\r\n    .readers-list li:nth-of-type(6n+1) a{border-left-color:#FF002B;}\r\n    .readers-list li:nth-of-type(6n+2) a{border-left-color:#FFA900;}\r\n    .readers-list li:nth-of-type(6n+3) a{border-left-color:#00CC00;}\r\n    .readers-list li:nth-of-type(6n+4) a{border-left-color:#00CCFF;}\r\n    .readers-list li:nth-of-type(6n+5) a{border-left-color:#0089FA;}\r\n    .readers-list li:nth-of-type(6n+6) a{border-left-color:#404040;}\r\n    .readers-list li a div{padding:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#999;}\r\n    .readers-list li a div:first-child{border-bottom:1px dashed #eee;font-size:1.3em;color:#666;}\r\n    .readers-list li a:hover {\r\n	-webkit-transform: translateY(-6px);\r\n	transform: translateY(-6px);\r\n	box-shadow: 0 26px 40px -24px rgba(0,0,0,0.3);\r\n}\r\n    .link-title {\r\n	position: relative;\r\n	left: -19px;\r\n	display: inline-block;\r\n	margin: 20px 0;\r\n	font-size: 15px;\r\n	padding: 0 30px 0 25px;\r\n	height: 45px;\r\n	line-height: 45px;\r\n	border-radius: 0 35px 35px 0;\r\n	background: #404040;\r\n	color: #fff;\r\n    }\r\n    @media(min-width:768px){\r\n        .readers-list li{width:50%;}\r\n    }\r\n    @media(max-width:767px){\r\n        .readers-list li{width:100%;}\r\n    }\r\n\r\n    .page-common ul li, .page-common ol li {\r\n        margin-bottom: 12px;\r\n    }\r\n    .page-friends ul {\r\n        padding: 0;\r\n        margin: 0;\r\n    }\r\n</style>\r\n','','原创',64,_binary '',_binary '\0',_binary '\0','2023-06-30 22:36:13','2023-06-30 23:29:48',2022576839,'',NULL,NULL,'1'),(1674790760379072514,'关于我','<div class=\"m-container m-padded-tb-big\">\r\n	<div class=\"ui container\">\r\n		<div class=\"ui stackable grid\">\r\n			<div class=\"eleven wide column\">\r\n				<div class=\"ui segment\">\r\n					<img src=\"http://47.115.207.49/img/blogAvatar.jpg\" alt=\"avatar\" style=\"width: 800px; height: 600px\"\r\n						class=\"ui rounded image\">\r\n				</div>\r\n			</div>\r\n			<div class=\"five wide column\">\r\n				<div class=\"ui top attached segment\">\r\n					<div class=\"ui header\">Hah</div>\r\n				</div>\r\n				<div class=\"ui attached segment\">\r\n					<p class=\"m-text\">Hah，一个搞笑男，喜欢安静，但又不喜欢一个人，</p>\r\n					<p class=\"m-text\">热爱编程，喜欢折腾，正在探索高效学习编程技术的方法...</p>\r\n					<p class=\"m-text\">博客+自带图床源码地址：<br /><a href=\"https://github.com/spongehah/HahHome_ImgBed\" target=\"_blank\">HahHome ·\r\n							GitHub</a><br />\r\n						学习笔记地址：<br />\r\n						<a href=\"https://github.com/spongehah/Notes\" target=\"_blank\">Notes · GitHub</a><br />\r\n						<a href=\"https://gitee.com/spongehah/Notes\" target=\"_blank\">Notes · Gitee</a>\r\n					</p>\r\n				</div>\r\n				<div class=\"ui attached segment\">\r\n					<div class=\"ui orange basic left pointing label\">编程</div>\r\n					<div class=\"ui orange basic left pointing label\">游戏</div>\r\n					<div class=\"ui orange basic left pointing label\">思考</div>\r\n					<div class=\"ui orange basic left pointing label\">运动</div>\r\n				</div>\r\n				<div class=\"ui attached segment\">\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">Java</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">SpringBoot</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">MYSQL</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">Redis</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">Nginx</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">Kafka</div>\r\n					<div class=\"ui teal basic left pointing label m-margin-tb-tiny\">...</div>\r\n				</div>\r\n			</div>\r\n		</div>\r\n<div>\r\n	</div>\r\n</div>\r\n','','原创',51,_binary '\0',_binary '\0',_binary '\0','2023-06-30 22:43:28','2023-07-02 18:55:17',2022576839,'',NULL,NULL,'2'),(1675518115531735041,'尚硅谷Nginx进阶部分笔记','# Nginx高级 第一部分：扩容\r\n\r\n\r\n\r\n通过扩容提升整体吞吐量\r\n\r\n## 1.单机垂直扩容：硬件资源增加\r\n\r\n```\r\n云服务资源增加\r\n整机：IBM、浪潮、DELL、HP等\r\nCPU/主板：更新到主流\r\n网卡：10G/40G网卡\r\n磁盘：SAS(SCSI) HDD（机械）、HHD（混合）、SATA SSD、PCI-e SSD、 MVMe SSD\r\nSSD\r\n多副本机制\r\n系统盘/热点数据/数据库存储\r\nHDD\r\n冷数据存储\r\n```\r\n\r\n\r\n\r\n## 2.水平扩展：集群化\r\n\r\n\r\n\r\n## 基本调优\r\n\r\n### 会话管理-修改负载均衡策略\r\n\r\n#### Nginx高级负载均衡\r\n\r\n**ip_hash**\r\n\r\n- 会导致流量倾斜，ip集中\r\n- 若后端服务器宕机，对应ip的服务将无法提供\r\n- 应用场景：中小型项目快速扩容时，不想修改代码，只需增加几台服务器使用ip_hash就可临时实现\r\n\r\n**hash    $cookie_jsessionid;**\r\n\r\n- 根据cookie中的jsessionid的不同转发到对应的服务器\r\n\r\n**hash    $request_uri;** \r\n\r\n- 根据uri的不同转发到对应的服务器\r\n\r\n**使用lua逻辑定向分发**\r\n\r\n**Redis + SpringSession**\r\n\r\n- 要修改代码\r\n- 所有前端服务器的请求打在redis服务器上，redis受不了\r\n\r\n\r\n\r\nip_hash示例：\r\n\r\n```nginx\r\n   upstream httpds {\r\n   ip_hash;			#设置负载均衡策略为ip_hash\r\n   server 192.168.44.102 ;\r\n   server 192.168.44.103 ;\r\n   }\r\n\r\n    server {\r\n        listen       80;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n	    proxy_pass http://httpds;\r\n\r\n      	# root   html;\r\n        }\r\n        \r\n       location ~*/(css|img|js) {\r\n     \r\n        root   /usr/local/nginx/html;\r\n\r\n    }\r\n```\r\n\r\n\r\n\r\n#### 使用sticky模块完成对Nginx的负载均衡\r\n\r\n**使用参考**\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_upstream_module.html#sticky\r\n\r\ntengine中有session_sticky模块我们通过第三方的方式安装在开源版本中\r\n\r\nsticky是第三方模块，需要重新编译Nginx,他可以对Nginx这种静态文件服务器使用基于cookie的负载均衡\r\n\r\n**1.下载模块**\r\n\r\n**项目官网**\r\n\r\nhttps://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/src/master/\r\n\r\n另外一个版本\r\n\r\nhttps://github.com/bymaximus/nginx-sticky-module-ng\r\n\r\n**下载**\r\n\r\nhttps://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/1.2.6.zip\r\n\r\n**2.上传解压**\r\n\r\n**3.重新编译Nginx**\r\n\r\n**进到源码目录重新编译**\r\n\r\n<font color=\'cornflowerblue\'>configure时记得加上自己原本有的后缀</font>\r\n\r\n```shell\r\ncd /opt/nginx-1.21.6	#根据自己的实际目录\r\n./configure --prefix=/usr/local/nginx --add-module=/root/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d\r\n```\r\n\r\n**执行make**\r\n\r\n**make时如遇报错修改源码**\r\n\r\n![image-20230624154939957](image/nginxadvanced.assets/image-20230624154939957.png)\r\n\r\n打开sticky文件夹中 `ngx_http_sticky_misc.c`文件\r\n\r\n在12行添加	\r\n\r\n```c\r\n#include <openssl/sha.h>\r\n#include <openssl/md5.h>\r\n```\r\n\r\n**若缺少依赖`openssl-devel`**\r\n\r\n```\r\nyum intall -y openssl-devel\r\n```\r\n\r\n**备份之前的程序**\r\n\r\n```\r\nmv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\r\n```\r\n\r\n**把编译好的Nginx程序替换到原来的目录里**\r\n\r\n```shell\r\ncp objs/nginx /usr/local/nginx/sbin/\r\n```\r\n\r\n**升级检测**\r\n\r\n```\r\nmake upgrade\r\n```\r\n\r\n检查程序中是否包含新模块\r\n\r\n```\r\nnginx -V\r\n```\r\n\r\n配置示例：\r\n\r\n```nginx\r\nupstream httpget {\r\n\r\nsticky name=route expires=6h;\r\n\r\nserver 192.168.44.102;\r\nserver 192.168.44.103;\r\n}\r\n```\r\n\r\n请求头中的cookie中带有key为route的数据，重复请求该值不变，route是由sticky模块下发的值\r\n\r\n![image-20230624160320269](image/nginxadvanced.assets/image-20230624160320269.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### KeepAlive\r\n\r\n不是keepalived		没有d\r\n\r\n\r\n\r\n**KeepAlive：保持长连接，避免过多的http连接的建立**，在http协议header中可以看到当前KeepAlive的连接状态\r\n\r\n\r\n\r\n**可使用测试工具charles**，也可以直接使用浏览器开发者模式，不过可能因为缓存原因刷新失败\r\n\r\n类似于wireshark，一个抓包工具\r\n\r\n**下载地址**\r\n\r\nhttps://www.charlesproxy.com/assets/release/4.6.2/charles-proxy-4.6.2-win64.msi?k=fc1457e312\r\n\r\n**官网**\r\n\r\nhttps://www.charlesproxy.com\r\n\r\n#### 什么时候用和不用？\r\n\r\n**用？**\r\n\r\n明显的预知用户会在当前连接上有下一步操作\r\n\r\n复用连接，有效减少握手次数，尤其是https建立一次连接开销会更大\r\n\r\n**不用？**\r\n\r\n访问内联资源一般用缓存，不需要keepalive\r\n\r\n长时间的tcp连接容易导致系统资源无效占用\r\n\r\n#### ==<font color=\'red\'>对客户端使用keepalive</font>==\r\n\r\n客户端一般是浏览器\r\n\r\n<font color=\'cornflowerblue\'>配置位置：http</font>\r\n\r\n- **keepalive_timeout**\r\n\r\nnginx.conf配置文件中修改keepalive_timeout，默认是65（s），修改成0即为关闭\r\n\r\n用于设置Nginx服务器与客户端保持连接的超时时间\r\n\r\n用于踢出不活动连接\r\n\r\nkeepalive_timeout = 0 即关闭\r\n\r\n可以设置两个参数，   keepalive_timeout  65 65;\r\n\r\n第二个参数用于配置http1.0版本，1.1不需要\r\n\r\n- **keepalive_disable**\r\n\r\n不对某些浏览器建立长连接\r\n\r\n默认msie6\r\n\r\n- **keepalive_time** \r\n\r\n限制keepalive保持连接的最大时间，超过之后 强制失效\r\n\r\n默认是1h\r\n\r\n1.19.10新功能\r\n\r\n- **keepalive_request**\r\n\r\n默认1000，1000已经够用\r\n\r\n一个tcp复用中 可以并发接收的请求个数\r\n\r\n- **send_timeout**\r\n\r\n两次向客户端写操作之间的间隔 如果大于这个时间则关闭连接 默认60s\r\n\r\nsend_timeout 10;  10秒\r\n\r\nsend_timeout 10 10; 同时下发一个header 告诉浏览器\r\n\r\n**此处有坑**，注意耗时的同步操作有可能会丢弃用户连接\r\n\r\n该设置表示Nginx服务器与客户端连接后，某次会话中服务器等待客户端响应超过10s，就会自动关闭连接。\r\n\r\n配置示例：\r\n\r\n```nginx\r\nhttp {\r\n    include       mime.types;\r\n    default_type  application/octet-stream;\r\n\r\n\r\n    sendfile        on;\r\n\r\n\r\n    keepalive_timeout  65 65; #超过这个时间 没有活动，会让keepalive失效 ，第二个参数用于配置http1.0版本，1.1不需要\r\n    keepalive_time 1h; # 一个tcp连接总时长，超过之后 强制失效\r\n  \r\n    send_timeout 60;# 默认60s  此处有坑！！ 系统中 若有耗时操作，超过 send_timeout 强制断开连接。 注意：准备过程中，不是传输过程\r\n\r\n\r\n    keepalive_requests 1000;  #一个tcp复用中 可以并发接收的请求个数\r\n```\r\n\r\n\r\n\r\n#### ==<font color=\'red\'>对上游服务器使用keepalive</font>==\r\n\r\n上游服务器就是后端服务器\r\n\r\n\r\n\r\n首先需要配置使用http1.1协议。以便建立更高效的传输，默认使用http1.0，在http1.0中需要配置header才能\r\n\r\n在Upstream中所配置的上游服务器默认都是用短连接，即每次请求都会在完成之后断开\r\n\r\n**upstream中配置**\r\n\r\n配置\r\n\r\n- **keepalive 100;**\r\n\r\n向上游服务器的保留连接数\r\n\r\n- **keepalive_timeout  65**\r\n\r\n连接保留时间\r\n\r\n-  **keepalive_requests 1000** \r\n\r\n\r\n一个tcp复用中 可以并发接收的请求个数\r\n\r\n\r\n\r\n**server中的location配置**\r\n\r\n```nginx\r\nproxy_http_version 1.1;\r\n#配置http版本号\r\n#因为nginx默认使用http1.0协议，需要在request中增加”Connection： keep-alive“ header才能够支持，而HTTP1.1默认支持。\r\nproxy_set_header Connection \"\";			#清除close信息\r\n```\r\n\r\n<font color=\'cornflowerblue\'>由于nginx默认为 http 1.0 ，不支持服务端长连接，请求头会携带 connection： close ，所以需要指定http版本为 http 1.1，同时设置connection： \"\"</font>\r\n\r\n配置示例：\r\n\r\n```nginx\r\n    #定义集群\r\n    upstream cluster {\r\n	keepalive 100;\r\n	keepalive_timeout  65;\r\n	keepalive_requests 1000;\r\n	server 192.168.111.101:80;\r\n	server 192.168.111.102:80;\r\n    }\r\n\r\n    server {\r\n        listen       80;\r\n        server_name  localhost;\r\n\r\n        location / {\r\n            proxy_http_version 1.1;\r\n            proxy_set_header Connection \"\";\r\n            \r\n            #反向代理到集群，配置负载均衡\r\n            proxy_pass http://cluster;\r\n        }\r\n```\r\n\r\n#### KeepAlive配置总结\r\n\r\n一般情况下：\r\n\r\n- 对客户端使用keepAlive全部配上，使用默认值\r\n- 对上游服务器使用keepAlive全部配上，使用默认值\r\n\r\n#### KeepAlive压测：AB安装使用\r\n\r\napache benchmark：一款压力测试插件，直接通过yum安装即可\r\n\r\nyum install httpd-tools\r\n\r\n参数说明：\r\n\r\n- **-n  即requests，用于指定压力测试总共的执行次数。**\r\n- **-c  即concurrency，用于指定的并发数。**\r\n- -t  即timelimit，等待响应的最大时间(单位：秒)。\r\n- -b  即windowsize，TCP发送/接收的缓冲大小(单位：字节)。\r\n- -p  即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数。\r\n- -u  即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数。\r\n- -T  即content-type，用于设置Content-Type请求头信息，例如：application/x-www-form-urlencoded，默认值为text/plain。\r\n- -v  即verbosity，指定打印帮助信息的冗余级别。\r\n- -w  以HTML表格形式打印结果。\r\n- -i  使用HEAD请求代替GET请求。\r\n- -x  插入字符串作为table标签的属性。\r\n- -y  插入字符串作为tr标签的属性。\r\n- -z  插入字符串作为td标签的属性。\r\n- -C  添加cookie信息，例如：\"Apache=1234\"(可以重复该参数选项以添加多个)。\r\n- -H  添加任意的请求头，例如：\"Accept-Encoding: gzip\"，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。\r\n- -A  添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。\r\n- -P  添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。\r\n- -X  指定使用的和端口号，例如:\"126.10.10.3:88\"。\r\n- -V  打印版本号并退出。\r\n- -k  使用HTTP的KeepAlive特性。\r\n- -d  不显示百分比。\r\n- -S  不显示预估和警告信息。\r\n- -g  输出结果信息到gnuplot格式的文件中。\r\n- -e  输出结果信息到CSV格式的文件中。\r\n- -r  指定接收到错误信息时不退出程序。\r\n- -h  显示用法信息，其实就是ab -help。\r\n\r\n压测语句：\r\n\r\n```shell\r\nab -n 100000 c 30 http://192.168.111.102/\r\n```\r\n\r\n**直连nginx**\r\n\r\n```\r\nServer Software:        nginx/1.21.6\r\nServer Hostname:        192.168.44.102\r\nServer Port:            80\r\n\r\nDocument Path:          /\r\nDocument Length:        16 bytes\r\n\r\nConcurrency Level:      30\r\nTime taken for tests:   13.035 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nWrite errors:           0\r\nTotal transferred:      25700000 bytes\r\nHTML transferred:       1600000 bytes\r\nRequests per second:    7671.48 [#/sec] (mean)\r\nTime per request:       3.911 [ms] (mean)\r\nTime per request:       0.130 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          1925.36 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0    0   0.4      0      12\r\nProcessing:     1    3   1.0      3      14\r\nWaiting:        0    3   0.9      3      14\r\nTotal:          2    4   0.9      4      14\r\n\r\nPercentage of the requests served within a certain time (ms)\r\n  50%      4\r\n  66%      4\r\n  75%      4\r\n  80%      4\r\n  90%      5\r\n  95%      5\r\n  98%      6\r\n  99%      7\r\n 100%     14 (longest request)\r\n```\r\n\r\n**反向代理**\r\n\r\n```\r\nServer Software:        nginx/1.21.6\r\nServer Hostname:        192.168.44.101\r\nServer Port:            80\r\n\r\nDocument Path:          /\r\nDocument Length:        16 bytes\r\n\r\nConcurrency Level:      30\r\nTime taken for tests:   25.968 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nWrite errors:           0\r\nTotal transferred:      25700000 bytes\r\nHTML transferred:       1600000 bytes\r\nRequests per second:    3850.85 [#/sec] (mean)\r\nTime per request:       7.790 [ms] (mean)\r\nTime per request:       0.260 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          966.47 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0    0   0.2      0      13\r\nProcessing:     3    8   1.4      7      22\r\nWaiting:        1    7   1.4      7      22\r\nTotal:          3    8   1.4      7      22\r\n\r\nPercentage of the requests served within a certain time (ms)\r\n  50%      7\r\n  66%      8\r\n  75%      8\r\n  80%      8\r\n  90%      9\r\n  95%     10\r\n  98%     12\r\n  99%     13\r\n 100%     22 (longest request)\r\n```\r\n\r\n**直连Tomcat**\r\n\r\n```\r\nServer Software:        nginx/1.21.6\r\nServer Hostname:        192.168.44.105\r\nServer Port:            8080\r\n\r\nDocument Path:          /\r\nDocument Length:        7834 bytes\r\n\r\nConcurrency Level:      30\r\nTime taken for tests:   31.033 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nWrite errors:           0\r\nTotal transferred:      804300000 bytes\r\nHTML transferred:       783400000 bytes\r\nRequests per second:    3222.38 [#/sec] (mean)\r\nTime per request:       9.310 [ms] (mean)\r\nTime per request:       0.310 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          25310.16 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0    0   0.3      0      15\r\nProcessing:     0    9   7.8      7     209\r\nWaiting:        0    9   7.2      7     209\r\nTotal:          0    9   7.8      7     209\r\n\r\nPercentage of the requests served within a certain time (ms)\r\n  50%      7\r\n  66%      9\r\n  75%     11\r\n  80%     13\r\n  90%     18\r\n  95%     22\r\n  98%     27\r\n  99%     36\r\n 100%    209 (longest request)\r\n```\r\n\r\n**nginx反向代理Tomcat + keepalive**\r\n\r\n```\r\nServer Software:        nginx/1.21.6\r\nServer Hostname:        192.168.44.101\r\nServer Port:            80\r\n\r\nDocument Path:          /\r\nDocument Length:        7834 bytes\r\n\r\nConcurrency Level:      30\r\nTime taken for tests:   23.379 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nWrite errors:           0\r\nTotal transferred:      806500000 bytes\r\nHTML transferred:       783400000 bytes\r\nRequests per second:    4277.41 [#/sec] (mean)\r\nTime per request:       7.014 [ms] (mean)\r\nTime per request:       0.234 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          33688.77 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0    0   0.2      0       9\r\nProcessing:     1    7   4.2      6     143\r\nWaiting:        1    7   4.2      6     143\r\nTotal:          1    7   4.2      6     143\r\n\r\nPercentage of the requests served within a certain time (ms)\r\n  50%      6\r\n  66%      7\r\n  75%      7\r\n  80%      7\r\n  90%      8\r\n  95%     10\r\n  98%     13\r\n  99%     16\r\n 100%    143 (longest request)\r\n```\r\n\r\n**nginx反向代理Tomcat** \r\n\r\n```\r\nServer Software:        nginx/1.21.6\r\nServer Hostname:        192.168.44.101\r\nServer Port:            80\r\n\r\nDocument Path:          /\r\nDocument Length:        7834 bytes\r\n\r\nConcurrency Level:      30\r\nTime taken for tests:   33.814 seconds\r\nComplete requests:      100000\r\nFailed requests:        0\r\nWrite errors:           0\r\nTotal transferred:      806500000 bytes\r\nHTML transferred:       783400000 bytes\r\nRequests per second:    2957.32 [#/sec] (mean)\r\nTime per request:       10.144 [ms] (mean)\r\nTime per request:       0.338 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          23291.74 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0    0   0.2      0       9\r\nProcessing:     1   10   5.5      9     229\r\nWaiting:        1   10   5.5      9     229\r\nTotal:          1   10   5.5      9     229\r\n\r\nPercentage of the requests served within a certain time (ms)\r\n  50%      9\r\n  66%     10\r\n  75%     11\r\n  80%     11\r\n  90%     13\r\n  95%     14\r\n  98%     17\r\n  99%     19\r\n 100%    229 (longest request)\r\n```\r\n\r\n\r\n\r\n### UpStream(反向代理上游集群)工作流程\r\n\r\n![image-20230624174235190](image/nginxadvanced.assets/image-20230624174235190.png)\r\n\r\n![image-20230624174246944](image/nginxadvanced.assets/image-20230624174246944.png)\r\n\r\n![image-20230624174400920](image/nginxadvanced.assets/image-20230624174400920.png)\r\n\r\n![image-20230624174406412](image/nginxadvanced.assets/image-20230624174406412.png)\r\n\r\nproxy_pass 向上游服务器请求数据共有6个阶段\r\n\r\n- 初始化\r\n- 与上游服务器建立连接\r\n- 向上游服务器发送请求\r\n- 处理响应头\r\n- 处理响应体\r\n- 结束\r\n\r\n#### ==<font color=\'red\'>对客户端的限制配置</font>==\r\n\r\n可配置位置\r\n\r\n- <font color=\'cornflowerblue\'>http</font>\r\n- <font color=\'cornflowerblue\'>server</font>\r\n- <font color=\'cornflowerblue\'>**location**</font>\r\n\r\n\r\n\r\n- **client_body_buffer_size**\r\n\r\n对客户端请求中的body缓冲区大小\r\n\r\n默认32位系统8k 64位16k\r\n\r\n如果请求体大于配置，则写入临时文件\r\n\r\n- **client_header_buffer_size**\r\n\r\n设置读取客户端请求体的缓冲区大小。 如果请求体大于缓冲区，则将整个请求体或仅将其部分写入临时文件。 默认32位8K。 64位平台16K。  \r\n\r\n- **client_max_body_size 1000M;**\r\n\r\n默认1m，如果一个请求的大小超过配置的值，会返回413 (request Entity Too Large)错误给客户端\r\n\r\n将size设置为0将禁用对客户端请求正文大小的检查。  \r\n\r\n- **client_body_timeout**\r\n\r\n指定客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）\r\n\r\n- **client_header_timeout**\r\n\r\n客户端向服务端发送一个完整的 request header 的超时时间。如果客户端在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。\r\n\r\n- **client_body_temp_path** *path*` [`*level1*` [`*level2*` [`*level3*`]]]\r\n\r\n在磁盘上客户端的body临时缓冲区位置\r\n\r\n**client_body_in_file_only on;**\r\n\r\n把body写入磁盘文件，请求结束也不会删除\r\n\r\n- **client_body_in_single_buffer**\r\n\r\n尽量缓冲body的时候在内存中使用连续单一缓冲区，在二次开发时使用`$request_body`读取数据时性能会有所提高\r\n\r\n- **client_header_buffer_size** \r\n\r\n设置读取客户端请求头的缓冲区大小\r\n\r\n如果一个请求行或者一个请求头字段不能放入这个缓冲区，那么就会使用large_client_header_buffers\r\n\r\n- **large_client_header_buffers**\r\n\r\n默认8k\r\n\r\n\r\n\r\n\r\n\r\n#### ==<font color=\'red\'>header和连接配置</font>==\r\n\r\n<font color=\'cornflowerblue\'>配置位置：推荐location</font>\r\n\r\n- **add_header	 |	 proxy_set_header**\r\n\r\n设置header\r\n\r\n- **proxy_connect_timeout** \r\n\r\n与上游服务器连接超时时间、快速失败\r\n\r\n- **proxy_send_timeout**\r\n\r\n定义nginx向后端服务发送请求的间隔时间(不是耗时)。默认60秒，超过这个时间会关闭连接\r\n\r\n- **proxy_read_timeout**\r\n\r\n后端服务给nginx响应的时间，规定时间内后端服务没有给nginx响应，连接会被关闭，nginx返回504 Gateway Time-out。默认60秒\r\n\r\n#### ==<font color=\'red\'>缓冲区配置</font>==\r\n\r\n<font color=\'cornflowerblue\'>配置位置：推荐location</font>\r\n\r\n- **proxy_requset_buffering**\r\n\r\n是否完全读到请求体之后再向上游服务器发送请求\r\n\r\n- **proxy_buffering** \r\n\r\n是否缓冲上游服务器数据\r\n\r\n- **proxy_buffers 32 64k;**\r\n\r\n缓冲区大小 32个 64k大小内存缓冲块\r\n\r\n- **proxy_buffer_size**\r\n\r\nheader缓冲区大小\r\n\r\n```nginx\r\nproxy_requset_buffering on;\r\nproxy_buffering on;\r\n\r\nproxy_buffer_size 64k;\r\n\r\nproxy_buffers 32 128k;\r\nproxy_busy_buffers_size 8k;\r\nproxy_max_temp_file_size 1024m;\r\n```\r\n\r\n- **proxy_temp_file_write_size 8k**\r\n\r\n当启用从代理服务器到临时文件的响应的缓冲时，一次限制写入临时文件的数据的大小。 默认情况下，大小由proxy_buffer_size和proxy_buffers指令设置的两个缓冲区限制。 临时文件的最大大小由proxy_max_temp_file_size指令设置。  \r\n\r\n- **proxy_max_temp_file_size 1024m;**\r\n\r\n临时文件最大值\r\n\r\n- **proxy_temp_path** \r\n\r\n> ```\r\n> proxy_temp_path /spool/nginx/proxy_temp 1 2;\r\n> ```\r\n\r\na temporary file might look like this:\r\n\r\n> ```\r\n> /spool/nginx/proxy_temp/7/45/00000123457\r\n> ```\r\n\r\n\r\n\r\n#### UpStream配置总结\r\n\r\n自己的阿里云服务器配置示例：\r\n\r\n需要配置下列一项才能完成登录等post请求，否侧会返回500\r\n            proxy_set_header Host $host;\r\n\r\n注释掉的都可以配一配，参考的别人的\r\n\r\n```nginx\r\n		location / {\r\n\r\n\r\n            #反向代理到集群，配置负载均衡\r\n            proxy_pass http://47.115.207.49:8099/;\r\n    		proxy_set_header Host $host;\r\n    \r\n            #proxy_redirect off;\r\n            #proxy_set_header X-Real-IP $remote_addr;\r\n            #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;           \r\n            #proxy_set_header Cookie $http_cookie;\r\n\r\n            #proxy_send_timeout 1300;\r\n            #proxy_read_timeout 1300;\r\n            #proxy_buffer_size 64k;\r\n            #proxy_buffers 8 64k;\r\n            #proxy_busy_buffers_size 128k;\r\n            #proxy_temp_file_write_size 64k;\r\n            #client_max_body_size 10m;\r\n            #client_body_buffer_size 128k;\r\n            #proxy_connect_timeout 1300;\r\n\r\n            #root   /www/www;\r\n            #index  index.html index.htm;\r\n        }\r\n```\r\n\r\n\r\n\r\n#### 获取客户端真实IP\r\n\r\n用到header设置：	proxy_set_header\r\n\r\n**X-Real-IP**\r\n\r\n额外模块，不推荐使用\r\n\r\n**X-Forwarded-For**\r\n\r\n```\r\nproxy_set_header X-Forwarded-For $remote_addr;\r\n```\r\n\r\n$remote_addr	：	前置ip地址，这里是获取nginx服务器的前置ip，那就是客户端ip\r\n\r\n若有两层nginx服务器，一种方法是转发第一层nginx发过来的remote_addr，另一种方法是不覆盖再加一个header记录第二层nginx的remote_addr\r\n\r\n\r\n\r\n### Gzip\r\n\r\n![image-20230627140313937](image/nginxadvanced.assets/image-20230627140313937.png)\r\n\r\n适合静态资源，但是\r\n\r\n**二进制资源**：例如图片/mp3这样的二进制文件,不必压缩；因为压缩率比较小, 比如100->80字节,而且压缩也是耗费CPU资源的.\r\n\r\n#### Gzip动态压缩配置\r\n\r\n作用域 `http, server, location`\r\n\r\n- **gzip on;**\r\n\r\n开关，默认关闭\r\n\r\n- **gzip_buffers 32 4k|16 8k**\r\n\r\n缓冲区大小\r\n\r\n32位cpu推荐选 32 4k\r\n\r\n64位cpu推荐选 16 8k\r\n\r\n- **gzip_comp_level 1；**\r\n\r\n压缩等级 1-9，数字越大压缩比越高\r\n\r\n推荐1-6\r\n\r\n- **gzip_http_version 1.1;**\r\n\r\n使用gzip的最小版本\r\n\r\n- **gzip_min_length**\r\n\r\n设置将被gzip压缩的响应的最小长度。 长度仅由“Content-Length”响应报头字段确定。\r\n\r\n大于这个设置长度才会压缩数据，否则不压缩\r\n\r\n一般1k~5K\r\n\r\n- **gzip_proxied 多选**\r\n\r\noff 为不做限制\r\n\r\n作为反向代理时，针对上游服务器返回的头信息进行压缩\r\n\r\nexpired - 启用压缩，如果header头中包含 \"Expires\" 头信息\r\nno-cache - 启用压缩，如果header头中包含 \"Cache-Control:no-cache\" 头信息\r\nno-store - 启用压缩，如果header头中包含 \"Cache-Control:no-store\" 头信息\r\nprivate - 启用压缩，如果header头中包含 \"Cache-Control:private\" 头信息\r\nno_last_modified - 启用压缩,如果header头中不包含 \"Last-Modified\" 头信息\r\nno_etag - 启用压缩 ,如果header头中不包含 \"ETag\" 头信息\r\nauth - 启用压缩 , 如果header头中包含 \"Authorization\" 头信息\r\nany - 无条件启用压缩\r\n\r\n\r\n\r\n- **gzip_vary on;**\r\n\r\n增加一个header，适配老的浏览器 `Vary: Accept-Encoding`\r\n\r\n- **gzip_types**\r\n\r\n哪些mime类型的文件进行压缩\r\n\r\n- **gzip_disable**\r\n\r\n禁止某些浏览器使用gzip\r\n\r\n会使用正则表达式，<font color=\'red\'>一般不推荐配置文件使用正则表达式，会额外消耗服务器的性能</font>\r\n\r\n**完整实例**\r\n\r\n<font color=\'cornflowerblue\'>加载location或者server中</font>\r\n\r\n<font color=\'cornflowerblue\'>使用Gzip动态压缩会导致sendFile功能无法使用，于是使用静态压缩来解决这个问题，静态压缩只用给nginx加装module即可，配置加一行gzip_static on; 	前提：服务器硬盘指定静态资源的位置，已经有压缩好的文件.gz</font>\r\n\r\n```nginx\r\n  gzip on;\r\n  gzip_buffers 16 8k;\r\n  gzip_comp_level 6;\r\n  gzip_http_version 1.1;\r\n  gzip_min_length 256;\r\n  gzip_proxied any;\r\n  gzip_vary on;\r\n  gzip_types text/plain application/x-javascript text/css application/xml;\r\n  gzip_types\r\n    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml\r\n    text/javascript application/javascript application/x-javascript\r\n    text/x-json application/json application/x-web-app-manifest+json\r\n    text/css text/plain text/x-component\r\n    font/opentype application/x-font-ttf application/vnd.ms-fontobject\r\n    image/x-icon;\r\n  #gzip_disable \"MSIE [1-6]\\.(?!.*SV1)\";	#正则会消耗服务器性能，不推荐配置\r\n```\r\n\r\n未配置gzip的响应报文\r\n\r\n```http\r\nHTTP/1.1 200\r\nServer: nginx/1.21.6\r\nDate: Wed, 18 May 2022 17:42:35 GMT\r\nContent-Type: text/html;charset=utf-8\r\nContent-Length: 7832\r\nConnection: keep-alive\r\nKeep-Alive: timeout=65\r\n```\r\n\r\n配置gzip的响应报文\r\n\r\n```http\r\nHTTP/1.1 200\r\nServer: nginx/1.21.6\r\nDate: Wed, 18 May 2022 17:42:35 GMT\r\nContent-Type: text/html;charset=utf-8\r\nTransfer-Encoding: chunked\r\nConnection: keep-alive\r\nKeep-Alive: timeout=65\r\nVary: Accept-Encoding\r\nContent-Encoding: gzip\r\n```\r\n\r\n#### Gzip静态压缩\r\n\r\n**http_gzip_static_module**\r\n\r\n<font color=\'cornflowerblue\'>前提：服务器硬盘指定静态资源的位置，已经有压缩好的文件.gz</font>\r\n\r\n需要重新编译nginx\r\n\r\n<font color=\'cornflowerblue\'>configure时记得加上自己原本有的后缀</font>\r\n\r\n```shell\r\n./configure --with-http_gzip_static_module\r\n```\r\n\r\n编译后make和复制启动命令，具体参考	使用sticky模块完成对Nginx的负载均衡		部分\r\n\r\n配置：在动态压缩的基础上加上gzip_static on;\r\n\r\n```nginx\r\ngzip_static on;\r\n```\r\n\r\n**ngx_http_gunzip_module**\r\n\r\n不常用\r\n\r\n作用：将压缩包发送给客户端前，帮助先解压再给客户端\r\n\r\n帮助不支持gzip的客户端解压本地文件\r\n\r\n```shell\r\n./configure --with-http_gunzip_module\r\n```\r\n\r\n配置：在前面的配置基础上加上gunzip on;并修改为gzip_static always;\r\n\r\n```nginx\r\ngunzip on;\r\ngzip_static always;\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Brotli（Br）\r\n\r\nBrotli为比Gzip压缩比更高的压缩方式，需要加载新的nginx模块才能实现\r\n\r\n可以和Gzip共存，若客户端不支持Brotli则使用Gzip\r\n\r\n**安装模块**\r\n\r\n- 官网\r\n\r\n  - `https://github.com/google/ngx_brotli`\r\n\r\n  - `https://codeload.github.com/google/brotli/tar.gz/refs/tags/v1.0.9`\r\n\r\n- 下载 两个项目\r\n\r\n- 解压缩\r\n\r\n- 将brotli-1.0.9目录下的所有东西移动到ngx_brotli-1.0.0rc/deps/brotli/下\r\n\r\n```shell\r\ncd /root/brotli-1.0.9/\r\nmv ./* /root/ngx_brotli-1.0.0rc/deps/brotli/\r\n```\r\n\r\n模块化编译\r\n\r\n<font color=\'cornflowerblue\'>configure时记得加上自己原本有的后缀</font>\r\n\r\n--add-dynamic-module：动态编译，临时存在于nginx\r\n\r\n```shell\r\n./configure --with-compat --add-dynamic-module=/root/ngx_brotli-1.0.0rc\r\n```\r\n\r\n或\r\n\r\n```\r\n--add-dynamic-module=brotli目录\r\n```\r\n\r\n- make\r\n- 将objs中的`ngx_http_brotli_filter_module.so` `ngx_http_brotli_static_module.so`拷贝到`/usr/local/nginx/modules/`\r\n- 备份然后复制nginx主程序\r\n\r\n**配置文件中添加**\r\n\r\n在最外层加，例如配置文件最前面\r\n\r\n```\r\nload_module \"/usr/local/nginx/modules/ngx_http_brotli_filter_module.so\";\r\nload_module \"/usr/local/nginx/modules/ngx_http_brotli_static_module.so\";\r\n```\r\n\r\n<font color=\'cornflowerblue\'>location或server加（和Gzip一起）</font>\r\n\r\n```nginx\r\n	brotli on;\r\n    brotli_static on;\r\n	brotli_comp_level 6;\r\n	brotli_buffers 16 8k;\r\n	brotli_min_length 20;\r\n	brotli_types text/plain text/css text/javascript application/javascript text/xml application/xml application/xml+rss application/json image/jpeg image/gif image/png;\r\n\r\n```\r\n\r\n\r\n\r\n- 测试\r\n\r\n默认http协议是没有br的，即http请求头中没有带br的请求方式，需要使用curl自己指定header\r\n\r\n```\r\ncurl -H \'Accept-Encoding: br\' -I http://192.168.111.100\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 反向代理中的容错机制\r\n\r\n#### 参考文档\r\n\r\nhttps://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/\r\n\r\nhttp://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_bind\r\n\r\n\r\n\r\n**proxy_timeout** \r\n\r\n\r\n\r\n#### 重试机制\r\n\r\n**proxy_next_upstream**\r\n\r\n作用：\r\n\r\n当后端服务器返回指定的错误时，将请求传递到其他服务器。\r\n\r\n`error`与服务器建立连接，向其传递请求或读取响应头时发生错误;\r\n\r\n`timeout`在与服务器建立连接，向其传递请求或读取响应头时发生超时;\r\n\r\n`invalid_header`服务器返回空的或无效的响应;\r\n\r\n`http_500`服务器返回代码为500的响应;\r\n\r\n`http_502`服务器返回代码为502的响应;\r\n\r\n`http_503`服务器返回代码为503的响应;\r\n\r\n`http_504`服务器返回代码504的响应;\r\n\r\n`http_403`服务器返回代码为403的响应;\r\n\r\n`http_404`服务器返回代码为404的响应;\r\n\r\n`http_429`服务器返回代码为429的响应;\r\n\r\n不了解这个机制，在日常开发web服务的时候，就可能会踩坑。\r\n\r\n比如有这么一个场景：一个用于导入数据的web页面，上传一个excel，通过读取、处理excel，向数据库中插入数据，处理时间较长（如1分钟），且为同步操作（即处理完成后才返回结果）。暂且不论这种方式的好坏，若nginx配置的响应等待时间（proxy_read_timeout）为30秒，就会触发超时重试，将请求又打到另一台。如果处理中没有考虑到重复数据的场景，就会发生数据多次重复插入！（当然，这种场景，内网可以通过机器名访问该服务器进行操作，就可以绕过nginx了，不过外网就没办法了。）\r\n\r\n\r\n\r\n## 并发调优\r\n\r\n### Concat合并客户端请求\r\n\r\n![image-20230627143528769](image/nginxadvanced.assets/image-20230627143528769.png)\r\n\r\n将文本类的请求合并起来成一个请求（需要修改代码），再发给客户端，<font color=\'cornflowerblue\'>能够减少并发请求，让并发量变小</font>提高能处理的并发数\r\n\r\n虽然多个类似于css文件会额外消耗服务器性能，但为了便于管理，也会分开来\r\n\r\nConcat模块\r\n\r\nTengine\r\n\r\nNginx官方介绍\r\n\r\nhttps://www.nginx.com/resources/wiki/modules/concat/\r\n\r\ngit地址\r\n\r\nhttps://github.com/alibaba/nginx-http-concat\r\n\r\n- 安装\r\n\r\n下载源码到/root目录\r\n\r\n解压\r\n\r\nnginx重新编译\r\n\r\n<font color=\'cornflowerblue\'>configure时记得加上自己原本有的后缀</font>\r\n\r\n```shell\r\n./configure .... --add-module=/root/nginx-http-concat-master/\r\n```\r\n\r\n- make\r\n- 备份复制nginx主程序\r\n- 配置\r\n\r\n例如css引用：\r\n\r\n```html\r\n<link href=\"??font.css,bg.css\"rel=\"stylesheet\">\r\n```\r\n\r\n配置文件：server或location\r\n\r\n```nginx\r\n    concat on;\r\n    concat_max_files 30;\r\n```\r\n\r\n\r\n\r\n### 资源静态化\r\n\r\n![image-20230627151618632](image/nginxadvanced.assets/image-20230627151618632.png)\r\n\r\n**高并发下：把资源做为静态资源放到Nginx。**\r\n\r\n- 类似于商品列表和详情页这种<font color=\'cornflowerblue\'>并发量高，但总体页面变化不大的页面</font>，\r\n- 可以使用资源静态化的方式将请求的页面生成一个静态页面存储起来，每次直接返回静态页面即可\r\n- 优点：商品列表和详情页的并发量高，可以跳过服务器计算和连接数据库读取数据的过程，直接返回静态页面，<font color=\'cornflowerblue\'>降低延迟度和并发量</font>\r\n- 静态页面存储在nginx，或者使用openresty技术（内置模板引擎，落地磁盘）直接跳过nginx连接DB生成静态页面\r\n- 再使用异步请求的方式更新页面中变化的动态数据\r\n- nginx服务器需要用到**rsync**进行资源同步\r\n\r\n\r\n\r\n**例如一个item.html，可分为三个部分：**\r\n\r\n- 1.实际内容\r\n\r\n- 2.固定公用->抽取 静态（<font color=\'cornflowerblue\'>例如header和footer，是common的</font>）\r\n\r\n  - 前端->节约服务器端的计算资源消耗请求数\r\n\r\n  - 后端->使用SSI合并服务端文件（下一节讲），类似使用模板引擎（例如thymeleaf）\r\n\r\n- 3.关联的内容->引用 动态资源\r\n\r\n\r\n\r\n•高并发系统资源静态化方案\r\n\r\n•一致性问题\r\n\r\n•合并文件输出\r\n\r\n•集群文件同步\r\n\r\n\r\n\r\n生成静态页面自己去学\r\n\r\n\r\n\r\n### SSI合并nginx服务器端文件\r\n\r\n<font color=\'cornflowerblue\'>类似使用模板引擎（例如thymeleaf）</font>\r\n\r\n不推荐过于复杂使用ssi，否则高消耗服务器性能，专业的事交给模板引擎来做\r\n\r\n\r\n\r\n服务端文件是nginx的文件，例如动静分离的静态文件html等等\r\n\r\n官方文档：http://nginx.org/en/docs/http/ngx_http_ssi_module.html\r\n\r\n#### 配置文件配置\r\n\r\n- **ssi on|off**\r\n\r\n开启关闭ssi\r\n\r\n- **ssi_last_modified on|off**\r\n\r\n是否保留lastmodified\r\n\r\n默认off，每次输出的都是新文件\r\n\r\n- **ssi_min_file_chunk size** \r\n\r\n向磁盘存储并使用sendfile发送，文件大小最小值\r\n\r\n默认1k，当大于1k时存储再磁盘上并用sendfile发送\r\n\r\n- **ssi_silent_errors on|off** \r\n\r\n不显示逻辑语法错误\r\n\r\n默认off，当类似于	<!--# include1 file=\"footer.html\" -->	的语法错误，将直接返回不友好提示\r\n\r\non：语法错误时不提示，但是类似找不到文件，也会返回404错误提示\r\n\r\n- **ssi_types** \r\n\r\n默认text/html，只支持解析html的ssi功能\r\n\r\n如果需要其他mime类型 需要设置\r\n\r\n- **ssi_value_length length**\r\n\r\n限制脚本参数最大长度\r\n\r\n\r\n\r\n要配置一般开启就行\r\n\r\n配置在server或者location中\r\n\r\n```nginx\r\nssi on\r\nssi_silent_errors on\r\n```\r\n\r\n\r\n\r\n#### SSI命令配置\r\n\r\n配置在配置文件配置ssi_types(例如html)中\r\n\r\n\r\n\r\n- **include file**\r\n\r\n```\r\n<!--# include file=\"footer.html\" -->\r\n```\r\n\r\n静态文件直接引用\r\n\r\n- **block**\r\n\r\n```\r\n<!--# block name=\"one\" -->\r\nstub\r\n<!--# endblock -->\r\n```\r\n\r\n可以声明一个ssi的命令块，里面可以包裹其他命令\r\n\r\n- **config**\r\n\r\n  - 1、errmsg:\r\n\r\n    配置文件配置ssi_silent_errors off时，即会返回不友好的语法错误提示\r\n\r\n    用于修改提示信息的内容\r\n\r\n    ```\r\n    [an error occurred while processing the directive]\r\n    ```\r\n\r\n    在模板中配置报错情况\r\n\r\n  - 2、timefmt:\r\n\r\n    ```\r\n    \"%A, %d-%b-%Y %H:%M:%S %Z\"\r\n    ```\r\n\r\n    日期格式化\r\n\r\n- **echo**\r\n\r\n  直接输出变量\r\n\r\n  - var变量名称\r\n\r\n  ```\r\n  <!--# echo var=\"name” default=\"no” -->\r\n  ```\r\n\r\n  - encoding 是否使用特殊编码格式\r\n\r\n  - default 变量没有值的时候使用默认值\r\n\r\n- **if**\r\n\r\n逻辑判断\r\n\r\n```\r\n<!--# if expr=\"...\" -->\r\n...\r\n<!--# elif expr=\"...\" -->\r\n...\r\n<!--# else -->\r\n...\r\n<!--# endif -->\r\n\r\neg：\r\n变量存在性检查：\r\n<!--# if expr=\"$name\" -->\r\n变量与文本的比较：\r\n<!--# if expr=\"$name = text\" -->\r\n<!--# if expr=\"$name != text\" -->\r\n变量与正则表达式的比较：\r\n<!--# if expr=\"$name = /text/\" -->\r\n<!--# if expr=\"$name != /text/\" -->\r\n如果 a 包含变量， 它们的值被替换。 正则表达式可以包含位置捕获和命名捕获 以后可以通过变量使用，例如：text\r\n<!--# if expr=\"$name = /(.+)@(?P<domain>.+)/\" -->\r\n    <!--# echo var=\"1\" -->\r\n    <!--# echo var=\"domain\" -->\r\n<!--# endif -->\r\n```\r\n\r\n<font color=\'cornflowerblue\'>正则不推荐使用，会高消耗服务器性能</font>\r\n\r\n- **include virtual**\r\n\r\n可以指向location，而不一定是具体文件\r\n\r\n指定包含的请求，例如：\r\n\r\n```\r\n<!--# include virtual=\"/remote/body.php?argument=value\" -->\r\n```\r\n\r\n如果需要顺序处理，则应使用该参数。`wait`\r\n\r\n- **include wait**\r\n\r\n如果需要顺序处理，则应使用该参数。`wait`\r\n\r\n```\r\n<!--# include virtual=\"/remote/body.php?argument=value\" wait=\"yes\" -->\r\n```\r\n\r\n- **include stub**\r\n\r\n一个非标准参数，用于命名其块 如果包含的请求导致空，则将输出内容 正文，或者在请求处理过程中发生错误，例如：\r\n\r\n```\r\n<!--# block name=\"one\" -->&nbsp;<!--# endblock -->\r\n<!--# include virtual=\"/remote/body.php?argument=value\" stub=\"one\" -->\r\n```\r\n\r\n- **include set**\r\n\r\n指示写入成功结果的非标准参数 对指定变量的请求处理， 例如：\r\n\r\n```\r\n<!--# include virtual=\"/remote/body.php?argument=value\" set=\"one\" -->\r\n```\r\n\r\n\r\n\r\n### rsync \r\n\r\n![image-20230627184302481](image/nginxadvanced.assets/image-20230627184302481.png)\r\n\r\nhttps://www.samba.org/ftp/rsync/rsync.html\r\n\r\nremote synchronize是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机之间的文件。也可以使用 rsync 同步本地硬盘中的不同目录。\r\nrsync 是用于替代 rcp 的一个工具，rsync 使用所谓的 rsync算法 进行数据同步，这种算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。\r\n\r\nrsync 基于inotify 开发\r\n\r\n\r\n\r\nRsync有三种模式：\r\n\r\n- 本地模式（类似于cp命令）\r\n- 远程模式（类似于scp命令）\r\n- 守护进程（socket进程：是rsync的重要功能）\r\n\r\n\r\n\r\n#### rsync手动拉取同步源文件\r\n\r\n**安装**\r\n\r\n两端安装\r\n\r\n```\r\nyum install -y rsync\r\n```\r\n\r\n**源服务器修改配置文件**\r\n\r\n```\r\nvim /etc/rsyncd.conf\r\n```\r\n\r\n内容：\r\n\r\n```nginx\r\n [ftp]\r\n        path = /usr/local/nginx/html\r\n```\r\n\r\n**源服务器启动rsync**\r\n\r\n```\r\nrsync--daemon\r\n```\r\n\r\n**目标服务器查看源文件夹**\r\n\r\n```\r\nrsync --list-only 192.168.111.100::ftp/\r\n```\r\n\r\nftp/为源服务器配置文件配置的[ftp]\r\n\r\n**目标服务器手动拉取同步文件**\r\n\r\n```\r\nrsync -avz 192.168.111.100::ftp/ /usr/local/nginx/html\r\n```\r\n\r\n同步到自己的/usr/local/nginx/html目录下\r\n\r\n<font color=\'cornflowerblue\'>现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：\r\n\r\n```\r\n--delete\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 增加安全认证及免密\r\n\r\n**源服务器增加密码文件**\r\n\r\n```\r\necho \"sgg:111\" >> /etc/rsyncd.pwd\r\n\r\nchmod 600 /etc/rsyncd.pwd\r\n```\r\n\r\n**源服务器修改配置文件**\r\n\r\n```\r\nvim /etc/rsyncd.conf\r\n```\r\n\r\n```\r\nauth users = sgg\r\nsecrets file = /etc/rsyncd.pwd\r\n\r\n[ftp]\r\n       path = /usr/local/nginx/html\r\n```\r\n\r\n**源服务器重启rsync**\r\n\r\n```\r\nps -ef | grep rsync\r\nkill -9 进程号\r\nrsync --daemon\r\n```\r\n\r\n**目标服务器输入密码登录查看**\r\n\r\n```\r\nrsync --list-only sgg@192.168.111.100::ftp/\r\n```\r\n\r\n\r\n\r\n**目标服务器创建client密码文件**	**实现免密**\r\n\r\n```shell\r\necho \"111\" >> /etc/rsyncd.pwd.client\r\nchmod 600 /etc/rsyncd.pwd.client\r\n\r\nrsync --list-only --password-file=/etc/rsyncd.pwd.client sgg@192.168.111.100::ftp/\r\n\r\nrsync -avz --password-file=/etc/rsyncd.pwd.client sgg@192.168.111.100::ftp/ /usr/local/nginx/html\r\n```\r\n\r\n此时在客户端已经可以配合脚本实现定时同步了\r\n\r\n<font color=\'cornflowerblue\'>现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：\r\n\r\n```\r\n--delete\r\n```\r\n\r\n\r\n\r\n#### 源服务器推送文件\r\n\r\n**目标服务器增加密码文件**\r\n\r\n```\r\necho \"sgg:111\" >> /etc/rsyncd.pwd\r\nchmod 600 /etc/rsyncd.pwd\r\n```\r\n\r\n**目标服务器修改配置文件**\r\n\r\n```\r\nvim /etc/rsyncd.conf\r\n```\r\n\r\n```nginx\r\nauth users = sgg\r\nsecrets file = /etc/rsyncd.pwd\r\nread only = no		#关闭只读，让别人可以写进来\r\n\r\n[ftp]\r\n       path = /usr/local/nginx/html\r\n```\r\n\r\n**目标服务器启动rsync**\r\n\r\n```\r\nrsync --daemon\r\n```\r\n\r\n**源服务器创建client密码文件**\r\n\r\n```\r\necho \"111\" >> /etc/rsyncd.pwd.client\r\nchmod 600 /etc/rsyncd.pwd.client\r\n```\r\n\r\n**源服务器推送给目标服务器**\r\n\r\n与拉取比只是交换了目录和目标ip\r\n\r\n```\r\nrsync -avz --password-file=/etc/rsyncd.pwd.client /usr/local/nginx/html/ sgg@192.168.111.101::ftp/ \r\n```\r\n\r\n注意发送目录/usr/local/nginx/html/最后要加	\'/\'，否则发送的是文件夹，不是文件夹下的东西\r\n\r\n<font color=\'cornflowerblue\'>现在只能增量同步</font>，若要删除源服务器没有的文件，需要加上参数实现完全同步：\r\n\r\n```\r\n--delete\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### inotify监控自动推送\r\n\r\n**源服务器推送端安装inotify**\r\n\r\n依赖\r\n\r\n```\r\nyum install -y automake\r\n```\r\n\r\n下载上传tar包：\r\n\r\n我的是		inotify-tools-3.14.tar.gz\r\n\r\n```\r\ntar -zxvf inotify-tools-3.14.tar.gz\r\n```\r\n\r\nconfigure\r\n\r\n```\r\ncd inotify-tools-3.14/\r\n./configure --prefix=/usr/local/inotify\r\nmake && make install\r\n```\r\n\r\n**源服务器监控目录**\r\n\r\n监控源服务器的/usr/local/nginx/html/目录\r\n\r\n```nginx\r\n/usr/local/inotify/bin/inotifywait -mrq --timefmt \'%Y-%m-%d %H:%M:%S\' --format \'%T %w%f %e\' -e close_write,modify,delete,create,attrib,move //usr/local/nginx/html/\r\n```\r\n\r\n**更改目标服务器配置文件**\r\n\r\n```nginx\r\n uid = root		#设置user\r\n gid = root		#设置用户组\r\n auth users = sgg\r\n secrets file = /etc/rsyncd.pwd\r\n read only = no\r\n\r\n [ftp]\r\n        path = /usr/local/nginx/html\r\n```\r\n\r\n**保证源和目标服务器rsync服务已启动且读取了最新配置文件**\r\n\r\n```\r\nps -ef | grep rsync\r\nkill -9 进程号\r\nrsync --daemon\r\n```\r\n\r\n**源服务器编写简单自动化脚本**\r\n\r\n```\r\ncd /root/bin\r\nvim autoRsync.sh\r\n```\r\n\r\n内容：\r\n\r\n```shell\r\n#!/bin/bash\r\n\r\n/usr/local/inotify/bin/inotifywait -mrq --timefmt \'%d/%m/%y %H:%M\' --format \'%T %w%f %e\' -e close_write,modify,delete,create,attrib,move //usr/local/nginx/html/ | while read file\r\ndo\r\n       \r\n        rsync -az --delete --password-file=/etc/rsyncd.pwd.client /usr/local/nginx/html/ sgg@192.168.111.101::ftp/\r\ndone\r\n```\r\n\r\n**源服务器修改文件权限**\r\n\r\n```\r\nchmod 777 autoRsync.sh\r\nchmod 777 /usr/local/nginx/html\r\n```\r\n\r\n**启动脚本**\r\n\r\n```\r\nautoRsync.sh\r\n```\r\n\r\n\r\n\r\n#### 常用参数\r\n\r\n**rsync 常用选项**\r\n\r\n| 选项     | 含义                                                         |\r\n| :------- | :----------------------------------------------------------- |\r\n| -a       | 包含-rtplgoD                                                 |\r\n| -r       | 同步目录时要加上，类似cp时的-r选项                           |\r\n| -v       | 同步时显示一些信息，让我们知道同步的过程                     |\r\n| -l       | 保留软连接                                                   |\r\n| -L       | 加上该选项后，同步软链接时会把源文件给同步                   |\r\n| -p       | 保持文件的权限属性                                           |\r\n| -o       | 保持文件的属主                                               |\r\n| -g       | 保持文件的属组                                               |\r\n| -D       | 保持设备文件信息                                             |\r\n| -t       | 保持文件的时间属性                                           |\r\n| –delete  | 删除DEST中SRC没有的文件                                      |\r\n| –exclude | 过滤指定文件，如–exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步 |\r\n| -P       | 显示同步过程，比如速率，比-v更加详细                         |\r\n| -u       | 加上该选项后，如果DEST中的文件比SRC新，则不同步              |\r\n| -z       | 传输时压缩                                                   |\r\n\r\n**inotify常用参数**\r\n\r\n| 参数       | 说明                                                         | 含义                                                         |\r\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| -r         | --recursive                                                  | #递归查询目录                                                |\r\n| -q         | --quiet                                                      | #打印很少的信息，仅仅打印监控事件信息                        |\r\n| -m         | --monitor                                                    | #始终保持事件监听状态                                        |\r\n| --excludei |                                                              | #排除文件或目录时，不区分大小写                              |\r\n| --timefmt  |                                                              | #指定事件输出格式                                            |\r\n| --format   |                                                              | #打印使用指定的输出类似格式字符串                            |\r\n| -e         | --event[ -e\\|--event ... ]accessmodifyattribcloseopenmove_tomove createdeleteumount | #通过此参数可以指定要监控的事件 #文件或目录被读取#文件或目录的内容被修改#文件或目录属性被改变#文件或目录封闭，无论读/写模式#文件或目录被打开#文件或目录被移动至另外一个目录#文件或目录被移动另一个目录或从另一个目录移动至当前目录#文件或目录被创建在当前目录#文件或目录被删除#文件系统被卸载 |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 多级缓存\r\n\r\n![image-20230628204302590](image/nginxadvanced.assets/image-20230628204302590.png)\r\n\r\n### 浏览器缓存\r\n\r\n**什么时候可以用缓存？**\r\n\r\n1. 不常改变的内容\r\n2. 过期时间\r\n3. 针对post/get请求都可以\r\n4. 存储位置\r\n5. 磁盘使用空间限制\r\n\r\n观察京东缓存及加载速度\r\n\r\n- deskcache\r\n\r\n字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，**不会请求服务器**一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况\r\n\r\n- memorycache\r\n\r\n是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，**不会请求服务器**但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache\r\n\r\n\r\n\r\n**Age**\r\n\r\n是CDN添加的属性表示在CDN中缓存了多少秒\r\n\r\n**via**\r\n\r\n用来标识CDN缓存经历了哪些服务器，缓存是否命中，使用的协议\r\n\r\n\r\n\r\n#### 强制缓存\r\n\r\n**cache-control**\r\n\r\nhttp1.1的规范，使用max-age表示文件可以在浏览器中缓存的时间以秒为单位\r\n\r\n| 标记                   | 类型       | 功能                                                         |\r\n| :--------------------- | ---------- | ------------------------------------------------------------ |\r\n| public                 | 响应头     | 响应的数据可以被缓存，客户端和代理层都可以缓存               |\r\n| private                | 响应头     | 可私有缓存，客户端可以缓存，代理层不能缓存（CDN，proxy_pass） |\r\n| no-cache               | 请求头     | 可以使用本地缓存，但是必须发送请求到服务器回源验证           |\r\n| no-store               | 请求和响应 | 应禁用缓存                                                   |\r\n| max-age                | 请求和响应 | 文件可以在浏览器中缓存的时间以秒为单位                       |\r\n| s-maxage               | 请求和响应 | 用户代理层缓存，CDN下发，当客户端数据过期时会重新校验        |\r\n| max-stale              | 请求和响应 | 缓存最大使用时间，如果缓存过期，但还在这个时间范围内则可以使用缓存数据 |\r\n| min-fresh              | 请求和响应 | 缓存最小使用时间，                                           |\r\n| must-revalidate        | 请求和响应 | 当缓存过期后，必须回源重新请求资源。比no-cache更严格。因为HTTP 规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候。那么带有must-revalidate的缓存必须校验，其他条件全部失效。 |\r\n| proxy-revalidate       | 请求和响应 | 和must-revalidate类似，只对CDN这种代理服务器有效，客户端遇到此头，需要回源验证 |\r\n| stale-while-revalidate | 响应       | 表示在指定时间内可以先使用本地缓存，后台进行异步校验         |\r\n| stale-if-error         | 响应       | 在指定时间内，重新验证时返回状态码为5XX的时候，可以用本地缓存 |\r\n| only-if-cached         | 响应       | 那么只使用缓存内容，如果没有缓存 则504 getway timeout        |\r\n\r\n在浏览器和服务器端验证文件是否过期的时候，浏览器在二次请求的时候会携带IF-Modified-Since属性\r\n\r\n\r\n\r\n**Expires**\r\n\r\n设置强制缓存过期时间\r\n\r\n\r\n\r\n**配置**\r\n\r\n<font color=\'cornflowerblue\'>location中</font>\r\n\r\n**使用expires配置**\r\n\r\n```\r\nexpires 30s;   #缓存30秒\r\nexpires 30m;  #缓存30分钟   \r\nexpires 2h;     #缓存2小时\r\nexpires 30d;    #缓存30天\r\n```\r\n\r\n**使用cache-control**\r\n\r\n优先级高于expires\r\n\r\n```\r\nadd_header cache-control \"max-age:300\";		#单位s\r\n```\r\n\r\n<font color=\'cornflowerblue\'>浏览器缓存很取决于浏览器的策略，一般只会在新标签页的首次访问才会使用强制缓存</font>\r\n\r\n\r\n\r\n#### 协商缓存\r\n\r\n**last-modified**\r\n\r\n**etag**\r\n\r\nhttp1.1支持\r\n\r\n在HTTP协议中If-Modified-Since和If-None-Match分别对应Last-Modified和ETag\r\n\r\nEntity Tag 的缩写，中文译过来就是实体标签的意思.\r\n\r\nHTTP中并没有指定如何生成ETag，哈希是比较理想的选择。\r\n\r\n在计算Etag的时候，会产生CPU的耗费，所以也可以用时间戳，但这样直接使用Last-Modified即可。\r\n\r\nETag 用来校验用户请求的资源是否有变化，作用和lastmodified很像，区别是lastmodified精确到秒，ETag可以用hash算法来生成更精确的比对内容。\r\n\r\n**当用户首次请求资源的时候返回给用户数据和200状态码并生成ETag，再次请求的时候服务器比对ETag，没有发生变化的话返回304**\r\n\r\nCache-Control直接是通过不请求来实现，而ETag是会发请求的，只不过服务器根据请求的东西的内容有无变化来判断是否返回请求的资源\r\n\r\n\r\n\r\n**配置**\r\n\r\nHttp1.1自带协商缓存，一般浏览器默认开启\r\n\r\n**禁用协商缓存：**\r\n\r\nserver或location\r\n\r\n```\r\netag off;\r\nif_modified_since off;\r\n或\r\netag off;\r\nadd_header Last-Modified \"\";\r\n```\r\n\r\n\r\n\r\n#### 总结\r\n\r\n- **cache-control | expires 强制缓存**\r\n  - 浏览器缓存很取决于浏览器的策略，一般只会在新标签页的首次访问才会使用强制缓存\r\n\r\n- **etag | lastmodify  协商缓存**\r\n  - 发送请求header中携带Last-Modified，若未修改服务器会返回304 Not Modified\r\n\r\n- **强制缓存和协商缓存可配合使用**\r\n  - 首次访问使用强制缓存，用户手动刷新将会发送请求，若服务器判断未修改，则返回304\r\n\r\n- **last-modified 会与ssi的冲突**\r\n\r\n- **浏览器缓存原则**\r\n\r\n  - 多级集群负载时last-modified必须**保持一致**\r\n\r\n  - 还有一些场景下我们希望禁用浏览器缓存。比如轮训api上报数据数据\r\n\r\n  - 浏览器缓存很难彻底禁用，大家的做法是加版本号，随机数等方法。\r\n\r\n  - 只缓存200响应头的数据，像3XX这类跳转的页面不需要缓存。\r\n\r\n  - 对于js，css这类可以缓存很久的数据，可以通过加版本号的方式更新内容\r\n\r\n  - 不需要强一致性的数据，可以缓存几秒\r\n\r\n  - 异步加载的接口数据，可以使用ETag来校验。\r\n\r\n  - 在服务器添加Server头，有利于排查错误\r\n\r\n\r\n  - 分为手机APP和Client以及是否遵循http协议\r\n\r\n\r\n  - 在没有联网的状态下可以展示数据\r\n\r\n\r\n  - 流量消耗过多\r\n\r\n\r\n  - **提前下发**  避免秒杀时同时下发数据造成流量短时间暴增\r\n\r\n  - **兜底数据** 在服务器崩溃和网络不可用的时候展示\r\n\r\n  - 临时缓存  退出即清理\r\n  - 固定缓存  展示框架这种，可能很长时间不会更新，可用随客户端下发\r\n    - **首页**有的时候可以看做是框架，首页经常变化应该禁用缓存，以保证加载的资源都是最新的\r\n\r\n  - 父子连接 页面跳转时有一部分内容不需要重新加载，可用从父菜单带过来\r\n\r\n  - 预加载     某些逻辑可用判定用户接下来的操作，那么可用异步加载那些资源\r\n\r\n  - 漂亮的加载过程 异步加载 先展示框架，然后异步加载内容，避免主线程阻塞\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### GEOip\r\n\r\n根据用户的ip获取用户所在地\r\n\r\n**1 下载数据库**\r\n\r\n官网需注册登录,下载数据库\r\n\r\nmaxmind.com\r\n\r\n数据库有country版和city版是免费的，商业版更精确需要收费\r\n\r\n**2 安装依赖**\r\n\r\n官方git	https://github.com/maxmind/libmaxminddb\r\n\r\n下载后执行编译安装之后\r\n\r\n```\r\n$ echo /usr/local/lib  >> /etc/ld.so.conf.d/local.conf \r\n$ ldconfig\r\n```\r\n\r\n**Nginx模块**\r\n\r\nhttps://github.com/leev/ngx_http_geoip2_module\r\n\r\n更完整的配置可参考官方文档\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_geoip_module.html#geoip_proxy\r\n\r\n编译安装，不再讲\r\n\r\n```\r\n./configure --prefix=......	--with.......... --add-module=/root/ngx_http_geoip2_module\r\n```\r\n\r\n**Nginx配置**\r\n\r\n```nginx\r\n#http添加\r\ngeoip2 /root/GeoLite2-ASN_20220524/GeoLite2-ASN.mmdb {\r\n    $geoip2_country_code country iso_code;\r\n}\r\n\r\n#location添加\r\nadd_header country $geoip2_country_code;\r\n```\r\n\r\n\r\n\r\n### 正向代理配置\r\n\r\n```nginx\r\n#server中配置google提供的DNS服务器进行解析\r\nresolver 8.8.8.8;\r\n\r\n#location中\r\nproxy_pass $scheme://$host$request_uri;\r\n```\r\n\r\n还需要在浏览器中设置代理服务器的信息，设置过后就可以正常代理访问http请求了\r\n\r\n若要能访问https请求，还需要添加下面的模块（一般不会使用nginx作为正向代理服务器）\r\n\r\n\r\n\r\n**代理https请求**\r\n\r\n需要第三方模块\r\n\r\nhttps://github.com/chobits/ngx_http_proxy_connect_module\r\n\r\n下载后对nginx进行重新编译\r\n\r\n**配置**\r\n\r\n```nginx\r\n server {\r\n     listen                         3128;\r\n\r\n     # dns resolver used by forward proxying\r\n     resolver                       8.8.8.8;\r\n\r\n     # forward proxy for CONNECT request\r\n     proxy_connect;\r\n     proxy_connect_allow            443 563;\r\n     proxy_connect_connect_timeout  10s;\r\n     proxy_connect_read_timeout     10s;\r\n     proxy_connect_send_timeout     10s;\r\n\r\n     # forward proxy for non-CONNECT request\r\n     location / {\r\n         proxy_pass http://$host;\r\n         proxy_set_header Host $host;\r\n     }\r\n }\r\n```\r\n\r\n\r\n\r\n### 反向代理proxy缓存\r\n\r\n![image-20230628204302590](image/nginxadvanced.assets/image-20230628204302590.png)\r\n\r\n将资源缓存在nginx服务器\r\n\r\n自己的理解：<font color=\'cornflowerblue\'>与动静分离类似</font>，只不过动静分离在静态资源文件夹更新数据，而反向代理缓存则是设定的时间过期过后可以重新向tomcat发送请求拉取数据，<font color=\'cornflowerblue\'>并且缓存会缓存发起请求时的动态数据</font>\r\n\r\n官网解释\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache\r\n\r\n#### 最小配置\r\n\r\n```nginx\r\n#http模块：\r\nproxy_cache_path /ngx_tmp levels=1:2 keys_zone=test_cache:100m inactive=1d max_size=10g;\r\n#缓存存储目录：/ngx_tmp\r\n\r\n#location模块：\r\nadd_header  Nginx-Cache \"$upstream_cache_status\";\r\nproxy_cache test_cache;\r\nproxy_cache_valid 1h;		#缓存过期时间\r\n```\r\n\r\n \r\n\r\n#### 缓存清理\r\n\r\n**purger**\r\n\r\n手动清理缓存，需要第三方模块支持\r\n\r\nhttps://github.com/FRiCKLE/ngx_cache_purge\r\n\r\n下载解压后使用--add-module重新编译nginx\r\n\r\n**最小配置**\r\n\r\n```nginx\r\n        #新增location\r\n		location ~ /purge(/.*) {\r\n\r\n            proxy_cache_purge  test_cache  $1;\r\n        }\r\n        \r\n		#proxy缓存配置的location中：\r\n        proxy_cache_key $uri;	#自定义cachekey\r\n```\r\n\r\n其中，proxy_cache_key为设置的key，purger会根据设置的key删除指定的缓存\r\n\r\n目前只根据uri为key删除缓存\r\n\r\n**示例：**\r\n\r\n以及访问了192.168.111.100/test.html，此时nginx缓存该页面，该页面的key为test.html，\r\n\r\n**若要清除该缓存，则浏览器访问：192.168.111.100/purge/test.html**\r\n\r\n\r\n\r\n配置以主机名+uri+参数作为key：\r\n\r\n```nginx\r\n        #新增location\r\n		location ~ /purge(/.*) {\r\n\r\n            proxy_cache_purge  test_cache  $host$1$is_args$args;\r\n        }\r\n        \r\n		#proxy缓存配置的location中：\r\n        proxy_cache_key $host$uri$is_args$args;	#自定义cachekey\r\n```\r\n\r\nproxy_cache_key和proxy_cache_purge要对应修改\r\n\r\n\r\n\r\n#### 断点续传缓存range\r\n\r\n当有完整的content-length之后即可断点续传\r\n\r\n在反向代理服务器中需向后传递header\r\n\r\n```\r\nproxy_set_header Range $http_range;\r\n```\r\n\r\nproxy_cache_key中增加range\r\n\r\n根据header中的Range获取对应的partial-content，会返回206\r\n\r\n\r\n\r\n#### 详细配置\r\n\r\n- **proxy_cache_key** \r\n\r\n默认`$scheme$proxy_host$request_uri`\r\n\r\n缓存的key\r\n\r\n- **proxy_cache_revalidate** \r\n\r\n过期后可以和协商缓存类似，如果缓存过期了，向上游服务器发送“If-Modified-Since” and “If-None-Match来验证是否改变，如果没有就不需要重新下载资源了\r\n\r\n- **proxy_cache_valid** \r\n\r\n可以针对不容http状态码设置缓存过期时间\r\n\r\n不设置状态码会默认200, 301, 302\r\n\r\n```\r\nproxy_cache_valid 200 302 10m;\r\nproxy_cache_valid 301      1h;\r\nproxy_cache_valid any      1m;\r\n```\r\n\r\nany指其他任意状态码\r\n\r\n- **proxy_cache_use_stale** \r\n\r\n默认off\r\n\r\n在什么时候可以使用过期缓存\r\n\r\n可选`error` | `timeout` | `invalid_header` | `updating` | `http_500` | `http_502` | `http_503` | `http_504` | `http_403` | `http_404` | `http_429` | `off`\r\n\r\n- **proxy_cache_background_update** \r\n\r\n默认off\r\n\r\n运行开启子请求更新过期的内容。同时会把过期的内容返回给客户端\r\n\r\n- **proxy_no_cache**  **proxy_cache_bypass** \r\n\r\n指定什么时候不使用缓存而直接请求上游服务器\r\n\r\n```\r\nproxy_no_cache $cookie_nocache $arg_nocache$arg_comment;\r\nproxy_no_cache $http_pragma    $http_authorization;\r\n```\r\n\r\n如果这些变量如果存在的话不为空或者不等于0，则不使用缓存\r\n\r\n- **proxy_cache_convert_head** \r\n\r\n默认 on\r\n\r\n是否把head请求转换成get请求后再发送给上游服务器 以便缓存body里的内容\r\n\r\n如果关闭 需要在 `cache key` 中添加 $request_method 以便区分缓存内容\r\n\r\n- **proxy_cache_lock** \r\n\r\n默认off\r\n\r\n缓存更新锁\r\n\r\n- **proxy_cache_lock_age** \r\n\r\n默认5s\r\n\r\n缓存锁超时时间\r\n\r\n- **proxy_cache_max_range_offset** \r\n\r\nrange最大值，超过之后不做缓存，默认情况下 不需要对单文件较大的资源做缓存\r\n\r\n- **proxy_cache_methods** \r\n\r\n默认 head get\r\n\r\n- **proxy_cache_min_uses** \r\n\r\n默认1\r\n\r\n被请求多少次之后才做缓存\r\n\r\n- **proxy_cache_path** \r\n\r\npath 指定存储目录\r\n\r\n以cache_key取md5值\r\n\r\n- **levels=1:2**\r\n\r\n目录层级数及目录名称位数\r\n\r\n取mdb5后几位\r\n\r\nTMPFS\r\n\r\n- **use_temp_path**\r\n\r\n默认创建缓存文件时，先向缓冲区创建临时文件，再移动到缓存目录\r\n\r\n是否使用缓冲区\r\n\r\n- **inactive** \r\n\r\n指定时间内未被访问过的缓存将被删除\r\n\r\n\r\n\r\n# 第二部分 高效\r\n\r\n\r\n\r\n## Nginx内存缓存\r\n\r\n![image-20230628204302590](image/nginxadvanced.assets/image-20230628204302590.png)\r\n\r\n**适用场景**：内存高速，但是内存较小，一般应用为静态文件元数据（索引）信息缓存、热点数据缓存\r\n\r\n\r\n\r\n**strace追踪内核**\r\n\r\n追踪内核查看sendfile执行过程\r\n\r\n安装：\r\n\r\n```\r\nyum install -y strace\r\n```\r\n\r\n追踪：\r\n\r\n```shell\r\nps -ef | grep nginx\r\nstrace -p 进程号	#nginx第一个worker的进程号\r\n```\r\n\r\nsendfile执行过程\r\n\r\n```\r\nepoll_wait(8, [{EPOLLIN, {u32=1904243152, u64=140709327827408}}, {EPOLLIN, {u32=1904242704, u64=140709327826960}}], 512, 25215) = 2\r\nrecvfrom(10, \"GET / HTTP/1.1\\r\\nHost: 192.168.44\"..., 1024, 0, NULL, NULL) = 475\r\nstat(\"/usr/local/nginx//html/index.html\", {st_mode=S_IFREG|0644, st_size=1429, ...}) = 0\r\nopen(\"/usr/local/nginx//html/index.html\", O_RDONLY|O_NONBLOCK) = 11\r\nfstat(11, {st_mode=S_IFREG|0644, st_size=1429, ...}) = 0\r\nwritev(10, [{iov_base=\"HTTP/1.1 200 OK\\r\\nServer: nginx/1\"..., iov_len=263}], 1) = 263\r\nsendfile(10, 11, [0] => [1429], 1429)   = 1429\r\nwrite(4, \"192.168.44.1 - - [27/May/2022:14\"..., 193) = 193\r\nclose(11) \r\n```\r\n\r\n使用sendfile，上面执行过程将不会具体读取文件内容，<font color=\'cornflowerblue\'>sendfile是使用内存的</font>\r\n\r\n\r\n\r\n**open_file_cache配置**\r\n\r\n这里是缓存在内存中的，**用于加速sendfile**\r\n\r\n配置在server下\r\n\r\n```nginx\r\nopen_file_cache max=500 inactive=60s;\r\nopen_file_cache_min_uses 1; \r\nopen_file_cache_valid 60s; \r\nopen_file_cache_errors on;\r\n```\r\n\r\n**max**缓存最大数量，超过数量后会使用LRU淘汰\r\n\r\n**inactive** 指定时间内未被访问过的缓存将被删除\r\n\r\n**pen_file_cache_min_uses**\r\n\r\n被访问到多少次后会开始缓存\r\n\r\n**open_file_cache_valid**\r\n\r\n间隔多长时间去检查文件是否有变化\r\n\r\n**open_file_cache_errors**\r\n\r\n对错误信息是否缓存\r\n\r\n\r\n\r\n## Nginx外置缓存缓存\r\n\r\n通过网络使用其他机器的内存\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_memcached_module.html\r\n\r\n### error_page\r\n\r\n指定状态码，默认指向location\r\n\r\n```nginx\r\nerror_page 404 =302 http://www.atguigu.com;		#若404则返回302重定向到http://www.atguigu.com\r\n\r\nerror_page 404 =200 /401.html	#若2404则返回200然后跳转到401页面\r\n```\r\n\r\n<font color=\'cornflowerblue\'>	`=`	后面不能有空格</font>\r\n\r\n\r\n\r\n### 匿名location\r\n\r\n```nginx\r\nerror_page 404 =@666;\r\nlocation @666 {\r\n    add_header content-type \"text/html\";	#若加了content-type，浏览器就知道怎么处理文本，不加则不显示\r\n    return 200 \"hi world!\";\r\n}\r\n```\r\n\r\n若未指定content-type，返回的返回的数据不会被展示，状态码为**886**，代表浏览器不知道怎么处理数据，会下载返回的数据到本机\r\n\r\n此配置代表：若404，则跳转到自定义页面	/666/index.html，状态码为200，网页内容为	hi world!\r\n\r\n\r\n\r\n### nginx + memcached\r\n\r\n![image-20230629175942043](image/nginxadvanced.assets/image-20230629175942043.png)\r\n\r\n**作用：将 `uri+args` 作为key存储在内存当中，当用户请求对应的uri时，从内存中找到后直接返回给用户，若未找到，则反向代理到上游服务器，然后将数据添加到内存中再返回给用户。**\r\n\r\n\r\n\r\n`memcached：内存缓存`\r\n\r\n**memcached安装**\r\n\r\n```\r\nyum -y install memcached\r\n```\r\n\r\n默认配置文件在\r\n\r\n`/etc/sysconfig/memcached`\r\n\r\n查看状态\r\n\r\n```\r\nsystemctl start memcached\r\nmemcached-tool 127.0.0.1:11211  stats\r\n```\r\n\r\n**安装telnet**\r\n\r\n```\r\nyum -y install telnet\r\n```\r\n\r\n向内存写东西\r\n\r\n```shell\r\ntelnet 127.0.0.1 11211\r\nset [key] 0 0 3		#0 0 x	： x个字节\r\n123\r\nget [key]\r\n```\r\n\r\n为下面nginx实验写入数据准备：\r\n\r\n```\r\nset /? 0 0 5\r\n12345\r\n```\r\n\r\n**nginx配置**\r\n\r\n```nginx\r\n   	upstream backend {\r\n   		server 192.168.44.104:8080;\r\n   	}\r\n\r\n	http {\r\n    	location / {\r\n\r\n        set 		   $memcached_key \"$uri?$args\";		#uri+args作为key\r\n        memcached_pass 127.0.0.1:11211;\r\n\r\n        add_header X-Cache-Satus HIT;\r\n        add_header Content-Type \'text/html; charset=utf-8\'; # 强制响应数据格式为html\r\n\r\n        # root   html;		#内存中没有内容则发出请求请求数据添加到内存，不需要返回页面了\r\n     	}\r\n    \r\n    	error_page 404 =@fallback;\r\n    	\r\n	    location @fallback {\r\n        	proxy_set_header memcached_key $memcached_key;\r\n        	proxy_pass http://192.168.44.104:8080;\r\n    	}\r\n    \r\n	}\r\n```\r\n\r\n将 `uri+args` 作为key存储在内存当中，当用户请求对应的uri时，从内存中找到后直接返回给用户，若未找到，则反向代理到上游服务器，然后将数据添加到内存中再返回给用户。\r\n\r\n这里我们是去前面手动写入第一次访问的数据12345，真实场景中需要后端tomcat服务器来写入\r\n\r\n\r\n\r\n### nginx + redis\r\n\r\n<font color=\'cornflowerblue\'>nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font>\r\n以上功能主要由后面讲的openresty处实现，这里主要讲外置缓存\r\n\r\n**redis快速安装**\r\n\r\n```\r\nyum install epel-release\r\nyum install -y redis\r\n```\r\n\r\n也可以自己下载后规范安装：https://codeload.github.com/redis/redis/tar.gz/refs/tags/7.0.0\r\n\r\n\r\n\r\n**redis2-nginx-module** \r\n\r\nredis2-nginx-module是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。\r\n\r\nhttps://www.nginx.com/resources/wiki/modules/redis2/\r\n\r\nhttps://github.com/openresty/redis2-nginx-module\r\n\r\n上传后解压，重新编译nginx\r\n\r\n```shell\r\ncd /opt/nginx-1.21.6\r\n./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-stream --with-http_gzip_static_module --add-module=/root/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d --add-module=/root/redis2-nginx-module-0.15\r\n\r\nmake\r\ncd objs\r\nmv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\r\ncp nginx /usr/local/nginx/sbin/\r\n```\r\n\r\n**启动redis**\r\n\r\n规范安装示例，快速安装应该已经自动启动和配置好了redis-server\r\n\r\n```\r\n在根目录下创建一个目录/myredis，并将/opt/redis-7.0.10/redis.conf文件复制到myredis目录下，保留原文件\r\n/myredis/redis.conf配置文件的修改：\r\n​	1.将daemonize no 改为 daemonize yes\r\n​	2.protected-mode yes 改为protected-mode no\r\n​	3.注释掉bind 127.0.0.1 -::1\r\n​	4.requirepass设置密码\r\n```\r\n\r\n```shell\r\nredis-server /myredis/redis.conf\r\nredis-cli\r\nauth [password]\r\nping	#若弹出pong则为连接客户端成功\r\n```\r\n\r\n**配置**\r\n\r\n**test**\r\n\r\n```nginx\r\nlocation = /foo {\r\n\r\n	 default_type text/html;\r\n\r\n     redis2_query auth 123123;	#自己的redis密码\r\n\r\n     set $value \'first\';\r\n\r\n     redis2_query set one $value;\r\n\r\n     redis2_pass 127.0.0.1:6379;\r\n }\r\n```\r\n\r\n浏览器访问192.168.111.100/foo可以向redis中写值，根据配置，写的键值对为	`one:fire`\r\n\r\n**get**\r\n\r\n```nginx\r\nlocation = /get {\r\n\r\n	 default_type text/html;\r\n\r\n     redis2_pass 127.0.0.1:6379;\r\n\r\n     redis2_query auth 123123;	#自己的redis密码\r\n\r\n     #set_unescape_uri $key $arg_key;  # this requires ngx_set_misc\r\n\r\n     redis2_query get $arg_key;\r\n\r\n}\r\n```\r\n\r\n浏览器访问 192.168.111.100/get?key=one	可获得one的值\r\n\r\n**set**\r\n\r\n```nginx\r\n# GET /set?key=one&val=first%20value\r\n\r\nlocation = /set {\r\n\r\n     default_type text/html;\r\n\r\n     redis2_pass 127.0.0.1:6379;\r\n\r\n     redis2_query auth 123123;\r\n \r\n     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc\r\n\r\n     set_unescape_uri $val $arg_val;  # this requires ngx_set_misc\r\n\r\n     redis2_query set $key $val;\r\n\r\n }\r\n```\r\n\r\n\r\n\r\n**pipeline**\r\n\r\n```nginx\r\n     set $value \'first\';\r\n\r\n     redis2_query set one $value;\r\n\r\n     redis2_query get one;\r\n\r\n     redis2_query set one two;\r\n\r\n     redis2_query get one;\r\n\r\n	 redis2_query del key1;\r\n```\r\n\r\n**list**\r\n\r\n```lua\r\n    redis2_query lpush key1 C;\r\n\r\n    redis2_query lpush key1 B;\r\n\r\n    redis2_query lpush key1 A;\r\n\r\n	redis2_query lrange key1 0 -1;\r\n```\r\n\r\n**集群**\r\n\r\n```nginx\r\nupstream redis_cluster {\r\n\r\n     server 192.168.199.161:6379;\r\n\r\n     server 192.168.199.161:6379;\r\n\r\n }\r\n\r\nlocation = /redis {\r\n\r\n	  default_type text/html;\r\n\r\n      redis2_next_upstream error timeout invalid_response;\r\n\r\n      redis2_query get foo;\r\n\r\n      redis2_pass redis_cluster;\r\n}\r\n```\r\n\r\n\r\n\r\n## Stream模块为nginx反向代理mysql\r\n\r\n<font color=\'red\'>配置文件中和http同级，是提供tcp服务的配置</font>\r\n\r\nhttp://nginx.org/en/docs/stream/ngx_stream_core_module.html\r\n\r\n重新编译nginx：\r\n\r\n```shell\r\n./configure ...... --with-stream \r\nmake\r\nmv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\r\ncp objs/nginx /usr/local/nginx/sbin/\r\n```\r\n\r\n\r\n\r\n额外开两台mysql服务器，一主一从，\r\n\r\n配置nginx服务器stream tcp服务，和http同级\r\n\r\n```nginx\r\nstream {\r\n\r\n    upstream mysql {\r\n		\r\n		server 192.168.111.101:3306;\r\n		server 192.168.111.102:3306;\r\n    }\r\n\r\n    server {\r\n        listen       3306;\r\n        proxy_pass  mysql;\r\n	 }\r\n}\r\nhttp {\r\n	...\r\n}\r\n```\r\n\r\n\r\n\r\n## 限流\r\n\r\n**QPS限制**\r\n\r\n官方文档\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_limit_req_module.html\r\n\r\n测试工具\r\n\r\nhttps://jmeter.apache.org/\r\n\r\n配置\r\n\r\n```nginx\r\n#http中\r\nlimit_req_zone $binary_remote_addr zone=test:10m rate=1r/s;\r\n#zone=test：与location中zone对应\r\n#rate=15r/s：限流，15qps每秒，每秒只接收15个请求\r\n\r\n#location中\r\nlimit_req zone=test		#每秒处理500个请求\r\n\r\nlimit_req zone=test burst=5;	#采用漏斗算法，允许平均每秒不超过1个请求，突发不超过5个请求。5个请求满后，后续请求全部排队，若排队超时则失败\r\n\r\nlimit_req zone=test burst=5 nodelay;	#如果不希望在限制请求时延迟过多的请求，则应使用参数nodelay，不会再有排队的请求，桶外请求全部快速失败\r\n```\r\n\r\n**带宽限制**\r\n\r\n```nginx\r\n#location中：\r\nlimit_rate_after 1m;	#设置刚开始的带宽\r\nlimit_rate 1k;	#设置带宽\r\n```\r\n\r\n**并发数限制**\r\n\r\n```nginx\r\n#http中\r\nlimit_conn_zone $binary_remote_addr zone=test2:10m;\r\n\r\n#location中：\r\nlimit_conn test2 1;\r\n```\r\n\r\n\r\n\r\n## 日志\r\n\r\n- **ngx_http_log_module**\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_log_module.html\r\n\r\n默认日志目录：\r\n\r\n正常访问日志：nignx/logs/access.log\r\n\r\n错误日志：nignx/logs/error.log\r\n\r\nlinux可使用	`tail -f /usr/local/nginx/logs/access.log`	实时追踪日志文件\r\n\r\n\r\n\r\n- **ngx_http_empty_gif_module**\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_empty_gif_module.html\r\n\r\n```nginx\r\nlocation = /_.gif {\r\n    empty_gif;\r\n}\r\n```\r\n\r\n只有1个像素的gif，肉眼看不出，用于收集用户的行为信息\r\n\r\n\r\n\r\n### access.log配置\r\n\r\n**自定义日志格式**\r\n\r\n| 语法: | `log_format name [escape=default|json|none] string ...;` |\r\n| :---- | -------------------------------------------------------- |\r\n| 默认: | `log_format combined \"...\";`                             |\r\n\r\n示例：http中：\r\n\r\n```nginx\r\n#语法：log_format name [escape=default|json|none] string ...;\r\nlog_format logtest \'$remote_addr - $remote_user [$time_local] \'\r\n                       \'\"$request\" $status $bytes_sent \'\r\n                       \'\"$http_referer\" \"$http_user_agent\" \"$gzip_ratio\"\';\r\n\r\n\r\n```\r\n\r\n日志内容格式定义为json示例：\r\n\r\n```nginx\r\nlog_format ngxlog json \'{\"timestamp\":\"$time_iso8601\",\'\r\n                    \'\"source\":\"$server_addr\",\'\r\n                    \'\"hostname\":\"$hostname\",\'\r\n                    \'\"remote_user\":\"$remote_user\",\'\r\n                    \'\"ip\":\"$http_x_forwarded_for\",\'\r\n                    \'\"client\":\"$remote_addr\",\'\r\n                    \'\"request_method\":\"$request_method\",\'\r\n                    \'\"scheme\":\"$scheme\",\'\r\n                    \'\"domain\":\"$server_name\",\'\r\n                    \'\"referer\":\"$http_referer\",\'\r\n                    \'\"request\":\"$request_uri\",\'\r\n                    \'\"requesturl\":\"$request\",\'\r\n                    \'\"args\":\"$args\",\'\r\n                    \'\"size\":$body_bytes_sent,\'\r\n                    \'\"status\": $status,\'\r\n                    \'\"responsetime\":$request_time,\'\r\n                    \'\"upstreamtime\":\"$upstream_response_time\",\'\r\n                    \'\"upstreamaddr\":\"$upstream_addr\",\'\r\n                    \'\"http_user_agent\":\"$http_user_agent\",\'\r\n                    \'\"http_cookie\":\"$http_cookie\",\'\r\n                    \'\"https\":\"$https\"\'\r\n                    \'}\';\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**自定义日志位置和其他设置**\r\n\r\n| 语法:    | `access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];`            `access_log off;` |\r\n| :------- | ------------------------------------------------------------ |\r\n| default: | `access_log logs/access.log combined;`                       |\r\n\r\n示例：http中\r\n\r\n```nginx\r\naccess_log /ngx_logs/nginx-access.log [logtest] [buffer=32k] [gzip=6] [flush=2m];\r\n#logtest：日志format，可使用log_format配置的名字来引用\r\n#buffer=32k：缓冲大小32k，32k后才写入文件		方括号表示可选\r\n#flush=2m：若两份钟还没打到缓冲区大小，强制写入文件		方括号表示可选\r\n#gzip=6：将记录的日志信息进行压缩，压缩等级1-9		方括号表示可选\r\n\r\nopen_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];\r\n#将日志文件缓存到内存中，减小磁盘的io，最多缓存max=N个日志文件\r\n```\r\n\r\n查看使用gzip的压缩文件\r\n\r\n```shell\r\ncd 设置的或默认日志文件目录\r\ncp access.log access.gz\r\ngzip -d access.gz\r\n```\r\n\r\n\r\n\r\n### errorlog和日志分割\r\n\r\n**errorlog**\r\n\r\nhttp://nginx.org/en/docs/ngx_core_module.html#error_log\r\n\r\n| 语法：     | `error_log file [level];`             |\r\n| :--------- | ------------------------------------- |\r\n| **默认：** | **`error_log logs/error.log error;`** |\r\n\r\n第二个参数决定日志记录的级别，可以是下列参数之一：debug，info，notice，warn，error，crit，alert，emerg【等级弱->强】\r\n\r\n\r\n\r\n**日志分割**\r\n\r\n1.脚本\r\n\r\n2.Logrotate（CentOS自带）\r\n\r\n\r\n\r\n## 健康检查\r\n\r\n### upstream被动式重试机制\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream\r\n\r\n\r\n\r\n对upstream服务器中所有服务器的限制\r\n\r\n**proxy_next_upstream**\r\n\r\n设置当连接upstream服务器集群中的某个服务器第一次失败时，指定在哪些情况下将请求传递到下一个服务器\r\n\r\n| 语法:    | `proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;` |\r\n| :------- | ------------------------------------------------------------ |\r\n| Default: | `proxy_next_upstream error timeout;`                         |\r\n| Context: | `http`, `server`, `location`                                 |\r\n\r\n**proxy_next_upstream_timeout**\r\n\r\n设置重试的超时时间，超时后不再重试，给用户返回错误，默认为0，即不做限制\r\n\r\n| 语法:    | `proxy_next_upstream_timeout time;` |\r\n| :------- | ----------------------------------- |\r\n| Default: | `proxy_next_upstream_timeout 0;`    |\r\n| Context: | `http`, `server`, `location`        |\r\n\r\n**proxy_next_upstream_tries **\r\n\r\n设置重试的最大次数，若超过重试次数，也不再重试，默认为0，即不做限制（proxy_next_upstream_timeout时间内允许proxy_next_upstream_tries次重试，包括第一次）\r\n\r\n| 语法:    | `proxy_next_upstream_tries number;` |\r\n| :------- | ----------------------------------- |\r\n| Default: | `proxy_next_upstream_tries 0;`      |\r\n| Context: | `http`, `server`, `location`        |\r\n\r\n示例：\r\n\r\n```nginx\r\nserver {\r\n	proxy_next_upstream error timeout;\r\n	proxy_next_upstream_timeout 15s;\r\n	proxy_next_upstream_tries 5;\r\n}\r\n```\r\n\r\n\r\n\r\n**upstream参数**\r\n\r\n对upstream中某单一服务器的限制\r\n\r\n- **max_fails**\r\n\r\n最大失败次数\r\n\r\n0为标记一直可用，不检查健康状态\r\n\r\n- **fail_timeout**\r\n\r\n失败时间\r\n\r\n当fail_timeout时间内失败了max_fails次，标记服务不可用	\r\n\r\nfail_timeout时间后会再次激活次服务\r\n\r\n示例：\r\n\r\n```nginx\r\nupstream httpget {\r\n    server 192.168.111.101:8080 max_fails=5 fail_timeout=10s;\r\n    server 192.168.111.102:8080;\r\n}\r\n```\r\n\r\n\r\n\r\n### 主动健康检查\r\n\r\ntengine版\r\n\r\nhttps://github.com/yaoweibin/nginx_upstream_check_module\r\n\r\nnginx商业版\r\n\r\nhttp://nginx.org/en/docs/http/ngx_http_upstream_hc_module.html\r\n\r\n补丁包是1.20.1+，和原来的nginx版本不适配，所以重新装一个nginx\r\n\r\n\r\n\r\n**1 下载nginx-1.20.2和nginx_upstream_check_module-0.3.0.tar.gz**\r\n\r\n下载后解压\r\n\r\n**2 复制check_1.20.1+.patch**\r\n\r\ntengine版网页打开，选择check_1.20.1+.patch，复制到linux\r\n\r\n```shell\r\ncd /root\r\nvim path	#复制到这里\r\n```\r\n\r\n**3 执行patch修改nginx源码**\r\n\r\n```shell\r\ncd nginx-1.20.2\r\nyum install -y patch\r\npatch -p1 < /root/path\r\n```\r\n\r\n**4 编译新的nginx**\r\n\r\n```\r\n./configure --prefix=/usr/local/nginx20 --add-module=/root/nginx_upstream_check_module-0.3.0\r\nmake && make install\r\n```\r\n\r\n**5 配置**\r\n\r\n```nginx\r\n      upstream backend {\r\n    \r\n           server 192.168.111.101:8080;\r\n           server 192.168.111.102:8080;\r\n           check interval=3000 rise=2 fall=5 timeout=1000 type=http;\r\n               check_http_send \"HEAD / HTTP/1.0\\r\\n\\r\\n\";\r\n               check_http_expect_alive http_2xx http_3xx;\r\n   	  }\r\n\r\n    server {\r\n    	listen 80;\r\n    	server_name localhost;\r\n    \r\n   		location /status {\r\n                check_status;\r\n                access_log off;\r\n        }\r\n\r\n\r\n        location / {\r\n        	 proxy_pass http://backend;\r\n             root   html;\r\n        }\r\n    }\r\n```\r\n\r\n**6 启动nginx1.20并访问**\r\n\r\n```shell\r\n/usr/local/nginx20/sbin/nginx -c /usr/local/nginx20/conf/nginx.conf\r\n```\r\n\r\n浏览器访问：192.168.111.100/status\r\n\r\n\r\n\r\n\r\n\r\n## Lua基础语法\r\n\r\n用于 nginx二次开发+Openresty\r\n\r\nLua 是由巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组于1993年开发的一种轻量、小巧的脚本语言，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\r\n\r\n官网：http://www.lua.org/\r\n\r\n**IDE**\r\n\r\nEmmyLua插件\r\n\r\nhttps://github.com/EmmyLua/IntelliJ-EmmyLua\r\n\r\nhttps://emmylua.github.io/zh_CN/\r\n\r\n**LDT 基于eclipse**\r\n\r\nhttps://www.eclipse.org/ldt/\r\n\r\n**Lua基础语法**\r\n\r\n**hello world**\r\n\r\n```lua\r\nprint(\"hello world!\")\r\n```\r\n\r\n**保留关键字**\r\n\r\n`and`       `break`     `do   ` `else`      `elseif`      `end`       `false`    ` for`       `function  if`      `in`        `local`     `nil`      ` not `      `or`      `repeat`    `return`    `then`     ` true`      `until`    ` while`\r\n\r\n**注释**\r\n\r\n```lua\r\n-- 两个减号是行注释\r\n\r\n--[[\r\n\r\n 这是块注释\r\n\r\n 这是块注释.\r\n\r\n --]]\r\n```\r\n\r\n**变量**\r\n\r\n**数字类型**\r\n\r\nLua的数字只有double型，64bits\r\n\r\n你可以以如下的方式表示数字\r\n\r\n ```lua\r\nnum = 1024\r\n\r\nnum = 3.0\r\n\r\nnum = 3.1416\r\n\r\nnum = 314.16e-2\r\n\r\nnum = 0.31416E1\r\n\r\nnum = 0xff\r\n\r\nnum = 0x56\r\n ```\r\n\r\n**字符串**\r\n\r\n可以用单引号，也可以用双引号\r\n\r\n也可以使用转义字符‘\\n’ （换行）， ‘\\r’ （回车）， ‘\\t’ （横向制表）， ‘\\v’ （纵向制表）， ‘\\\\’ （反斜杠）， ‘\\”‘ （双引号）， 以及 ‘\\” （单引号)等等\r\n\r\n下面的四种方式定义了完全相同的字符串（其中的两个中括号可以用于定义有换行的字符串）\r\n\r\n```\r\na = \'alo\\n123\"\'\r\n\r\na = \"alo\\n123\\\"\"\r\n\r\na = \'\\97lo\\10\\04923\"\'\r\n\r\na = [[alo\r\n\r\n123\"]]\r\n```\r\n\r\n**空值**\r\n\r\nC语言中的NULL在Lua中是nil，比如你访问一个没有声明过的变量，就是nil\r\n\r\n**布尔类型**\r\n\r\n只有nil和false是 false\r\n\r\n数字0，‘’空字符串（’\\0’）都是true\r\n\r\n**作用域**\r\n\r\nlua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。\r\n\r\n变量前加local关键字的是局部变量。\r\n\r\n**控制语句**\r\n\r\n**while循环**\r\n\r\n```lua\r\nlocal i = 0\r\n\r\nlocal max = 10\r\n\r\nwhile i <= max do\r\n\r\nprint(i)\r\n\r\ni = i +1\r\n\r\nend\r\n```\r\n\r\n**if-else**\r\n\r\n```lua\r\nlocal function main()\r\n\r\n\r\nlocal age = 140\r\n\r\nlocal sex = \'Male\'\r\n \r\n\r\n  if age == 40 and sex ==\"Male\" then\r\n    print(\" 男人四十一枝花 \")\r\n  elseif age > 60 and sex ~=\"Female\" then\r\n   \r\n    print(\"old man!!\")\r\n  elseif age < 20 then\r\n    io.write(\"too young, too simple!\\n\")\r\n  \r\n  else\r\n  print(\"Your age is \"..age)\r\n  end\r\n\r\nend\r\n\r\n\r\n-- 调用\r\nmain()\r\n\r\n```\r\n\r\n**for循环**\r\n\r\n```lua\r\nsum = 0\r\n\r\nfor i = 100, 1, -2 do\r\n\r\n	sum = sum + i\r\n\r\nend\r\n```\r\n\r\n**函数**\r\n\r\n1.\r\n\r\n```lua\r\nfunction myPower(x,y)\r\n\r\n  return      y+x\r\n\r\nend\r\n\r\npower2 = myPower(2,3)\r\n\r\n print(power2)\r\n```\r\n\r\n2.\r\n\r\n```lua\r\nfunction newCounter()\r\n\r\n   local i = 0\r\n   return function()     -- anonymous function\r\n\r\n        i = i + 1\r\n\r\n        return i\r\n\r\n    end\r\nend\r\n\r\n \r\n\r\nc1 = newCounter()\r\n\r\nprint(c1())  --> 1\r\n\r\nprint(c1())  --> 2\r\n\r\nprint(c1())\r\n```\r\n\r\n**返回值**\r\n\r\n```lua\r\nname, age,bGay = \"yiming\", 37, false, \"yimingl@hotmail.com\"\r\n\r\nprint(name,age,bGay)\r\n```\r\n\r\n ```lua\r\nfunction isMyGirl(name)\r\n  return name == \'xiao6\' , name\r\nend\r\n\r\nlocal bol,name = isMyGirl(\'xiao6\')\r\n\r\nprint(name,bol)\r\n ```\r\n\r\n**Table**\r\n\r\nkey，value的键值对 类似 map\r\n\r\n```lua\r\nlocal function main()\r\ndog = {name=\'111\',age=18,height=165.5}\r\n\r\ndog.age=35\r\n\r\nprint(dog.name,dog.age,dog.height)\r\n\r\nprint(dog)\r\nend\r\nmain()\r\n```\r\n\r\n**数组**\r\n\r\n```lua\r\nlocal function main()\r\narr = {\"string\", 100, \"dog\",function() print(\"wangwang!\") return 1 end}\r\n\r\nprint(arr[4]())\r\nend\r\nmain()\r\n\r\n```\r\n\r\n**遍历**\r\n\r\n```lua\r\narr = {\"string\", 100, \"dog\",function() print(\"wangwang!\") return 1 end}\r\n\r\nfor k, v in pairs(arr) do\r\n\r\n   print(k, v)\r\nend\r\n```\r\n\r\n**成员函数**\r\n\r\n```lua\r\nlocal function main()\r\n\r\nperson = {name=\'旺财\',age = 18}\r\n\r\n  function  person.eat(food)\r\n\r\n    print(person.name ..\" eating \"..food)\r\n\r\n  end\r\nperson.eat(\"骨头\")\r\nend\r\nmain()\r\n\r\n```\r\n\r\n\r\n\r\n## Openresty Nginx + Lua \r\n\r\nNginx是一个主进程配合多个工作进程的工作模式，每个进程由单个线程来处理多个连接。\r\n\r\n在生产环境中，我们往往会把cpu内核直接绑定到工作进程上，从而提升性能。\r\n\r\n### 安装启动\r\n\r\n**预编译安装**\r\n\r\n以CentOS举例 其他系统参照：http://openresty.org/cn/linux-packages.html\r\n\r\n你可以在你的 CentOS 系统中添加 openresty 仓库，这样就可以便于未来安装或更新我们的软件包（通过 yum update 命令）。运行下面的命令就可以添加我们的仓库：\r\n\r\n      yum install yum-utils\r\n\r\n      yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo\r\n\r\n然后就可以像下面这样安装软件包，比如 openresty：\r\n\r\n   yum install openresty\r\n\r\n如果你想安装命令行工具 resty，那么可以像下面这样安装 openresty-resty 包：\r\n\r\n      sudo yum install openresty-resty\r\n\r\n**源码编译安装**\r\n\r\n**下载**\r\n\r\nhttp://openresty.org/cn/download.html\r\n\r\n最小版本基于nginx1.21\r\n\r\n然后在进入 `openresty-VERSION/ `目录, 然后输入以下命令配置:\r\n\r\n```\r\n./configure --prefix=/usr/local/openresty\r\nmake\r\nmake install\r\n```\r\n\r\n默认, `--prefix=/usr/local/openresty` 程序会被安装到`/usr/local/openresty`目录。\r\n\r\n依赖 `gcc openssl-devel pcre-devel zlib-devel`\r\n\r\n安装：`yum install gcc openssl-devel pcre-devel zlib-devel postgresql-devel`\r\n\r\n您可以指定各种选项，比如\r\n\r\n ```\r\n./configure --prefix=/opt/openresty \\\r\n\r\n            --with-luajit \\\r\n\r\n            --without-http_redis2_module \\\r\n\r\n            --with-http_iconv_module \\\r\n\r\n            --with-http_postgres_module\r\n ```\r\n\r\n试着使用 `./configure --help` 查看更多的选项。\r\n\r\n`make && make install`\r\n\r\n**启动**\r\n\r\n`Service openresty start`\r\n\r\n或\r\n\r\n```shell\r\ncd /usr/local/openresty/nginx/sbin\r\n./nginx -c /usr/local/openresty/nginx/conf/nginx.conf	#启动前修改配置文件端口号以防和原nginx冲突\r\n```\r\n\r\n**停止**\r\n\r\n`Service openresty stop`\r\n\r\n**检查配置文件是否正确**\r\n\r\n`Nginx -t`\r\n\r\n 重新加载配置文件\r\n\r\n`Service openresty reload`\r\n\r\n**查看已安装模块和版本号**\r\n\r\n`Nginx -V`\r\n\r\n\r\n\r\n**测试lua脚本**\r\n\r\n```nginx\r\n   #在Nginx.conf 中写入\r\n   location /lua {\r\n\r\n        default_type text/html;\r\n        content_by_lua \'\r\n           ngx.say(\"<p>Hello, World!</p>\")\r\n         \';\r\n    }\r\n```\r\n\r\n不在配置文件写lua，引入lua文件：nginx目录下的lua/hello.lua\r\n\r\n```nginx\r\n        content_by_lua_file lua/hello.lua;\r\n```\r\n\r\n\r\n\r\n### lua-nginx-module\r\n\r\n#### 引入lua环境\r\n\r\n**创建配置文件lua.conf（没必要采用引入方式，直接在nginx配置文件中写location /lua 即可）**\r\n\r\n```nginx\r\nserver {\r\n   listen       80;\r\n   server_name  localhost;\r\n\r\n   location /lua {\r\n        default_type text/html;\r\n        content_by_lua_file lua/hello.lua;\r\n    }\r\n}\r\n```\r\n\r\n**在Nginx.conf下引入lua配置**\r\n\r\n`include       lua.conf;`\r\n\r\n**创建外部lua脚本**\r\n\r\n`nginx目录下的lua/hello.lua`\r\n\r\n内容：\r\n\r\n`ngx.say(\"<p>Hello, World!</p>\")`\r\n\r\n**代码热部署**\r\n\r\n关闭缓存，开启热部署，不用每次都重启openresty nginx\r\n\r\n```\r\nlua_code_cache off;\r\n```\r\n\r\n\r\n\r\n#### 用lua代码获取各值\r\n\r\n**获取Nginx uri中的单一变量**\r\n\r\n ```nginx\r\n     location /nginx_var {\r\n\r\n           default_type text/html;\r\n           content_by_lua_block {\r\n           		ngx.say(ngx.var.arg_a)\r\n         }\r\n     }\r\n ```\r\n\r\n**获取Nginx uri中的所有变量**\r\n\r\n```lua\r\nlocal uri_args = ngx.req.get_uri_args()  \r\nfor k, v in pairs(uri_args) do  \r\n    if type(v) == \"table\" then  \r\n        ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \r\n    else  \r\n        ngx.say(k, \": \", v, \"<br/>\")  \r\n    end  \r\nend\r\n```\r\n\r\n**在处理http请求时还可以使用**\r\n\r\n- set_by_lua\r\n\r\n修改nginx变量\r\n\r\n- rewrite_by_lua\r\n\r\n修改uri\r\n\r\n- access_by_lua\r\n\r\n访问控制\r\n\r\n- header_filter_by_lua\r\n\r\n修改响应头\r\n\r\n- boy_filter_by_lua\r\n\r\n修改响应体\r\n\r\n- log_by_lua\r\n\r\n日志\r\n\r\n**获取Nginx请求头信息**\r\n\r\n```lua\r\nlocal headers = ngx.req.get_headers()                         \r\n\r\nngx.say(\"Host : \", headers[\"Host\"], \"<br/>\")  \r\n\r\nngx.say(\"user-agent : \", headers[\"user-agent\"], \"<br/>\")  \r\n\r\nngx.say(\"user-agent : \", headers.user_agent, \"<br/>\")\r\n\r\nfor k,v in pairs(headers) do  \r\n\r\n    if type(v) == \"table\" then  \r\n\r\n        ngx.say(k, \" : \", table.concat(v, \",\"), \"<br/>\")  \r\n\r\n    else  \r\n\r\n        ngx.say(k, \" : \", v, \"<br/>\")  \r\n\r\n    end  \r\n\r\nend  \r\n```\r\n\r\n**获取post请求参数**\r\n\r\n```lua\r\nngx.req.read_body()  \r\n\r\nngx.say(\"post args begin\", \"<br/>\")  \r\n\r\nlocal post_args = ngx.req.get_post_args()  \r\n\r\nfor k, v in pairs(post_args) do  \r\n\r\n    if type(v) == \"table\" then  \r\n\r\n        ngx.say(k, \" : \", table.concat(v, \", \"), \"<br/>\")  \r\n\r\n    else  \r\n\r\n        ngx.say(k, \": \", v, \"<br/>\")  \r\n\r\n    end  \r\nend\r\n```\r\n\r\n**http协议版本**\r\n\r\n```lua\r\nngx.say(\"ngx.req.http_version : \", ngx.req.http_version(), \"<br/>\")\r\n```\r\n\r\n**请求方法**\r\n\r\n```lua\r\nngx.say(\"ngx.req.get_method : \", ngx.req.get_method(), \"<br/>\")  \r\n```\r\n\r\n**原始的请求头内容**  \r\n\r\n```lua\r\nngx.say(\"ngx.req.raw_header : \",  ngx.req.raw_header(), \"<br/>\")  \r\n```\r\n\r\n**body内容体**  \r\n\r\n```lua\r\nngx.say(\"ngx.req.get_body_data() : \", ngx.req.get_body_data(), \"<br/>\")\r\n```\r\n\r\n \r\n\r\n### Nginx缓存\r\n\r\n#### Nginx全局内存缓存\r\n\r\nnginx配置：\r\n\r\n```nginx\r\nlua_shared_dict shared_data 1m;		#http中\r\n```\r\n\r\nlua文件代码：\r\n\r\n```lua\r\nlocal shared_data = ngx.shared.shared_data  \r\n\r\nlocal i = shared_data:get(\"i\")  \r\n\r\nif not i then  \r\n\r\n    i = 1  \r\n\r\n    shared_data:set(\"i\", i)  \r\n\r\n    ngx.say(\"lazy set i \", i, \"<br/>\")  \r\nend  \r\n \r\n\r\ni = shared_data:incr(\"i\", 1)  \r\n\r\nngx.say(\"i=\", i, \"<br/>\")\r\n```\r\n\r\n\r\n\r\n#### lua-resty-lrucache\r\n\r\nLua 实现的一个简单的 LRU 缓存，适合在 Lua 空间里直接缓存较为复杂的 Lua 数据结构：它相比 ngx_lua 共享内存字典可以省去较昂贵的序列化操作，相比 memcached 这样的外部服务又能省去较昂贵的 socket 操作\r\n\r\nhttps://github.com/openresty/lua-resty-lrucache\r\n\r\n\r\n\r\n新建文件cache.lua\r\n\r\n```shell\r\ncd /usr/local/openresty/lualib\r\nmkdir my\r\ncd my\r\nvim cache.lua	#内容写下面lua文件代码\r\n```\r\n\r\nlua文件代码：自定义函数\r\n\r\n```lua\r\nlocal _M = {}\r\n\r\nlrucache = require \"resty.lrucache\"\r\n\r\nc, err = lrucache.new(200)  -- allow up to 200 items in the cache\r\nngx.say(\"count=init\")\r\n\r\nif not c then\r\n    error(\"failed to create the cache: \" .. (err or \"unknown\"))\r\nend\r\n\r\nfunction _M.go()\r\n\r\ncount = c:get(\"count\")\r\n\r\nc:set(\"count\",100)\r\nngx.say(\"count=\", count, \" --<br/>\")\r\n\r\nif not count then  \r\n\r\n    c:set(\"count\",1)\r\n\r\n    ngx.say(\"lazy set count \", c:get(\"count\"), \"<br/>\")  \r\n\r\nelse\r\n\r\nc:set(\"count\",count+1)\r\n \r\nngx.say(\"count=\", count, \"<br/>\")\r\nend\r\n\r\nend\r\nreturn _M\r\n```\r\n\r\nnginx配置文件引用lua文件\r\n\r\n```nginx\r\n#注释掉http中的代码热部署，否则lua文件中每次都会new一个新对象\r\n#lua_code_cache off;\r\nlua_shared_dict shared_data 1m;\r\n\r\n\r\nlocation /lua {\r\n    ...\r\n    #content_by_lua_file lua/hello.lua;		#需注释，否则与lua_block冲突\r\n        \r\n    content_by_lua_block {\r\n    	require(\"my/cache\").go()\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### lua-resty-redis访问redis\r\n\r\n<font color=\'cornflowerblue\'>nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font>\r\n\r\nhttps://github.com/openresty/lua-resty-redis\r\n\r\n除了lua-resty-redis可以连接redis，也可以用前面讲的redis2-nginx-module\r\n\r\n**常用方法**\r\n\r\n```lua\r\nlocal res, err = red:get(\"key\")\r\n\r\nlocal res, err = red:lrange(\"nokey\", 0, 1)\r\n\r\nngx.say(\"res:\",cjson.encode(res))\r\n```\r\n\r\n**创建连接**\r\n\r\n```lua\r\nred, err = redis:new()\r\n\r\nok, err = red:connect(host, port, options_table?)\r\n```\r\n\r\n**timeout**\r\n\r\n```lua\r\nred:set_timeout(time)\r\n```\r\n\r\n**keepalive**\r\n\r\n```lua\r\nred:set_keepalive(max_idle_timeout, pool_size)\r\n```\r\n\r\n**close**\r\n\r\n```lua\r\nok, err = red:close()\r\n```\r\n\r\n**pipeline**\r\n\r\n```lua\r\nred:init_pipeline()\r\n\r\nresults, err = red:commit_pipeline()\r\n```\r\n\r\n**认证**\r\n\r\n```lua\r\n    local res, err = red:auth(\"foobared\")\r\n\r\n    if not res then\r\n\r\n        ngx.say(\"failed to authenticate: \", err)\r\n\r\n        return\r\n	end\r\n```\r\n\r\n**nginx配置**\r\n\r\n```\r\ncontent_by_lua_file lua/redis.lua\r\n```\r\n\r\n**redis.lua**\r\n\r\n```lua\r\n  				local redis = require \"resty.redis\"\r\n                local red = redis:new()\r\n\r\n                red:set_timeouts(1000, 1000, 1000) -- 1 sec\r\n\r\n  				local ok, err = red:connect(\"127.0.0.1\", 6379)\r\n 				if not ok then\r\n                    ngx.say(\"failed to connect: \", err)\r\n                    return\r\n                end\r\n\r\n				red:auth(\"123123\") 		--redis有密码需要输入密码，没密码删除此行\r\n\r\n				--业务代码，根据实际情况修改\r\n                ok, err = red:set(\"dog\", \"an animal\")\r\n                if not ok then\r\n                    ngx.say(\"failed to set dog: \", err)\r\n                    return\r\n                end\r\n\r\n                ngx.say(\"set result: \", ok)\r\n\r\n                local res, err = red:get(\"dog\")\r\n                if not res then\r\n                    ngx.say(\"failed to get dog: \", err)\r\n                    return\r\n                end\r\n\r\n                if res == ngx.null then\r\n                    ngx.say(\"dog not found.\")\r\n                    return\r\n                end\r\n\r\n\r\n                ngx.say(\"dog: \", res)\r\n```\r\n\r\n**redis-cluster支持**\r\n\r\nhttps://github.com/steve0511/resty-redis-cluster\r\n\r\n \r\n\r\n### redis2-nginx-module \r\n\r\nredis2-nginx-module是一个支持 Redis 2.0 协议的 Nginx upstream 模块，它可以让 Nginx 以非阻塞方式直接防问远方的 Redis 服务，同时支持 TCP 协议和 Unix Domain Socket 模式，并且可以启用强大的 Redis 连接池功能。\r\n\r\n**test**\r\n\r\n```nginx\r\nlocation = /foo {\r\n\r\ndefault_type text/html;\r\n\r\n     redis2_query auth 123123;\r\n\r\n     set $value \'first\';\r\n\r\n     redis2_query set one $value;\r\n\r\n     redis2_pass 192.168.199.161:6379;\r\n\r\n }\r\n```\r\n\r\n**get**\r\n\r\n```nginx\r\nlocation = /get {\r\n\r\ndefault_type text/html;\r\n\r\n     redis2_pass 192.168.199.161:6379;\r\n\r\n     redis2_query auth 123123;\r\n\r\n     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc\r\n\r\n     redis2_query get $key;\r\n\r\n}\r\n```\r\n\r\n**set**\r\n\r\n```nginx\r\n# GET /set?key=one&val=first%20value\r\n\r\nlocation = /set {\r\n\r\ndefault_type text/html;\r\n\r\nredis2_pass 192.168.199.161:6379;\r\n\r\nredis2_query auth 123123;\r\n \r\n\r\n     set_unescape_uri $key $arg_key;  # this requires ngx_set_misc\r\n\r\n     set_unescape_uri $val $arg_val;  # this requires ngx_set_misc\r\n\r\n     redis2_query set $key $val;\r\n\r\n }\r\n```\r\n\r\n**pipeline**\r\n\r\n```nginx\r\n     set $value \'first\';\r\n\r\n     redis2_query set one $value;\r\n\r\n     redis2_query get one;\r\n\r\n     redis2_query set one two;\r\n\r\n     redis2_query get one;\r\n\r\nredis2_query del key1;\r\n```\r\n\r\n**list**\r\n\r\n```lua\r\n    redis2_query lpush key1 C;\r\n\r\n    redis2_query lpush key1 B;\r\n\r\n    redis2_query lpush key1 A;\r\n\r\nredis2_query lrange key1 0 -1;\r\n```\r\n\r\n** **\r\n\r\n```nginx\r\nupstream redis_cluster {\r\n\r\n     server 192.168.199.161:6379;\r\n\r\n     server 192.168.199.161:6379;\r\n\r\n }\r\n\r\nlocation = /redis {\r\n\r\ndefault_type text/html;\r\n\r\n         redis2_next_upstream error timeout invalid_response;\r\n\r\n         redis2_query get foo;\r\n\r\n         redis2_pass redis_cluster;\r\n   }\r\n```\r\n\r\n\r\n\r\n### lua-resty-mysql\r\n\r\n<font color=\'cornflowerblue\'>nginx连接redis或者mysql用于直接从nginx获取redis、mysql中的数据，简化从tomcat让tomcat连接数据库再传值回来，数据库中的值的写入由tomcat完成，nginx只需要读取就好</font>\r\n\r\n https://github.com/openresty/lua-resty-mysql\r\n\r\n ```lua\r\n 				local mysql = require \"resty.mysql\"\r\n                 local db, err = mysql:new()\r\n                 if not db then\r\n                     ngx.say(\"failed to instantiate mysql: \", err)\r\n                     return\r\n                 end\r\n \r\n                 db:set_timeout(1000) -- 1 sec\r\n \r\n \r\n 				--自己的mysql信息\r\n                 local ok, err, errcode, sqlstate = db:connect{\r\n                     host = \"192.168.111.100\",\r\n                     port = 3306,\r\n                     database = \"zhangmen\",\r\n                     user = \"root\",\r\n                     password = \"123456\",\r\n                     charset = \"utf8\",\r\n                     max_packet_size = 1024 * 1024,\r\n                 }\r\n \r\n \r\n                 ngx.say(\"connected to mysql.<br>\")\r\n \r\n \r\n 				--业务代码，根据实际情况修改\r\n                 local res, err, errcode, sqlstate = db:query(\"drop table if exists cats\")\r\n                 if not res then\r\n                     ngx.say(\"bad result: \", err, \": \", errcode, \": \", sqlstate, \".\")\r\n                     return\r\n                 end\r\n \r\n \r\n                 res, err, errcode, sqlstate =\r\n                     db:query(\"create table cats \"\r\n                              .. \"(id serial primary key, \"\r\n                              .. \"name varchar(5))\")\r\n                 if not res then\r\n                     ngx.say(\"bad result: \", err, \": \", errcode, \": \", sqlstate, \".\")\r\n                     return\r\n                 end\r\n \r\n                 ngx.say(\"table cats created.<br>\")\r\n \r\n \r\n \r\n                 res, err, errcode, sqlstate =\r\n                     db:query(\"select * from t_emp\")\r\n                 if not res then\r\n                     ngx.say(\"bad result: \", err, \": \", errcode, \": \", sqlstate, \".\")\r\n                     return\r\n                 end\r\n \r\n                 local cjson = require \"cjson\"\r\n                 ngx.say(\"result: \", cjson.encode(res))\r\n \r\n \r\n                 local ok, err = db:set_keepalive(10000, 100)\r\n                 if not ok then\r\n                     ngx.say(\"failed to set keepalive: \", err)\r\n                     return\r\n                 end\r\n ```\r\n\r\n\r\n\r\n## 模板实时渲染 lua-resty-template\r\n\r\nhttps://github.com/bungle/lua-resty-template\r\n\r\n如果学习过JavaEE中的servlet和JSP的话，应该知道JSP模板最终会被翻译成Servlet来执行；\r\n\r\n而lua-resty-template模板引擎可以认为是JSP，其最终会被翻译成Lua代码，然后通过ngx.print输出。   \r\n\r\nlua-resty-template大体内容有： \r\n\r\nl   模板位置：从哪里查找模板； \r\n\r\nl   变量输出/转义：变量值输出； \r\n\r\nl   代码片段：执行代码片段，完成如if/else、for等复杂逻辑，调用对象函数/方法； \r\n\r\nl   注释：解释代码片段含义； \r\n\r\nl   include：包含另一个模板片段； \r\n\r\nl   其他：lua-resty-template还提供了不需要解析片段、简单布局、可复用的代码块、宏指令等支持。\r\n\r\n基础语法\r\n\r\nl   {(include_file)}：包含另一个模板文件；\r\n\r\nl   {* var *}：变量输出；\r\n\r\nl   {{ var }}：变量转义输出；\r\n\r\nl   {% code %}：代码片段；\r\n\r\nl   {# comment #}：注释；\r\n\r\nl   {-raw-}：中间的内容不会解析，作为纯文本输出；\r\n\r\n\r\n\r\n\r\n\r\n### 准备和简单测试\r\n\r\n**解压移动模板引擎到openresty/resty目录下**\r\n\r\n```shell\r\ncd /usr/local/openresty/lualib\r\n\r\n上传下载好的 lua-resty-template-2.0.tar.gz\r\ntar -zxvf lua-resty-template-2.0.tar.gz\r\ncd lua-resty-template-2.0/lib/resty\r\nmv template/ template.lua /usr/local/openresty/lualib/resty\r\n```\r\n\r\n**写模板**\r\n\r\n```shell\r\ncd /usr/local/openresty\r\nmkdir tpl\r\ncd tpl\r\nvim view.html	#新建模板\r\n```\r\n\r\nview.html内容：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n  <h1>{{message}}</h1>\r\n</body>\r\n</html>\r\n```\r\n\r\n**nginx.conf中配置**\r\n\r\nlua代码热加载\r\n\r\n在http模块中加入\r\n\r\n```\r\nlua_code_cache off;\r\n```\r\n\r\nreload后Nginx会提示影响性能，记得在生产环境中关掉。\r\n\r\n配置模板文件存放位置\r\n\r\n```nginx\r\nlocation /lua {\r\n	...\r\n	set $template_root /usr/local/openresty/tpl;\r\n    content_by_lua_file lua/tpl.lua;\r\n}\r\n```\r\n\r\n**写lua文件**\r\n\r\n```shell\r\ncd /usr/local/openresty/nginx/lua\r\nvim tpl.lua\r\n```\r\n\r\ntpl.lua内容：\r\n\r\n```lua\r\n-- Using template.new\r\nlocal template = require \"resty.template\"\r\nlocal view = template.new \"view.html\"	--读取前面写的模板view.html\r\nview.message = \"Hello, World!\"\r\nview:render()\r\n\r\n-- Using template.render\r\n-- template.render(\"view.html\", { message = \"Hel11lo, Worl1d!\" })\r\n```\r\n\r\n**重启openresty nginx**\r\n\r\n```\r\ncd /usr/local/openresty/nginx/sbin/\r\n./nginx -s stop\r\n./nginx -c /usr/local/openresty/nginx/conf/nginx.conf\r\n```\r\n\r\n\r\n\r\n### 其他测试配置\r\n\r\n**一、初始化**\r\n\r\n```\r\n-- Using template.new\r\nlocal template = require \"resty.template\"\r\nlocal view = template.new \"view.html\"\r\nview.message = \"Hello, World!\"\r\nview:render()\r\n\r\n-- Using template.render\r\n-- template.render(\"view.html\", { message = \"Hel11lo, Worl1d!\" })\r\n```\r\n\r\n**二、执行函数，得到渲染之后的内容**\r\n\r\n```\r\nlocal func = template.compile(\"view.html\")  \r\n\r\nlocal content = func(context)  \r\n\r\nngx.say(\"xx:\",content) \r\n```\r\n\r\n\r\n\r\n**resty.template.html**\r\n\r\n```lua\r\nlocal template = require(\"resty.template\")\r\nlocal html = require \"resty.template.html\"\r\n\r\ntemplate.render([[\r\n<ul>\r\n{% for _, person in ipairs(context) do %}\r\n    {*html.li(person.name)*} --\r\n{% end %}\r\n</ul>\r\n<table>\r\n{% for _, person in ipairs(context) do %}\r\n    <tr data-sort=\"{{(person.name or \"\"):lower()}}\">\r\n        {*html.td{ id = person.id }(person.name)*}\r\n    </tr>\r\n{% end %}\r\n</table>]], {\r\n    { id = 1, name = \"Emma\"},\r\n    { id = 2, name = \"James\" },\r\n    { id = 3, name = \"Nicholas\" },\r\n    { id = 4 }\r\n})\r\n\r\n```\r\n\r\n**模板内容**\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n  <h1>{{message}}</h1>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n**多值传入**\r\n\r\n```lua\r\ntemplate.caching(false)\r\nlocal template = require(\"resty.template\")\r\nlocal context = {\r\n    name = \"lucy\",\r\n    age = 50,\r\n}\r\ntemplate.render(\"view.html\", context)\r\n\r\n```\r\n\r\n**模板内容**\r\n\r\n```lua\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n  <h1>name:{{name}}</h1>\r\n  <h1>age:{{age}}</h1>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n**模板管理与缓存**\r\n\r\n模板缓存：默认开启，开发环境可以手动关闭\r\n\r\n```template.caching(true)```\r\n\r\n模板文件需要业务系统更新与维护，当模板文件更新后，可以通过模板版本号或消息通知Openresty清空缓存重载模板到内存中\r\n\r\n`template.cache = {}`\r\n\r\n\r\n\r\n### 完整配置示例\r\n\r\n**完整页面**\r\n\r\n```lua\r\nlocal template = require(\"resty.template\")\r\ntemplate.caching(false)\r\nlocal context = {\r\n    title = \"测试\",\r\n    name = \"lucy\",\r\n    description = \"<script>alert(1);</script>\",\r\n    age = 40,\r\n    hobby = {\"电影\", \"音乐\", \"阅读\"},\r\n    score = {语文 = 90, 数学 = 80, 英语 = 70},\r\n    score2 = {\r\n        {name = \"语文\", score = 90},\r\n        {name = \"数学\", score = 80},\r\n        {name = \"英语\", score = 70},\r\n    }\r\n}\r\n\r\ntemplate.render(\"view.html\", context)\r\n\r\n```\r\n\r\n**模板**\r\n\r\n```html\r\n{(header.html)}  	<!--引入页面，自己随便写一个，再view.html同目录-->\r\n   <body>  \r\n      {# 不转义变量输出 #}  \r\n      姓名：{* string.upper(name) *}<br/>  \r\n      {# 转义变量输出 #}  \r\n      简介：{{description}}\r\n           简介：{* description *}<br/>  \r\n      {# 可以做一些运算 #}  \r\n      年龄: {* age + 10 *}<br/>  \r\n      {# 循环输出 #}  \r\n      爱好：  \r\n      {% for i, v in ipairs(hobby) do %}  \r\n         {% if v == \'电影\' then  %} - xxoo\r\n            \r\n              {%else%}  - {* v *} \r\n{% end %}  \r\n         \r\n      {% end %}<br/>  \r\n  \r\n      成绩：  \r\n      {% local i = 1; %}  \r\n      {% for k, v in pairs(score) do %}  \r\n         {% if i > 1 then %}，{% end %}  \r\n         {* k *} = {* v *}  \r\n         {% i = i + 1 %}  \r\n      {% end %}<br/>  \r\n      成绩2：  \r\n      {% for i = 1, #score2 do local t = score2[i] %}  \r\n         {% if i > 1 then %}，{% end %}  \r\n          {* t.name *} = {* t.score *}  \r\n      {% end %}<br/>  \r\n      {# 中间内容不解析 #}  \r\n      {-raw-}{(file)}{-raw-}  \r\n{(footer.html)}  <!--引入页面，自己随便写一个，再view.html同目录-->\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### layout 布局统一风格\r\n\r\n使用模板内容嵌套可以实现全站风格同一布局\r\n\r\n**lua**\r\n\r\n`local template = require \"resty.template\"`\r\n\r\n一、\r\n\r\n```\r\nlocal layout   = template.new \"layout.html\"\r\n\r\nlayout.title   = \"Testing lua-resty-template\"\r\n\r\nlayout.view    = template.compile \"view.html\" { message = \"Hello, World!\" }\r\n\r\nlayout:render()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n二、\r\n\r\n```\r\ntemplate.render(\"layout.html\", {\r\n\r\n  title = \"Testing lua-resty-template\",\r\n\r\n  msg = \"type=2\",\r\n\r\n  view  = template.compile \"view.html\" { message = \"Hello, World!\" }\r\n\r\n})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n三、\r\n\r\n此方式重名变量值会被覆盖\r\n\r\n```\r\nlocal view     = template.new(\"view.html\", \"layout.html\")\r\n\r\nview.title     = \"Testing lua-resty-template\"\r\n\r\nview.msg = \"type=3\"\r\n\r\nview.message   = \"Hello, World!\"\r\n\r\nview:render()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n四、\r\n\r\n可以区分一下\r\n\r\n```\r\nlocal layout   = template.new \"layout.html\"\r\n\r\nlayout.title   = \"Testing lua-resty-template\"\r\n\r\nlayout.msg = \"type=4\"\r\n\r\nlocal view     = template.new(\"view.html\", layout)\r\n\r\nview.message   = \"Hello, World!\"\r\n\r\nview:render()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n**layout.html**\r\n\r\n```\r\n<!DOCTYPE html>\r\n\r\n<html>\r\n\r\n<head>\r\n\r\n​    <title>{{title}}</title>\r\n\r\n</head>\r\n\r\n<h1>layout</h1>\r\n\r\n<body>\r\n\r\n​    {*view*}\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**view.html·**\r\n\r\n`msg:{{message}}`\r\n\r\n \r\n\r\n**多级嵌套**\r\n\r\nlua\r\n\r\n```\r\nlocal view     = template.new(\"view.html\", \"layout.html\")\r\n\r\nview.title     = \"Testing lua-resty-template\"\r\n\r\nview.message   = \"Hello, World!\"\r\n\r\nview:render()\r\n\r\nview.html\r\n\r\n{% layout=\"section.html\" %}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n<h1>msg:{{message}}</h1>\r\n\r\nsection.html\r\n\r\n<div\r\nid=\"section\">\r\n\r\n\r\n​    {*view*} - sss\r\n\r\n</div>\r\n\r\nlayout.html\r\n\r\n<!DOCTYPE html>\r\n\r\n\r\n<html>\r\n\r\n<head>\r\n\r\n\r\n​    <title>{{title}}</title>\r\n\r\n</head>\r\n\r\n<h1>layout {{msg}}</h1>\r\n\r\n<body>\r\n\r\n​    {*view*}\r\n\r\n</body>\r\n\r\n</html>\r\n\r\n\r\n\r\n\r\n\r\n### Redis缓存+mysql+模板输出\r\n\r\nlua\r\n\r\n```\r\n  cjson = require \"cjson\"\r\nsql=\"select * from t_emp\"\r\n\r\n\r\nlocal redis = require \"resty.redis\"\r\n                local red = redis:new()\r\n\r\n                red:set_timeouts(1000, 1000, 1000) -- 1 sec\r\n\r\n  local ok, err = red:connect(\"127.0.0.1\", 6379)\r\n if not ok then\r\n                    ngx.say(\"failed to connect: \", err)\r\n                    return\r\n                end\r\n\r\n\r\n        \r\n                local res, err = red:get(sql)\r\n                if not res then\r\n                    ngx.say(\"failed to get sql: \", err)\r\n                    return\r\n                end\r\n\r\n                if res == ngx.null then\r\n                    ngx.say(\"sql\"..sql..\" not found.\")\r\n\r\n\r\n\r\n\r\n--mysql查询\r\nlocal mysql = require \"resty.mysql\"\r\n                local db, err = mysql:new()\r\n                if not db then\r\n                    ngx.say(\"failed to instantiate mysql: \", err)\r\n                    return\r\n                end\r\n\r\n                db:set_timeout(1000) -- 1 sec\r\n\r\n\r\n                local ok, err, errcode, sqlstate = db:connect{\r\n                    host = \"192.168.44.211\",\r\n                    port = 3306,\r\n                    database = \"zhangmen\",\r\n                    user = \"root\",\r\n                    password = \"111111\",\r\n                    charset = \"utf8\",\r\n                    max_packet_size = 1024 * 1024,\r\n                }\r\n\r\n\r\n                ngx.say(\"connected to mysql.<br>\")\r\n\r\n\r\n res, err, errcode, sqlstate =\r\n                    db:query(sql)\r\n                if not res then\r\n                    ngx.say(\"bad result: \", err, \": \", errcode, \": \", sqlstate, \".\")\r\n                    return\r\n                end\r\n\r\n\r\n          --ngx.say(\"result: \", cjson.encode(res))\r\n\r\n\r\n\r\n      ok, err = red:set(sql, cjson.encode(res))\r\n                if not ok then\r\n                    ngx.say(\"failed to set sql: \", err)\r\n                    return\r\n                end\r\n\r\n                ngx.say(\"set result: \", ok)\r\n\r\n                    return\r\n                end\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlocal template = require(\"resty.template\")\r\ntemplate.caching(false)\r\nlocal context = {\r\n    title = \"测试\",\r\n    name = \"lucy\",\r\n    description = \"<script>alert(1);</script>\",\r\n    age = 40,\r\n    hobby = {\"电影\", \"音乐\", \"阅读\"},\r\n    score = {语文 = 90, 数学 = 80, 英语 = 70},\r\n    score2 = {\r\n        {name = \"语文\", score = 90},\r\n        {name = \"数学\", score = 80},\r\n        {name = \"英语\", score = 70},\r\n    },\r\n\r\nzhangmen=cjson.decode(res)\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ntemplate.render(\"view.html\", context)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n模板\r\n\r\n```\r\n\r\n{(header.html)}  \r\n   <body>  \r\n      {# 不转义变量输出 #}  \r\n      姓名：{* string.upper(name) *}<br/>  \r\n      {# 转义变量输出 #}  \r\n\r\n      年龄: {* age + 10 *}<br/>  \r\n      {# 循环输出 #}  \r\n      爱好：  \r\n      {% for i, v in ipairs(hobby) do %}  \r\n         {% if v == \'电影\' then  %} - xxoo\r\n            \r\n              {%else%}  - {* v *} \r\n{% end %}  \r\n         \r\n      {% end %}<br/>  \r\n  \r\n      成绩：  \r\n      {% local i = 1; %}  \r\n      {% for k, v in pairs(score) do %}  \r\n         {% if i > 1 then %}，{% end %}  \r\n         {* k *} = {* v *}  \r\n         {% i = i + 1 %}  \r\n      {% end %}<br/>  \r\n      成绩2：  \r\n      {% for i = 1, #score2 do local t = score2[i] %}  \r\n         {% if i > 1 then %}，{% end %}  \r\n          {* t.name *} = {* t.score *}  \r\n      {% end %}<br/>  \r\n      {# 中间内容不解析 #}  \r\n      {-raw-}{(file)}{-raw-}  \r\n\r\n\r\n\r\n\r\n掌门：\r\n{* zhangmen *}\r\n\r\n\r\n\r\n   {% for i = 1, #zhangmen do local z = zhangmen[i] %}  \r\n         {* z.deptId *},{* z.age *},{* z.name *},{* z.empno *},<br>\r\n      {% end %}<br/>  \r\n\r\n{(footer.html)}  \r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Lua 开源项目\r\n\r\n### WAF\r\n\r\nhttps://github.com/unixhot/waf\r\n\r\nhttps://github.com/loveshell/ngx_lua_waf\r\n\r\n \r\n\r\nl   防止 SQL 注入，本地包含，部分溢出，fuzzing 测试，XSS/SSRF 等 Web 攻击\r\n\r\nl   防止 Apache Bench 之类压力测试工具的攻击\r\n\r\nl   屏蔽常见的扫描黑客工具，扫描器\r\n\r\nl   屏蔽图片附件类目录执行权限、防止 webshell 上传\r\n\r\nl   支持 IP 白名单和黑名单功能，直接将黑名单的 IP 访问拒绝\r\n\r\nl   支持 URL 白名单，将不需要过滤的 URL 进行定义\r\n\r\nl   支持 User-Agent 的过滤、支持 CC 攻击防护、限制单个 URL 指定时间的访问次数\r\n\r\nl   支持支持 Cookie 过滤，URL 与 URL 参数过滤\r\n\r\nl   支持日志记录，将所有拒绝的操作，记录到日志中去\r\n\r\n### Kong 基于Openresty的流量网关\r\n\r\nhttps://konghq.com/\r\n\r\nhttps://github.com/kong/kong\r\n\r\nKong 基于 OpenResty，是一个云原生、快速、可扩展、分布式的微服务抽象层（Microservice Abstraction Layer），也叫 API 网关（API Gateway），在 Service Mesh 里也叫 API 中间件（API Middleware）。\r\n\r\nKong 开源于 2015 年，核心价值在于高性能和扩展性。从全球 5000 强的组织统计数据来看，Kong 是现在依然在维护的，在生产环境使用最广泛的 API 网关。\r\n\r\nKong 宣称自己是世界上最流行的开源微服务 API 网关（The World’s Most Popular Open Source Microservice API Gateway）。\r\n\r\n核心优势：\r\n\r\nl   可扩展：可以方便的通过添加节点水平扩展，这意味着可以在很低的延迟下支持很大的系统负载。\r\n\r\nl   模块化：可以通过添加新的插件来扩展 Kong 的能力，这些插件可以通过 RESTful Admin API 来安装和配置。\r\n\r\nl   在任何基础架构上运行：Kong 可以在任何地方都能运行，比如在云或混合环境中部署 Kong，单个或全球的数据中心。\r\n\r\n###  APISIX\r\n\r\n### ABTestingGateway\r\n\r\nhttps://github.com/CNSRE/ABTestingGateway\r\n\r\nABTestingGateway 是一个可以动态设置分流策略的网关，关注与灰度发布相关领域，基于 Nginx 和 ngx-lua 开发，使用 Redis 作为分流策略数据库，可以实现动态调度功能。\r\n\r\nABTestingGateway 是新浪微博内部的动态路由系统 dygateway 的一部分，目前已经开源。在以往的基于 Nginx 实现的灰度系统中，分流逻辑往往通过 rewrite 阶段的 if 和 rewrite 指令等实现，优点是性能较高，缺点是功能受限、容易出错，以及转发规则固定，只能静态分流。ABTestingGateway 则采用 ngx-lua，通过启用 lua-shared-dict 和 lua-resty-lock 作为系统缓存和缓存锁，系统获得了较为接近原生 Nginx 转发的性能。\r\n\r\nl   支持多种分流方式，目前包括 iprange、uidrange、uid 尾数和指定uid分流\r\n\r\nl   支持多级分流，动态设置分流策略，即时生效，无需重启\r\n\r\nl   可扩展性，提供了开发框架，开发者可以灵活添加新的分流方式，实现二次开发\r\n\r\nl   高性能，压测数据接近原生 Nginx 转发\r\n\r\nl   灰度系统配置写在 Nginx 配置文件中，方便管理员配置\r\n\r\nl   适用于多种场景：灰度发布、AB 测试和负载均衡等\r\n','http://47.115.207.49/shareX/20230627/image-20230627004745027-shareX-20230627004750.png','原创',19,_binary '',_binary '',_binary '\0','2023-07-02 22:53:43',NULL,2022576839,'尚硅谷Nginx2022教程全程跟做笔记',NULL,NULL,'0'),(1675526800714776577,'博客告示','- 服务器太la，文件加载较慢，请见谅\r\n- 部分笔记图片较多，可前往github或gitee拉取md/pdf/word文档\r\n- github、gitee关于我界面有，首页右侧栏也有github\r\n- 部分笔记同步至CSDN\r\n- 若有问题请留言或加我v\r\n- 引用文章请注明出处\r\n- 由于阿里云禁用邮件端口原因，经修改后仍然无效，线上评论无法通过邮件提醒，localhost可以，现还在寻找有效解决办法中(已解决)\r\n- 推荐阅读方式：找到对应的分类栏目，按时间顺序从前往后读，因为上传时可能多个分类混合上传，导致同分类博客不连续\r\n\r\n\r\n------------\r\n\r\n\r\n------------\r\n\r\n\r\n- 2023.7.10增减显示编辑时间，修复邮件发送问题\r\n\r\n','/img/idea.png','原创',30,_binary '',_binary '',_binary '','2023-07-02 23:28:13','2023-07-22 22:16:28',2022576839,'在这里留下我想说的和你想说的[笔芯]',NULL,NULL,'0'),(1678452615425323010,'JVM-类的加载过程','[TOC]\r\n\r\n\r\n\r\n# 类的加载过程\r\n\r\n\r\n\r\n![image-20230709125627229](image/JVMClassLoading.assets/image-20230709125627229.png)\r\n\r\n\r\n\r\n我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中\r\n\r\n- 加载（Loading）：查找编译后该类对应的 .class文件，并对常量进行默认初始化赋值0\r\n- 链接（Linking）：\r\n  - 验证（Verify）：验证class文件是否符合当前虚拟机的要求\r\n  - 准备（Prepare）：为类变量分配内存并设置默认初始值0，并为常量进行显式赋值\r\n  - 解析（Resolve）：将常量池内的符号引用转换为直接引用的过程\r\n\r\n- 初始化（Initialization）：执行类构造器 clinit()方法的过程，对类变量初始化赋值\r\n\r\n\r\n\r\n## 加载（Loading）\r\n\r\n\r\n\r\n### 加载的理解\r\n\r\n<font color=\'red\'>查找编译后该类对应的 .class文件，并对常量进行默认初始化赋值0</font>\r\n\r\n<font color=\'red\'>所谓加载，简而言之就是将)ava类的字节码文件加载到机器内存中，并在内存中构建出]ava类的原型一一类模板对象。</font>所谓类模板对象，其实就是]va类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取]ava类中的任意信息，能够对]ava类的成员变量进行遍历，也能进行Java方法的调用。\r\n\r\n反射的机制即基于这一基础。如果JVM没有将]aVa类的声明信息存储起来，则JVM在运行期也无法反射。\r\n\r\n\r\n\r\n### 加载完成的操作\r\n\r\n<font color=\'red\'>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</font>\r\n\r\n在加载类时，)ava虚拟机必须完成以下3件事情：\r\n\r\n- 通过类的全名，获取类的二进制数据流。\r\n- 解析类的二进制数据流为方法区内的数据结构(Java类模型)\r\n- 创建java.lang.c1ass类的实例，表示该类型。作为方法区这个类的各种数据的访问入口\r\n\r\n\r\n\r\n### 类的加载器\r\n\r\n- 引导类/启动类 加载器Bootstrap ClassLoader：用c/c++编写，不继承于Classloader类，用于加载Java核心类库等，若要输出该类的对象，将会输出NULL\r\n- 扩展类加载器Extension ClassLoader：用Java编写，继承于Classloader类\r\n- 系统类加载器Application ClassLoader：用Java编写，继承于Classloader类，是默认的类加载器\r\n- 特殊的：自定义类加载器自己重写findClass()方法的加载器\r\n\r\n<font color=\'cornflowerblue\'>扩展类加载器、系统类加载器也叫自定义类加载器，都继承于ClassLoader类</font>\r\n\r\n\r\n\r\n### 获取ClassLoader类对象的途径\r\n\r\n方式一：获取当前类的ClassLoader\r\nclazz.getClassLoader()\r\n方式二：获取当前线程上下文的ClassLoader\r\nThread.currentThread().getContextClassLoader()\r\n方式三：获取系统的ClassLoader\r\nClassLoader.getsystemClassLoader()\r\n方式四：获取调用者的ClassLoader\r\nDriverManager.getCallerClassLoader()\r\n\r\n\r\n\r\n## 链接（Linking）\r\n\r\n\r\n\r\n### 验证（Verification）\r\n\r\n验证class文件是否符合当前虚拟机的要求\r\n\r\n<font color=\'red\'>它的目的是保证加载的字节码是合法、合理并符合规范的。</font>\r\n\r\n1. 进行格式验证\r\n   - 魔数检查\r\n   - 版本检查\r\n   - 长度检查\r\n2. 语义检查\r\n   - 是否继承final\r\n   - 是否有父类\r\n   - 抽象方法是否有实现\r\n3. 字节码验证\r\n   - 跳转指令是否指向正确位置\r\n   - 操作数类型是否合理、\r\n4. 符号引用验证\r\n   - 符号引用的直接引用是否存在\r\n\r\n<font color=\'red\'>其中格式验证会和加载阶段一起执行。</font>验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。\r\n\r\n<font color=\'red\'>格式验证之外的验证操作将会在方法区中进行。</font>\r\n\r\n\r\n\r\n具体说明：\r\n1.**格式验证**：是否以魔数OxCAFEBABE开头，主版本和副版本号是否在当前]ava虚拟机的支持范围内，数据中每一个项是否都\r\n拥有正确的长度等。\r\n\r\n2.Java虚拟机会进行字节码的**语义检查**，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：\r\n\r\n- 是否所有的类都有父类的存在（在Java里，除了Object外，其他类都应该有父类）\r\n- 是否一些被定义为final的方法或者类被重写或继承了\r\n- 非抽象类是否实现了所有抽象方法或者接口方法\r\n- 是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract情况\r\n  下的方法，就不能是final的了)\r\n\r\n3.]av虚拟机还会进行**字节码验证**，字节码验证也是<font color=\'cornflowerblue\'>验证过程中最为复杂的一个过程</font>。它试图通过对字节码流的分析，判断字节\r\n码是否可以被正确地执行。比如：\r\n\r\n- 在字节码的执行过程中，是否会跳转到一条不存在的指令\r\n- 函数的调用是否传递了正确类型的参数\r\n- 变量的赋值是不是给了正确的数据类型等\r\n\r\n栈映射帧(StackMapTable)就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。\r\n但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显\r\n的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是\r\n完全没有问题的。\r\n\r\n<font color=\'red\'>在前面3次检查中，已经排除子文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</font>\r\n\r\n4.校验器还将进行**符号引用的验证**。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<font color=\'red\'>虚拟机就会检查这些类或者方法确实是存在的</font>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError,如果一个方法无法被找到，则会抛出NoSuchMethodError。\r\n\r\n此阶段在解析环节才会执行。\r\n\r\n\r\n\r\n### 准备（Preparation）\r\n\r\n<font color=\'red\'>为类变量分配内存并设置默认初始值0，并为常量进行显式赋值</font>\r\n\r\n\r\n\r\n准备阶段(Preparation),简言之，为<font color=\'red\'>类的静态变量分配内存，并将其初始化为默认值。</font>\r\n\r\n当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。\r\n\r\nJava虚拟机为各类型变量默认的初始值如表所示：\r\n\r\n| 类型      | 默认初始值 |\r\n| --------- | ---------- |\r\n| byte      | 0          |\r\n| short     | 0          |\r\n| int       | 0          |\r\n| long      | 0L         |\r\n| float     | 0.0f       |\r\n| double    | 0.0        |\r\n| char      | \\u0000     |\r\n| boolean   | 0(false)   |\r\n| reference | null       |\r\n\r\n注意：Java并不支持boolean:类型，对于boolean类型，内部实现是int,由于int的默认值是g,故对应的，boolean的默认值就是false\r\n\r\n\r\n\r\n注意：\r\n\r\n1.<font color=\'red\'>这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配并初始化赋值，准备阶段会显式赋值</font>，具体在初始化部分详解\r\n\r\n2.注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到门Va堆中。\r\n\r\n3.在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。\r\n\r\n\r\n\r\n### 解析（Resolution）\r\n\r\n<font color=\'red\'>将常量池内的符号引用转换为直接引用的过程</font>\r\n\r\n\r\n\r\n<font color=\'red\'>解析阶段(Resolution),简言之，将类、接口、字段和方法的符号引用转为直接引用。</font>\r\n\r\n1.具体描述：\r\n\r\n符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在C1ass类文件中\r\n,通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下print1n()方法被\r\n调用时，系统需要明确知道该方法的位置。\r\n\r\n\r\n\r\n举例：输出操作System.out.println()对应的字节码：\r\n\r\ninvokevirtual #24 <java/io/PrintStream.println>\r\n\r\n\r\n\r\n<font color=\'red\'>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</font>\r\n\r\n\r\n\r\n## 初始化（Initialization）\r\n\r\n<font color=\'red\'>执行类构造器< clinit>()方法的过程，对类的静态变量初始化赋值</font>\r\n\r\n### 具体描述\r\n\r\n类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。（即：<font color=\'cornflowerblue\'>到了初始化阶段，才真正开始执行类中定义的Java程序代码</font>。）\r\n\r\n<font color=\'red\'>切始化阶段的重要工作是执行类的初始化方法：< clinit>()方法。</font>\r\n\r\n- 该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在]ava程序中调用该方法，虽然该方法也是由字节码指令所组成。\r\n- 它是由类静态成员的赋值语句以及static语句块合并产生的\r\n\r\n\r\n\r\n**说明**\r\n\r\n1. 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的< clinit>总是在子类< clinit>之前被调用。也就是说，父类的static块优先级高于子类。\r\n\r\n2. Java编译器并不会为所有的类都产生< clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含< c1init>()方法？\r\n\r\n   - 一个类中并没有声明任何的类变量，也没有静态代码块时\r\n\r\n   - 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时\r\n\r\n   - 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式\r\n\r\n3. **< clinit>()是带锁线程安全的**\r\n\r\n   - 锁是隐式的，若两个类交叉相互调用，有可能造成死锁\r\n\r\n\r\n\r\n\r\n\r\n### 哪些不会生成< clinit>()方法\r\n\r\n![image-20230709134249348](image/JVMClassLoading.assets/image-20230709134249348.png)\r\n\r\n\r\n\r\n### static+final修饰显式赋值\r\n\r\n使用static+final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？\r\n\r\n- 情况1：在链接阶段的准备环节赋值\r\n- 情况2：在初始化阶段<clinit>()中赋值\r\n\r\n\r\n\r\n**结论：**\r\n\r\n**在链接阶段的准备环节赋值的情况：**\r\n\r\n1. 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行\r\n2. 对于string来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行\r\n\r\n\r\n\r\n**在初始化阶段< clinit>()中赋值的情况：**\r\n\r\n排除上述的在准备环节赋值的情况之外的情况。\r\n\r\n最终结论：\r\n\r\n- <font color=\'red\'>使用static+final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或tring类型的显式赋值，是在链接阶段的准备环节进行。</font>\r\n  - <font color=\'red\'>即静态常量（基本数据类型（不包括封装类）、String类型字面量（\"XXX\"这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</font>\r\n- <font color=\'red\'>引用数据类型的静态常量，尤其是new String(\"XXX\")这种形式，都是在初始化中的< client>()中进行显示赋值的</font>\r\n\r\n\r\n\r\n示例：\r\n\r\n```java\r\npublic class InitializationTest {\r\n    public static int a = 1;//在初始化阶段<clinit>()中赋值\r\n    public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值\r\n    \r\n    public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段<clinit>()中赋值\r\n    public final Integer INTEGER_CONSTANT2 = Integer.valueOf(100);//在初始化阶段<clinit>()中赋值\r\n    \r\n    public static final String s0 = \"helloworld0\";//在链接阶段的准备环节赋值\r\n    public static final String s1 = new String(\"helloworld1\");//在初始化阶段<clinit>()中赋值\r\n}\r\n```\r\n\r\n\r\n\r\n## 使用（Using）\r\n\r\n\r\n\r\n**检查类的初始化情况**：主动使用vs被动使用（这里并不算真正的类的使用，只是分情况讨论哪些情况才会导致< clinit>()的执行）\r\n\r\n调试期间可以添加参数	`-XX:+TraceClassLoading`来打印**类的加载**(Loading)情况\r\n\r\n### 主动使用\r\n\r\nClass只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备己经完成。)\r\n\r\n<font color=\'cornflowerblue\'>主动使用即会造成类的初始化（Initialization）</font>\r\n\r\n1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\r\n2. 当调用类的静态方法时，即当使用了字节码invokestatic指令。\r\n3. 当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作)\r\n4. 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\"com.atguigu.java.Test\")\r\n5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\r\n   - 其实现的接口一般情况下不会被初始化\r\n6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。\r\n7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\r\n8. 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getstatic、REF_putstatic、REF_invokeStatic方法句柄对应的类)\r\n\r\n<font color=\'red\'>只有类的主动使用，才会进行类的初始化，执行< clinit>()方法进行初始化赋值</font>\r\n\r\n\r\n\r\n### 被动使用\r\n\r\n除了以上八种情况，其他使用Java类的方式都被看作是对<font color=\'red\'>类的被动使用，都不会导致类的初始化</font>（<font color=\'cornflowerblue\'>即类的加载过程中的Initialization</font>）\r\n\r\n关于类的被动使用，即不会进行类的初始化操作，即不会调用clinit.>()\r\n\r\n1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。\r\n   - 当通过子类引用父类的静态变量，不会导致子类初始化\r\n2. 通过数组定义类引用，不会触发此类的初始化\r\n3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。\r\n4. 调用ClassLoader类的了loadcLass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\r\n   - ClassLoader.getSystemClassLoader().loadClass(\"com.spongehah.java.Person\")，该种反射加载类的方式并不会造成类的初始化\r\n\r\n\r\n\r\n### 类的使用\r\n\r\n任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。\r\n\r\n开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用ew关键字为其创建对象实例。\r\n\r\n\r\n\r\n## 卸载（Unloading）\r\n\r\n\r\n\r\n### 一、类、类的加载器、类的实例之间的引用关系\r\n\r\n在类加载器的内部实现中，用一个]ava集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器,调用Class对象的getclassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。\r\n\r\n一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的]ava类都有一个静态属性Class,它引用代表这个类的Class对象。\r\n\r\n\r\n\r\n### 二、类的生命周期\r\n\r\n**当Sample类被加载、链接和初始化后**，它的生命周期就开始了。**当代表Sample类的Class对象不再被引用**，即不可触及\r\n\r\n时，Class对象就会结束生命周期，**Sample类在方法区内的数据也会被卸载**，从而结束Sample类的生命周期。\r\n\r\n\r\n\r\n<font color=\'red\'>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</font>\r\n\r\n\r\n\r\n### 三、具体例子\r\n\r\n\r\n\r\n![image-20230709202450409](image/JVMClassLoading.assets/image-20230709202450409.png)\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>若要想卸载方法区中某类的数据结构，根据图来看，必须要它的Class对象被回收，而Class对象要被回收，需要要它的实例对象（）Sample对象、ClassLoader对象（MyClassLoader对象）和局部变量表中引用Class对象的局部变量（objClass引用变量）全部被回收，才可能能够回收掉该类的数据结构</font>\r\n\r\n\r\n\r\nloader1变量和obj变量间接应用代表Sample类的class对象，而objclass变量则直接引用它。\r\n\r\n如果程序运行过程中，将上图左侧三个引用变量都置为null,此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。\r\n\r\n当再次有需要时，会检查Sample类的class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的class实例（可以通过哈希码查看是否是同一个实例）。\r\n\r\n\r\n\r\n### 四、类的卸载\r\n\r\n(1)**启动类加载咖载的类型在整个运行期间是不可能被卸载的**(jvm和jls规范)\r\n\r\n(2)被**系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载**，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，**其达到unreachable的可能性极小。**\r\n\r\n(3)<font color=\'cornflowerblue\'>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载</font>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的)。\r\n\r\n综合以上三点，一个己经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。\r\n\r\n<font color=\'cornflowerblue\'>综上所述：一般情况下，只有自定义的类加载器有可能被卸载，其它类的加载器都不太可能被卸载，故其加载的类也不会被卸载</font>\r\n\r\n\r\n\r\n**回顾：方法区的垃圾回收**\r\n\r\n方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量**和**不再使用的类型**。\r\n\r\nHotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。\r\n\r\n判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：\r\n\r\n- <font color=\'cornflowerblue\'>该类所有的实例都已经被回收。也就是]ava堆中不存在该类及其任何派生子类的实例。</font>\r\n- <font color=\'cornflowerblue\'>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSG1、]SP的重加载等，否则通常是很难达成的。</font>\r\n- <font color=\'cornflowerblue\'>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</font>\r\n\r\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“**被允许**”，而并不是和对象一样，没有引用了就必然会回收。\r\n\r\n\r\n\r\n## 大厂面试题\r\n\r\n\r\n\r\n**蚂蚁金服：**\r\n\r\n描述一下JVM加载Class文件的原理机制？\r\n\r\n一面：类加载过程\r\n\r\n\r\n\r\n**百度：**\r\n\r\n类加载的时机\r\n\r\njava类加载过程？\r\n\r\n简述java类加载机制？\r\n\r\n\r\n\r\n**腾讯：**\r\n\r\nJVM中类加载机制，类加载过程？\r\n\r\n\r\n\r\n**滴滴：**\r\n\r\nJVM类加载机制\r\n\r\n\r\n\r\n**美团：**\r\n\r\n]ava类加载过程\r\n\r\n描述一下jvm加载class文件的原理机制\r\n\r\n\r\n\r\n','/image/JVMClassLoading.assets/image-20230709125627229.png','原创',6,_binary '',_binary '',_binary '\0','2023-07-11 01:14:22','2023-07-12 15:11:16',2022576839,'JVM类的加载部分学习笔记',NULL,NULL,'0'),(1678454551474106369,'JVM-类的加载器','[TOC]\r\n\r\n\r\n\r\n# 类的加载器\r\n\r\n环境JDK1.8中，在JDK1.9时，类的加载器会发生一定的变化，但对于学习改变不大\r\n\r\n\r\n\r\n## 概述\r\n\r\n\r\n\r\n### ClassLoader的作用\r\n\r\n类加载器是JVM执行类加载机制的前提。\r\n\r\n\r\n\r\nClassLoader的作用：\r\n\r\nClassLoader是Java的核心组件，所有的Class都是由ClassLoader:进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.1ang.Class对象实例。然后交给]ava虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。\r\n\r\n![image-20230709204232835](image/JVMClassLoader.assets/image-20230709204232835.png)\r\n\r\n类加载器最早出现在]ava1.o版本中，那个时候只是单纯地为了满足]ava Applet.应用而被研发出来。但如今类加载器却在0SGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计拳加载器的时候，并没有考虑将它绑定在]VM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。\r\n\r\n\r\n\r\n### 显式加载与隐式加载\r\n\r\n类的加载分类：显式加载Vs隐式加载\r\n\r\nclass文件的显式加载与隐式加载的方式是指]VM加载class文件到内存的方式。\r\n\r\n- 显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().1 oadClass()加载class对象。\r\n- 隐式加载则是不直接在代码中调用classLoader的方法加载class对象，而是通过**虚拟机自动加载到内存中**，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。\r\n\r\n在日常开发以上两种方式一般会混合使用。\r\n\r\n\r\n\r\n### 命名空间\r\n\r\n**1.何为类的唯一性？**\r\n\r\n对于任意一个类，<font color=\'red\'>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</font>。每一个类加载器，都拥有一个独立的类名称空间：<font color=\'red\'>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</font>。否则,即使这两个类源自同一个Class文件，被同一个虚拟机加载，**只要加载他们的类加载器不同，那这两个类就必定不相等**。\r\n\r\n\r\n\r\n**2.命名空间**\r\n\r\n- 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成\r\n- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类\r\n- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类\r\n\r\n在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。\r\n\r\n\r\n\r\n**3.如何判断两个类是同一个类？**\r\n\r\n- 两个类的全类名（包括包名）相等\r\n- 加载两个类的类加载器相同\r\n\r\n\r\n\r\n### 类加载机制的基本特征\r\n\r\n通常类加载机制有三个基本特征：\r\n\r\n- **双亲委派模型**。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvidet/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。\r\n- 可见性，**子类加载器可以访问父加载器加载的类型**，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。\r\n- 单一性，由于父加载器的类型对于子加载器是可见的，所以**父加载器中加载过的类型，就不会在子加载器中重复加载**。但是注意，**类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见**。\r\n\r\n\r\n\r\n### 类加载器之间的关系\r\n\r\n**源码：**\r\n\r\n```java\r\npublic class Launcher {\r\n    ...\r\n\r\n    //系统类加载器\r\n    static class AppClassLoader extends URLClassLoader{}\r\n\r\n    //扩展类加载器\r\n    static class ExtClassLoader extends URLClassLoader{}\r\n    \r\n    ...\r\n}\r\n```\r\n\r\n```java\r\npublic class URLClassLoader extends SecureClassLoader implements Closeable {}\r\n    \r\npublic class SecureClassLoader extends ClassLoader {}\r\n```\r\n\r\n\r\n\r\n- AppClassLoader的父类是ExtClassLoader\r\n- ExtClassLoader的父类是BootstrapClassLoader\r\n- AppClassLoader和ExtClassLoader都继承于URLClassLoader，而URLClassLoader继承于SecureClassLoader又继承于ClassLoader\r\n\r\n\r\n\r\n### 获取类的加载器\r\n\r\n方式一：获取当前类的ClassLoader\r\n\r\nclazz.getClassLoader()\r\n\r\n方式二：获取当前线程上下文的ClassLoader\r\n\r\nThread.currentThread().getContextClassLoader()\r\n\r\n方式三：获取系统的ClassLoader\r\n\r\nClassLoader.getsystemClassLoader()\r\n\r\n方式四：获取调用者的ClassLoader\r\n\r\nDriverManager.getCallerClassLoader()\r\n\r\n\r\n\r\n\r\n\r\n## 类加载器的分类\r\n\r\n### 引导类（启动类）加载器\r\n\r\n启动类加载器（引导类加载器，Bootstrap ClassLoader)\r\n\r\n- 这个类加载使用C/C+语言实现的，嵌套在JVM内部。\r\n- 它用来加载]ava的核心库(JAVA_HOME/jre/Iib/rt.jar或sun.boot.class.path路径下的内容)。用于提供JVM自身需要的类。\r\n- 并不继承自java.lang.ClassLoader,没有父加载器。\r\n- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类\r\n- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。\r\n\r\n\r\n\r\n使用-XX:+TraceClassLoading参数得到加载类的列表\r\n\r\n\r\n\r\n- 启动类加载器使用c++编写的？Yes!\r\n- C/C++任指针函数&函数指针、C++支持多继承、更加高效\r\n- Java:由C++演变而来，(C++)--版，单继承\r\n\r\n\r\n\r\n### 扩展类加载器\r\n\r\n扩展类加载器(Extension ClassLoader)\r\n\r\n- Java语言编写，由sun.misc.Launcher:$ExtClassLoader实现。\r\n- 继承于ClassLoader类\r\n- 父类加载器为启动类加载器\r\n- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/Iib/ext子目录下加载类库。如果用户创建的]AR放在此目录下，也会自动由扩展类加载器加载。\r\n\r\n- 无法通过扩展类加载器获得引导类加载器，因为引导类加载器是用C/C++语言编写的，所以获取的值是null\r\n\r\n\r\n\r\n### 系统类加载器\r\n\r\n应用程序类加载器（系统类加载器，AppClassLoader)\r\n\r\n- java语言编写，由sun.misc.Launchers$AppClassLoader实现\r\n- 继承于ClassLoader类\r\n- 父类加载器为扩展类加载器\r\n- 它负责加载环境变量classpath或系统属性java.class,path指定路径下的类库\r\n- <font color=\'red\'>应用程序中的类加载器默认是系统类加载器。</font>\r\n- 它是用户自定义类加载器的默认父加载器\r\n- 通过ClassLoader的getSystemclassLoader()方法可以获取到该类加载器\r\n\r\n\r\n\r\n### 用户自定义类加载器\r\n\r\n用户自定义类加载器\r\n\r\n- 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。\r\n- 体现]ava语言强大生命力和巨大魅力的关键因素之一便是，]ava开发者可以自定义类加载器来实现类库的动态加载,加载源可以是本地的]AR包，也可以是网络上的远程资源。\r\n- <font color=\'red\'>通过类加载器可以实现非常绝妙的插件机制</font>，这方面的实际应用案例举不胜举。例如，著名的0SG工组件框架，再如Ec1ipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。\r\n- 同时，<font color=\'red\'>自定义加载器能够实现应用隔离</font>，例如Tomcat,Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。\r\n- 自定义类加载器通常需要继承于ClassLoader。\r\n\r\n\r\n\r\n**用户自定义类加载器的两种方式：**查看后续目录为自定义类的加载器中的内容\r\n\r\n\r\n\r\n\r\n\r\n## ClassLoader结构\r\n\r\n### 总体结构\r\n\r\n![image-20230709211423138](image/JVMClassLoader.assets/image-20230709211423138.png)\r\n\r\n除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类\r\n\r\n\r\n\r\n### ClassLoader的主要方法\r\n\r\n主要方法调用顺序：<font color=\'red\'>loadClass()内部调用 findClass()内部调用 defineClass()内部调用 preDefineClass()</font>\r\n\r\n这里没有写到preDefineClass()，此方法是为了避免重写loadClass方法打破双亲委派机制后，造成核心API被篡改\r\n\r\n\r\n\r\n抽象类ClassLoader的主要方法：(内部没有抽象方法)\r\n\r\n```java\r\npublic class<?> loadClass(String name) throws ClassNotFoundException\r\n//加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。\r\n```\r\n\r\n\r\n\r\n```java\r\nprotected class<?> findClass(String name) throws ClassNotFoundException\r\n//查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被1oadClass()方法调用。\r\n```\r\n\r\n\r\n\r\n> 在门DK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在DK1.2之后己不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在1oadc1ass()方法中被调用的，当1oadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类幼加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<font color=\'red\'>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class.对象。</font>\r\n\r\n\r\n\r\n```java\r\nprotected final class<?> defineclass(String name,byte[]b,int off,int len)\r\n//根据给定的字节数组b转换为c1ass的实例，off和1en参数表示实际Cc1ass信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。\r\n```\r\n\r\n\r\n\r\n> defineClass()方法是用来将邻yte字节流解析成]VM能够识别的Class对象(ClassLoader中己实现该方法逻辑)，通过这个方法不仅能通过c1ass文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class.对象。\r\n>\r\n> <font color=\'red\'>defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</font>\r\n\r\n\r\n\r\n### loadClass()方法源码\r\n\r\n```java\r\nprotected Class<?> loadClass(String name, boolean resolve)\r\n    throws ClassNotFoundException\r\n{\r\n    synchronized (getClassLoadingLock(name)) {\r\n        // First, check if the class has already been loaded\r\n        Class<?> c = findLoadedClass(name);\r\n        if (c == null) {\r\n            //双亲委派机制逻辑代码\r\n            long t0 = System.nanoTime();\r\n            try {\r\n                if (parent != null) {\r\n                    c = parent.loadClass(name, false);\r\n                } else {\r\n                    c = findBootstrapClassOrNull(name);\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                // ClassNotFoundException thrown if class not found\r\n                // from the non-null parent class loader\r\n            }\r\n\r\n            if (c == null) {\r\n                // If still not found, then invoke findClass in order\r\n                // to find the class.\r\n                long t1 = System.nanoTime();\r\n                //调用findClass()方法\r\n                c = findClass(name);\r\n\r\n                // this is the defining class loader; record the stats\r\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\r\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\r\n                sun.misc.PerfCounter.getFindClasses().increment();\r\n            }\r\n        }\r\n        if (resolve) {\r\n            resolveClass(c);\r\n        }\r\n        return c;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### SecureClassLoader与URLClassLoader\r\n\r\n**SecureClassLoader URLClassLoader**\r\n\r\n接着SecureClassLoader:扩展了ClassLoader,新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对Class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。\r\n\r\n前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<font color=\'red\'>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</font>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。\r\n\r\n\r\n\r\n### ExtClassLoader与AppClassLoader\r\n\r\n**ExtClassLoader AppclassLoader**\r\n\r\n了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器\r\n\r\nAppClassLoader,这两个类都继承自URLClassLoader,是sun.misc.Launcher的静态内部类，\r\n\r\nsun.misc.Launcher.主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的\r\n\r\n\r\n\r\n我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。\r\n\r\n\r\n\r\n### Class.forName()与ClassLoader.loadClass()\r\n\r\n**Class.forName()ClassLoader.loadClass():**\r\n\r\n- Class.forName():是一个静态方法，最常用的是Class.forName(String className);根据传入的类的全限定名返回一个Class对象。<font color=\'red\'>该方法在将Class文件加载到内存的同时，会执行类的初始化</font>。如：Class.forName(\"com.atguigu.java.HelloWorld\");\r\n- ClassLoader.loadclass():这是一个实例方法，需要一个ClassLoader对象来调用该方法。<font color=\'red\'>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化</font>。该方法因为需要得到一个ClassLoader对象，所以可以根据要指定使用哪个类加载器.如：ClassLoader c l= ······;				c1.loadClass(\"com.atguigu.java.HelloWorld\");\r\n\r\n\r\n\r\n## 双亲委派机制\r\n\r\n\r\n\r\n类加载器用来把类加载到]aVa虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。\r\n\r\n### 概念\r\n\r\n**1.定义**\r\n\r\n如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。\r\n\r\n**2.本质**\r\n\r\n规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载\r\n\r\n![image-20230709214112724](image/JVMClassLoader.assets/image-20230709214112724.png)\r\n\r\n![image-20230709214118952](image/JVMClassLoader.assets/image-20230709214118952.png)\r\n\r\n\r\n\r\n### 优势与劣势\r\n\r\n\r\n\r\n**1.双亲委派机制优势**\r\n\r\n- <font color=\'red\'>避免类的重复加载</font>，确保一个类的全局唯一性\r\n\r\n<font color=\'cornflowerblue\'>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载</font>，当父亲己经加载了该类时，就没有必要子ClassLoader再加载一次。\r\n\r\n- 保护程序安全，<font color=\'red\'>防止核心API被随意篡改</font>\r\n\r\n\r\n\r\n**2.代码支持**\r\n\r\n双亲委派机在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下：\r\n\r\n- (1)先在当前加载器的缓存中查找有无目标类，如果有，直接返回。\r\n- (2)判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name,false)接口进行加载。\r\n- (3)反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载。\r\n- (4)如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。\r\n\r\n**双亲委派的模型就隐藏在这第2和第3步中。**\r\n\r\n\r\n\r\n**3.举例**\r\n\r\n假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是nu11,因此系统调用findClass(String),最终通过引导类加载器进行加载。\r\n\r\n\r\n\r\n**4.思考**\r\n\r\n如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String,boolean)方法抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢？这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass(String.,byte[],int,int,ProtectionDomain)方法，而该方法会执行<font color=\'red\'>preDefineClass</font>()接口，该接口中提供了对JDK核心类库的保护。\r\n\r\n\r\n\r\n**5.双亲委托模式的弊端**\r\n\r\n检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，<font color=\'cornflowerblue\'>即顶层的ClassLoader无法访问底层的ClassLoader所加载的类</font>。\r\n\r\n通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<font color=\'red\'>应用类访问系统类自然是没有问厚，但是系统类访问应用类就会出现问题</font>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。\r\n\r\n\r\n\r\n**6.结论：**\r\n\r\n<font color=\'red\'>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已</font>。\r\n\r\n比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。\r\n\r\n\r\n\r\n### 破坏双亲委派机制\r\n\r\n双亲委派模型并不是一个具有强制性约束的模型，而是]Java设计者推荐给开发者们的类加载器实现方式。\r\n\r\n\r\n\r\n在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到]Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。\r\n\r\n\r\n\r\n**第一次破坏双亲委派机制：**\r\n\r\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一一即JDK1.2面世以前的“远古”时代。\r\n\r\n由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第个版本中就己经存在，面对己经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<font color=\'red\'>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</font>，只能在JDK1.2之后的java.lang.ClassLoader中<font color=\'red\'>添加一个新的protected方法findClass(),</font>并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们己经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。\r\n\r\n以上简单来说就是jdk1.2之前还没有引入双亲委派机制，所以jdk1.2之前就是破坏双亲委派机制的情况\r\n\r\n\r\n\r\n**第二次破坏双亲委派机制：线程上下文类加载器**\r\n\r\n双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<font color=\'red\'>越基础的类由越上层的加载器进行加载）</font>，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？\r\n\r\n这并非是不可能出现的事情，一个典型的例子便是]NDI服务，JNDI现在己经是]va的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到rt.jar的），肯定属于]ava中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的]NDI服务提供者接口(Service Provider Interface,SPI)的代码，现在问题来了，<font color=\'red\'>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</font>(SPI:在Jaya平台中，通常把核心类rt,jar中提供外部服务、可由应用层自行实现的接口称为SPI)\r\n\r\n为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<font color=\'red\'>线程上下文类加载器(Thread ContextClassLoader)</font>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\r\n\r\n有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<font color=\'red\'>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</font>，但也是无可奈何的事情。]ava中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、]AXB和]B等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。\r\n\r\n简单来说就是线程上下文类加载器让启动类加载器和系统类加载器直接联系起来了，中间的扩展类加载器被省略了，所以这破坏了双亲委派机制，其中线程上下文类加载器就是系统类加载器\r\n\r\n\r\n\r\n**第三次破坏双亲委派机制：**\r\n\r\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等\r\n\r\nIBM公司主导的]SR-291(即0SGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGI中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<font color=\'red\'>网状结构</font>。\r\n\r\n当收到类加载请求时，OSGI将按照下面的顺序进行类搜索：\r\n\r\n- <font color=\'red\'>1)将以java.*开头的类，委派给父类加载器加载。</font>\r\n- <font color=\'red\'>2)否则，将委派列表名单内的类，委派给父类加载器加载。</font>\r\n- 3)否则，将Import列表中的类，委派给Export这个类的Bund1e的类加载器加载。\r\n- 4)否则，查找当前Bund1e的classPath,使用自己的类加载器加载。\r\n- 5)否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。\r\n- 6)否则，查找Dynamic Import列表的Bundle,委派给对应Bundle的类加载器加载。\r\n- 7)否则，类查找失败。\r\n\r\n说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的\r\n\r\n小结：\r\n\r\n这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<font color=\'red\'>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</font>\r\n\r\n\r\n\r\n\r\n\r\n### 热替换的实现\r\n\r\n![image-20230709220841256](image/JVMClassLoader.assets/image-20230709220841256.png)\r\n\r\n\r\n\r\n## 沙箱安全机制\r\n\r\n沙箱安全机制\r\n\r\n- 保证程序安全\r\n- 保护]ava原生的JDK代码\r\n\r\n<font color=\'red\'>Java安全模型的核心就是]ava沙箱(sandbox)</font>。什么是沙箱？沙<font color=\'red\'>箱是一个限制程序运行的环境</font>。\r\n\r\n沙箱机制就是将]va代码<font color=\'red\'>限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问</font>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。\r\n\r\n沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。\r\n\r\n所有的]ava程序运行都可以指定沙箱，可以定制安全策略。\r\n\r\n![image-20230709221604225](image/JVMClassLoader.assets/image-20230709221604225.png)\r\n\r\n\r\n\r\n## 自定义类的加载器\r\n\r\n**1.为什么要自定义类加载器？**\r\n\r\n- <font color=\'red\'>隔离加载类</font>\r\n\r\n在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。\r\n\r\n- <font color=\'red\'>修改类加载的方式</font>\r\n\r\n类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载\r\n\r\n- <font color=\'red\'>扩展加载源</font>\r\n\r\n比如从数据库、网络、甚至是电视机机顶盒进行加载\r\n\r\n- <font color=\'red\'>防止源码泄漏</font>\r\n\r\nJava代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。\r\n\r\n\r\n\r\n**2.常见的场景**\r\n\r\n- 实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。\r\n- 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。\r\n\r\n\r\n\r\n**3.注意：**\r\n在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换,则加载器反而容易产生不美好的事情。在做]Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。\r\n\r\n\r\n\r\n用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。\r\n\r\n\r\n\r\n**1.实现方式**\r\n\r\n- Java提供了抽象类java.lang.ClassLoader,所有用户自定义的类加载器都应该继承ClassLoader类。\r\n\r\n- 在自定义ClassLoader的子类时候，我们常见的会有两种做法：\r\n\r\n  - 方式一：重写loadClass()方法\r\n\r\n  - 方式二：重写findClass()方法-->推荐（或者继承URLClassLoader）\r\n\r\n  \r\n\r\n**2.对比**\r\n\r\n这两种方法本质上差不多，毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。\r\n\r\n- loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<font color=\'red\'>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</font>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。\r\n- 当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。\r\n\r\n\r\n\r\n**3.说明**\r\n\r\n- 其父类加载器是系统类加载器\r\n- JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口（自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。\r\n\r\n\r\n\r\n## Java9变化\r\n\r\n为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\r\n\r\n1.扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(Platform ClassLoader)。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\r\n\r\nJDK9时基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就己天然地满足了可扩展的需求，那自然无须再保留<]AVA HOME>\\Iib\\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。\r\n\r\n2,平台类加载器和应用程序类加载器都不再继承自java.net.URLCLassLoader。\r\n\r\n现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.1 oader.BuiltinClassLoader。\r\n\r\n\r\n\r\n即<font color=\'red\'>URLClassLoader -- > BuiltinClassLoader</font>，只是名字改变，为了向下兼容，并没有删除\r\n\r\n\r\n\r\n如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。\r\n\r\n\r\n\r\n3.在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过**getName()**方法来获取。平台类加载器的名称是platform,.应用类加载器的名称是app。<font color=\'red\'>类加载器的名称在调试与类加载器相关的问题时会非常有用</font>。\r\n\r\n4.启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容在获取启动类加载器的场景中仍然会返回nu11,而不会得到BootClassLoader实例。\r\n\r\n5.类加载的委派关系也发生了变动。\r\n\r\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\r\n\r\n\r\n\r\n**双亲委派模式示意图**\r\n\r\n![image-20230709222712492](image/JVMClassLoader.assets/image-20230709222712492.png)\r\n\r\n<font color=\'cornflowerblue\'>当知道要加载的类是哪个模块时，可以直接交给对应负责的类加载器</font>\r\n\r\n\r\n\r\n## 大厂面试题\r\n\r\n蚂蚁金服：\r\n\r\n深入分析ClassLoader,双亲委派机制\r\n\r\n类加载器的邓亲委派模型是什么？\r\n\r\n一面：双亲委派机制及使用原因\r\n\r\n\r\n\r\n百度：\r\n\r\n都有哪些类加载器，这些类加载器都加载哪些文件？\r\n\r\n手写一个类加载器Demo\r\n\r\nClass的forName(\"java.lang.String\")和Class的getClassLoader()的1 oadclass(\"java.lang.String\")有什么区别？\r\n\r\n\r\n\r\n腾讯：\r\n\r\n什么是双亲委派模型？\r\n\r\n类加载器有哪些？\r\n\r\n\r\n\r\n小米：\r\n\r\n双亲委派模型介绍一下\r\n\r\n\r\n\r\n滴滴：\r\n\r\n简单说说你了解的类加载器\r\n\r\n一面：讲一下双亲委派模型，以及其优点\r\n\r\n\r\n\r\n字节跳动：\r\n\r\n什么是类加载器，类加载器有哪些？\r\n\r\n\r\n\r\n京东：\r\n\r\n类加载器的双亲委派模型是什么？\r\n\r\n双亲委派机制可以打破吗？为什么','image/JVMClassLoader.assets/image-20230709214112724.png','原创',4,_binary '',_binary '',_binary '\0','2023-07-11 01:22:03','2023-07-12 15:14:04',2022576839,'JVM类的加载器部分学习笔记',NULL,NULL,'0'),(1678729967006937089,'JUCBase-JUC基础：JUC基础框架体系大致了解','[TOC]\r\n\r\n\r\n\r\n# 课程内容概览\r\n\r\n• 1、什么是 JUC\r\n\r\n• 2、Lock 接口\r\n\r\n• 3、线程间通信\r\n\r\n• 4、集合的线程安全\r\n\r\n• 5、多线程锁\r\n\r\n• 6、Callable 接口\r\n\r\n• 7、JUC 三大辅助类: CountDownLatch CyclicBarrier Semaphore\r\n\r\n• 8、读写锁: ReentrantReadWriteLock\r\n\r\n• 9、阻塞队列\r\n\r\n• 10、ThreadPool 线程池\r\n\r\n• 11、Fork/Join 框架\r\n\r\n• 12、CompletableFuture\r\n\r\n<font color=\'red\'>该部分只是对JUC体系的大致了解，锁介绍内容偏向于了解和入门应用，更高级部分将在JUC01-08部分详细讲解</font>\r\n\r\n另外：JUC01-08部分，没有集合的线程安全、Callable接口、三大辅助类、阻塞队列、线程池、Fork/Join部分的讲解，其他部分均有详细讲解以及更多其他内容的讲解\r\n\r\n\r\n\r\n# 1 什么是 JUC\r\n\r\n\r\n\r\n## 1.1 JUC 简介\r\n\r\n在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC\r\n\r\n就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK \r\n\r\n1.5 开始出现的。\r\n\r\n\r\n\r\n## 1.2 进程与线程 \r\n\r\n**进程（Process）** 是计算机中的程序关于某数据集合上的一次运行活动，是系\r\n\r\n统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程\r\n\r\n设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的\r\n\r\n描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活\r\n\r\n动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是\r\n\r\n指令、数据及其组织形式的描述，进程是程序的实体。\r\n\r\n\r\n\r\n**线程（thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之\r\n\r\n中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，\r\n\r\n<font color=\'red\'>一个进程中可以并发多个线程</font>，每条线程并行执行不同的任务\r\n\r\n\r\n\r\n**总结来说:**\r\n\r\n进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—\r\n\r\n—资源分配的最小单位。\r\n\r\n线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个\r\n\r\n单元执行流。线程——程序执行的最小单位\r\n\r\n\r\n\r\n## 1.3 线程的状态 \r\n\r\n\r\n\r\n### 1.3.1 线程状态枚举类\r\n\r\n​	\r\n\r\n```java\r\npublic enum State {\r\n\r\nNEW,(新建)\r\n\r\nRUNNABLE,（准备就绪）\r\n\r\nBLOCKED,（阻塞）\r\n\r\nWAITING,（不见不散）\r\n\r\nTIMED_WAITING,（过时不候）\r\n\r\nTERMINATED;(终结)\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.3.2 wait/sleep 的区别 \r\n\r\n1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都\r\n\r\n能调用。\r\n\r\n2）**sleep 不会释放锁**，它也不需要占用锁。**wait 会释放锁**，但调用它的前提\r\n\r\n是当前线程占有锁(即代码要在 synchronized 中)。\r\n\r\n3）它们都可以被 interrupt() 方法中断。\r\n\r\n\r\n\r\n## 1.4 并发与并行 \r\n\r\n\r\n\r\n### 1.4.1 串行模式 \r\n\r\n串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能\r\n\r\n运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步\r\n\r\n骤，才能进行下一个步骤。\r\n\r\n**串行是一次只能取得一个任务，并执行这个任务**\r\n\r\n\r\n\r\n### 1.4.2 并行模式 \r\n\r\n并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模\r\n\r\n式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列\r\n\r\n的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上\r\n\r\n则依赖于多核 CPU。\r\n\r\n\r\n\r\n### 1.4.3 并发\r\n\r\n**并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可**\r\n\r\n**以同时运行或者多指令可以同时运行**。但这不是重点，在描述并发的时候也不\r\n\r\n会去扣这种字眼是否精确，==并发的重点在于它是一种现象==, ==并发描述的是多==\r\n\r\n==进程同时运行的现象==。但实际上，对于单核心 CPU 来说，同一时刻\r\n\r\n只能运行一个线程。所以，这里的\"同时运行\"表示的不是真的同一时刻有多个\r\n\r\n线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同\r\n\r\n时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一\r\n\r\n会停一会。\r\n\r\n**要解决大并发问题，通常是将大任务分解成多个小任务**, 由于操作系统对进程的\r\n\r\n调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可\r\n\r\n能会出现一些现象：\r\n\r\n• 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用\r\n\r\n队列或类似的数据结构来存放各个小任务的成果\r\n\r\n• 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或\r\n\r\n异步的方式，比如只有准备好产生了事件通知才执行某个任务。\r\n\r\n• 可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这\r\n\r\n些小任务，这时很可能要配合多路复用才能达到较高的效率\r\n\r\n\r\n\r\n### 1.4.4 小结(重点) \r\n\r\n**并发：**同一时刻多个线程在访问同一个资源，多个线程对一个点\r\n\r\n（一个CPU同一时间点是交替执行的）\r\n\r\n 例子：春运抢票 电商秒杀...\r\n\r\n**并行：**多项工作一起执行，之后再汇总\r\n\r\n 例子：泡方便面，电水壶烧水，一边撕调料倒入桶中\r\n\r\n\r\n\r\n## 1.5 管程 \r\n\r\n管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同\r\n\r\n一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行\r\n\r\nJVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程\r\n\r\n(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁\r\n\r\n执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方\r\n\r\n法在执行时候会持有管程，其他线程无法再获取同一个管程\r\n\r\n<font color=\'cornflowerblue\'>管程即管理钥匙的人，会监视锁只能由一个人使用，管程就是锁</font>\r\n\r\n\r\n\r\n## 1.6 用户线程和守护线程 \r\n\r\n**用户线程**：平时用到的普通线程,自定义线程\r\n\r\n**守护线程**：运行在后台,是一种特殊的线程,比如垃圾回收\r\n\r\n\r\n\r\n<font color=\'red\'>**当主线程结束后：用户线程还在运行,JVM存活**</font>\r\n\r\n<font color=\'red\'>**如果没有用户线程,都是守护线程,JVM结束**</font>\r\n\r\n\r\n\r\n使用thread.setDaemon(true)设置为守护线程\r\n\r\n示例：\r\n\r\n```java\r\npublic class Concept {\r\n\r\n    public static void main(String[] args) {\r\n        Thread aa = new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"::\" + Thread.currentThread().isDaemon());\r\n            while (true){\r\n                \r\n            }\r\n        }, \"aa\");\r\n        \r\n//        aa.setDaemon(true);\r\n        aa.start();\r\n        \r\n        System.out.println(Thread.currentThread().getName() + \"over\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 2 Lock 接口\r\n\r\n\r\n\r\n## 2.1 Synchronized\r\n\r\n\r\n\r\n### 2.1.1 Synchronized 关键字回顾 \r\n\r\nsynchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：\r\n\r\n1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}\r\n\r\n括起来的代码，作用的对象是调用这个代码块的对象；\r\n\r\n2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用\r\n\r\n的对象是调用这个方法的对象；\r\n\r\no 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定\r\n\r\n义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方\r\n\r\n法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这\r\n\r\n个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上\r\n\r\nsynchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方\r\n\r\n法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，\r\n\r\n子类的方法也就相当于同步了。\r\n\r\n3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的\r\n\r\n所有对象；\r\n\r\n4. 修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主\r\n\r\n的对象是这个类的所有对象。\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</font>\r\n\r\n<font color=\'cornflowerblue\'>具体表现为以下3种形式：</font>\r\n\r\n- <font color=\'cornflowerblue\'>对于普通同步方法，锁是当前实例对象。</font>\r\n- <font color=\'cornflowerblue\'>对于静态同步方法，锁是当前类的class对象。</font>\r\n- <font color=\'cornflowerblue\'>对于同步方法块，锁是Synchonized括号里配置的对象</font>\r\n\r\n\r\n\r\n\r\n\r\n### 2.1.2 售票案例\r\n\r\n```java\r\n//第一步：创建资源类\r\nclass Ticket {\r\n    //票数\r\n    private int number = 30;\r\n    \r\n    private int saleCount = 0;\r\n    \r\n    //操作方法：卖票\r\n    public synchronized void sale(){\r\n        if (number > 0){\r\n            System.out.println(Thread.currentThread().getName() + \"卖出第\" + (++saleCount) + \"张票，剩余：\" + --number);\r\n        }\r\n    }\r\n}\r\n\r\n\r\npublic class SaleTicket {\r\n\r\n    //第二步：创建多个线程，调用资源类的操作方法\r\n    public static void main(String[] args) {\r\n        Ticket ticket = new Ticket();\r\n        \r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"aa\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"bb\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"cc\").start();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执\r\n\r\n行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里\r\n\r\n获取锁的线程释放锁只会有两种情况：\r\n\r\n 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；\r\n\r\n 2）线程执行发生异常，此时 JVM 会让线程自动释放锁。\r\n\r\n 那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep\r\n\r\n方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一\r\n\r\n下，这多么影响程序执行效率。\r\n\r\n因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等\r\n\r\n待一定的时间或者能够响应中断），通过 **Lock** 就可以办到\r\n\r\n\r\n\r\n## 2.2 什么是 Lock\r\n\r\nLock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允\r\n\r\n许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对\r\n\r\n象。**Lock 提供了比 synchronized 更多的功能**。\r\n\r\nLock 与的 Synchronized 区别\r\n\r\n• Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内\r\n\r\n置特性。Lock 是一个类，通过这个类可以实现同步访问；\r\n\r\n• Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户\r\n\r\n去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，\r\n\r\n系统会自动让线程释放对锁的占用；而 **Lock 则必须要用户去手动释放锁，如**\r\n\r\n**果没有主动释放锁，就有可能导致出现死锁现象**。\r\n\r\n\r\n\r\n### 2.2.1 Lock 接口\r\n\r\n```java\r\npublic interface Lock {\r\n    void lock();\r\n    void lockInterruptibly() throws InterruptedException;\r\n    boolean tryLock();\r\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\r\n    void unlock();\r\n    Condition newCondition();\r\n}\r\n```\r\n\r\n下面来逐个讲述 Lock 接口中每个方法的使用\r\n\r\n\r\n\r\n### 2.2.2 Lock()\r\n\r\nlock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他\r\n\r\n线程获取，则进行等待。\r\n\r\n采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一\r\n\r\n般来说，使用 Lock 必须在 try{}catch{}块中进行，并且将释放锁的操作放在\r\n\r\nfinally 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock\r\n\r\n来进行同步的话，是以下面这种形式去使用的：\r\n\r\n```java\r\n		private final ReentrantLock lock = new ReentrantLock();\r\n        //上锁\r\n        lock.lock();\r\n        try {\r\n            //处理任务\r\n        } finally {\r\n            //释放锁\r\n            lock.unlock();\r\n        }\r\n```\r\n\r\n\r\n\r\n### 2.2.3 newCondition\r\n\r\n关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通\r\n\r\n知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类\r\n\r\n也可以实现等待/通知模式。\r\n\r\n用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以\r\n\r\n进行选择性通知， Condition 比较常用的两个方法：\r\n\r\n• await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重\r\n\r\n新获得锁并继续执行。\r\n\r\n• signal()用于唤醒一个等待的线程。\r\n\r\n<font color=\'cornflowerblue\'>注意：在调用 Condition 的 await()/signal()方法前，也需要线程持有相关</font>\r\n\r\n<font color=\'cornflowerblue\'>的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前</font>\r\n\r\n<font color=\'cornflowerblue\'>Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦</font>\r\n\r\n<font color=\'cornflowerblue\'>获得锁成功就继续执行。</font>\r\n\r\n**wait()/signal()方法对应于使用synchronized的wait()方法和notify()方法**\r\n\r\n\r\n\r\n使用wait() / await()方式时：不能使用if，而要使用while避免虚假唤醒，\r\n\r\n因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行\r\n\r\n需要使用while循环\r\n\r\n```java\r\n            while (条件){\r\n                condition.await();\r\n                //this.wait();\r\n            }\r\n```\r\n\r\n\r\n\r\n## 2.3 ReentrantLock\r\n\r\nReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。\r\n\r\nReentrantLock 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更\r\n\r\n多的方法。下面通过一些实例看具体看一下如何使用。\r\n\r\n**售票案例的lock实现**\r\n\r\n```java\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n//第一步：创建资源类\r\nclass LTicket {\r\n    //票数\r\n    private int number = 30;\r\n\r\n    private int saleCount = 0;\r\n\r\n    //创建可重入锁\r\n    private final ReentrantLock lock = new ReentrantLock();\r\n    \r\n    //操作方法：卖票\r\n    public void sale(){\r\n        \r\n        //上锁\r\n        lock.lock();\r\n        try {\r\n            if (number > 0){\r\n                System.out.println(Thread.currentThread().getName() + \"卖出第\" + (++saleCount) + \"张票，剩余：\" + --number);\r\n            }\r\n        } finally {\r\n            //释放锁\r\n            lock.unlock();\r\n        }\r\n    }\r\n}\r\n\r\npublic class LSaleTicket {\r\n    //第二步：创建多个线程，调用资源类的操作方法\r\n    public static void main(String[] args) {\r\n        LTicket ticket = new LTicket();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"aa\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"bb\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    ticket.sale();\r\n                    try {\r\n                        Thread.sleep(100);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"cc\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 2.4 ReadWriteLock\r\n\r\nReadWriteLock 也是一个接口，在它里面只定义了两个方法：\r\n\r\n```java\r\npublic interface ReadWriteLock {\r\n     \r\n     Lock readLock();\r\n    \r\n     Lock writeLock();\r\n}\r\n```\r\n\r\n一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分\r\n\r\n成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的\r\n\r\n**ReentrantReadWriteLock** 实现了 ReadWriteLock 接口。\r\n\r\nReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个\r\n\r\n方法：readLock()和 writeLock()用来获取读锁和写锁。\r\n\r\n\r\n\r\n• 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写\r\n\r\n锁的线程会一直等待释放读锁。\r\n\r\n• 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则\r\n\r\n申请的线程会一直等待释放写锁。\r\n\r\n\r\n\r\n## 2.5 小结(重点)\r\n\r\nLock 和 synchronized 有以下几点不同：\r\n\r\n1. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内\r\n\r\n置的语言实现；\r\n\r\n2. **synchronized 在发生异常时，会自动释放线程占有的锁**，因此不会导致死锁现\r\n\r\n象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很\r\n\r\n可能造成死锁现象，因此**使用 Lock 时需要在 finally 块中释放锁**；\r\n\r\n3. <font color=\'cornflowerblue\'>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行</font>，使用\r\n\r\nsynchronized 时，等待的线程会一直等待下去，不能够响应中断；\r\n\r\n4. <font color=\'cornflowerblue\'>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</font>。\r\n\r\n5. <font color=\'cornflowerblue\'>Lock 可以提高多个线程进行读操作的效率</font>。\r\n\r\n在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而**当竞争资源**\r\n\r\n**非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于**\r\n\r\n**synchronized**。\r\n\r\n\r\n\r\n# 3 线程间通信 \r\n\r\n线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模\r\n\r\n型来实现的。我们来基本一道面试常见的题目来分析\r\n\r\n**场景---两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求**\r\n\r\n**用线程间通信**\r\n\r\n\r\n\r\n**多线程编程步骤：**\r\n\r\n![image-20230711003002637](image/JUCBase.assets/image-20230711003002637.png)\r\n\r\n## 3.1 synchronized 方案 \r\n\r\n**使用wait()和notify()方法：**\r\n\r\n```java\r\n/**\r\n * synchronized测试线程间通信：交替加减\r\n */\r\n\r\n//第一步：创建资源类\r\nclass Share {\r\n    //初始值\r\n    private int number = 0;\r\n    //+1方法\r\n    public synchronized void incr() throws InterruptedException {\r\n        //第二步：判断 干活 通知\r\n        \r\n        //第四步：防止虚假唤醒问题\r\n        //不能使用if，而要使用while避免虚假唤醒，因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行\r\n        while (number != 0){   //判断 number是否为0，如果不是0，等待\r\n            this.wait();\r\n        }\r\n        //如果number是0，+1\r\n        number++;\r\n        System.out.println(Thread.currentThread().getName() + \"::\" + + number);\r\n        //通知 其它线程\r\n        this.notifyAll();\r\n    }\r\n    \r\n    //-1方法\r\n    public synchronized void decr() throws InterruptedException {\r\n        //第二步：判断 干活 通知\r\n        while (number != 1){   //判断 number是否为1，如果不是1，等待\r\n            this.wait();\r\n        }\r\n        //如果number是1，-1\r\n        number--;\r\n        System.out.println(Thread.currentThread().getName() + \"::\" + + number);\r\n        //通知 其它线程\r\n        this.notifyAll();\r\n    }\r\n}\r\n\r\n\r\npublic class TestVolatile {\r\n    //第三步：创建多个线程，调用资源类的操作方法\r\n    public static void main(String[] args) {\r\n\r\n        Share share = new Share();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.incr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"aa\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.decr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }\r\n            }\r\n        },\"bb\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.incr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"cc\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.decr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }\r\n            }\r\n        },\"dd\").start();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3.2 Lock 方案 \r\n\r\n```java\r\n/**\r\n * lock测试线程间通信：交替加减\r\n */\r\n//第一步：创建资源类\r\nclass Share {\r\n    //初始值\r\n    private int number = 0;\r\n    \r\n    //创建可重入锁\r\n    private final Lock lock = new ReentrantLock();\r\n    private Condition condition = lock.newCondition();\r\n    \r\n    //+1方法\r\n    public void incr() throws InterruptedException {\r\n        //第二步：判断 干活 通知\r\n        \r\n        lock.lock();\r\n        try {\r\n            //第四步：防止虚假唤醒问题\r\n            //不能使用if，而要使用while避免虚假唤醒，因为wait从哪里睡，从哪里醒，醒了过后会继续往下执行\r\n            while (number != 0){   //判断 number是否为0，如果不是0，等待\r\n                condition.await();       \r\n            }\r\n            //如果number是0，+1\r\n            number++;\r\n            System.out.println(Thread.currentThread().getName() + \"::\" + + number);\r\n            //通知 其它线程\r\n            condition.signalAll();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    //-1方法\r\n    public void decr() throws InterruptedException {\r\n        //第二步：判断 干活 通知\r\n        \r\n        lock.lock();\r\n        try {\r\n            while (number != 1){   //判断 number是否为1，如果不是1，等待\r\n                condition.await();\r\n            }\r\n            //如果number是1，-1\r\n            number--;\r\n            System.out.println(Thread.currentThread().getName() + \"::\" + + number);\r\n            //通知 其它线程\r\n            condition.signalAll();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n}\r\n\r\n\r\npublic class LTestVolatile {\r\n    //第三步：创建多个线程，调用资源类的操作方法\r\n    public static void main(String[] args) {\r\n\r\n        Share share = new Share();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.incr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"aa\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.decr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }\r\n            }\r\n        },\"bb\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.incr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"cc\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <40; i++) {\r\n                    try {\r\n                        share.decr();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }\r\n            }\r\n        },\"dd\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 3.3 线程间定制化通信 \r\n\r\n\r\n\r\n### 3.3.1 案例介绍 \r\n\r\n==问题: A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮==\r\n\r\n\r\n\r\n### 4.4.2 实现流程\r\n\r\n```java\r\n/**\r\n * 线程间定制化通信\r\n * \r\n * 这里实现：\r\n * flag=1时，aa打印5次，并set flag=2\r\n * flag=2时，bb打印10次，并set flag=3\r\n * flag=3时，cc打印15次，并set flag=1\r\n * 循环10次\r\n */\r\n//第一步：创建资源类\r\nclass ShareResource {\r\n    //标志位\r\n    private int flag = 1;\r\n\r\n    //创建可重入锁\r\n    private final Lock lock = new ReentrantLock();\r\n    //创建三个condition，实现指定唤醒\r\n    private Condition c1 = lock.newCondition();\r\n    private Condition c2 = lock.newCondition();\r\n    private Condition c3 = lock.newCondition();\r\n    \r\n    //打印5次\r\n    public void print5(int loop) throws InterruptedException {\r\n\r\n        //第二步：判断 干活 通知\r\n        lock.lock();\r\n        try {\r\n            //判断\r\n            while (flag != 1){\r\n                c1.await();\r\n            }\r\n\r\n            for (int i = 0; i < 5; i++) {\r\n                System.out.println(Thread.currentThread().getName() + \"::\" + + i + \"，轮数：\" + loop);\r\n                \r\n                //修改标志位\r\n                flag = 2;\r\n                c2.signal();\r\n            }\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    //打印10次\r\n    public void print10(int loop) throws InterruptedException {\r\n\r\n        //第二步：判断 干活 通知\r\n        lock.lock();\r\n        try {\r\n            //判断\r\n            while (flag != 2){\r\n                c2.await();\r\n            }\r\n\r\n            for (int i = 0; i < 10; i++) {\r\n                System.out.println(Thread.currentThread().getName() + \"::\" + + i + \"，轮数：\" + loop);\r\n\r\n                //修改标志位\r\n                flag = 3;\r\n                c3.signal();\r\n            }\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    //打印15次\r\n    public void print15(int loop) throws InterruptedException {\r\n\r\n        //第二步：判断 干活 通知\r\n        lock.lock();\r\n        try {\r\n            //判断\r\n            while (flag != 3){\r\n                c3.await();\r\n            }\r\n\r\n            for (int i = 0; i < 15; i++) {\r\n                System.out.println(Thread.currentThread().getName() + \"::\" + + i + \"，轮数：\" + loop);\r\n\r\n                //修改标志位\r\n                flag = 1;\r\n                c1.signal();\r\n            }\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    \r\n}\r\n\r\npublic class TestVolatileCustom {\r\n    public static void main(String[] args) {\r\n        ShareResource shareResource = new ShareResource();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <10; i++) {\r\n                    try {\r\n                        shareResource.print5(i);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"aa\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <10; i++) {\r\n                    try {\r\n                        shareResource.print10(i);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }\r\n            }\r\n        },\"bb\").start();\r\n\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i <10; i++) {\r\n                    try {\r\n                        shareResource.print15(i);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        },\"cc\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 4 集合的线程安全\r\n\r\n\r\n\r\n## 4.1 ArrayList的线程安全\r\n\r\n```java\r\n/**\r\n * ArrayList是线程不安全的，因为它的add()等方法并没有使用synchronized关键字\r\n * \r\n * 会报异常：java.util.ConcurrentModificationException   并发修改问题\r\n * \r\n * 解决方案：1 Vector                     线程安全，但古老，效率低，不常用\r\n *         2 Collections                古老，不常用\r\n *         3 CopyOnWriteArrayList       JUC工具包中的类，常用\r\n */\r\npublic class ArrayListDemo {\r\n    public static void main(String[] args) {\r\n//        List<String> list = new ArrayList<>();\r\n        \r\n        //方法一：Vector\r\n//        List<String> list = new Vector<>();\r\n\r\n        //方法二：Collections工具类、\r\n//        List<String> list = Collections.synchronizedList(new ArrayList<>());\r\n        \r\n        //方法三：CopyOnWriteArrayList      写时复制技术\r\n        List<String> list = new CopyOnWriteArrayList<>();\r\n        \r\n        for (int i = 0; i < 30; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    list.add(UUID.randomUUID().toString().substring(0,8));\r\n                    System.out.println(list);\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 4.2 HashSet的线程安全\r\n\r\n```java\r\n/**\r\n * HashSet也是线程不安全的\r\n * \r\n * 也会出现并发修改问题   java.util.ConcurrentModificationException\r\n * \r\n * 解决方法：CopyOnWriteArraySet\r\n */\r\npublic class HashSetDemo {\r\n\r\n    public static void main(String[] args) {\r\n//        Set<String> set = new HashSet<>();\r\n\r\n        //解决方法：CopyOnWriteArraySet\r\n        Set<String> set = new CopyOnWriteArraySet<>();\r\n        \r\n        for (int i = 0; i < 30; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    set.add(UUID.randomUUID().toString().substring(0,8));\r\n                    System.out.println(set);\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 4.3 HashMap的线程安全\r\n\r\n```java\r\n/**\r\n * HashMap也是线程不安全的\r\n *\r\n * 也会出现并发修改问题   java.util.ConcurrentModificationException\r\n *\r\n * 解决方法：1 HashTable                 不推荐\r\n *         2 ConcurrentHashMap         推荐\r\n */\r\npublic class HashMapDemo {\r\n\r\n    public static void main(String[] args) {\r\n//        Map<String,String> map = new HashMap<>();\r\n\r\n        //解决方法：ConcurrentHashMap\r\n        Map<String,String> map = new ConcurrentHashMap<>();\r\n\r\n        for (int i = 0; i < 30; i++) {\r\n            String key = String.valueOf(i);\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    map.put(key,UUID.randomUUID().toString().substring(0,8));\r\n                    System.out.println(map);\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 4.4 CopyOnWriteArrayList详解(重点) \r\n\r\n首先我们对 CopyOnWriteArrayList 进行学习,其特点如下:\r\n\r\n它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和\r\n\r\nArrayList 不同的时，它具有以下特性：\r\n\r\n1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多\r\n\r\n于可变操作，需要在遍历期间防止线程间的冲突。\r\n\r\n2. 它是线程安全的。\r\n\r\n3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() \r\n\r\n等等）的开销很大。\r\n\r\n4. 迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。\r\n\r\n5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代\r\n\r\n器时，迭代器依赖于不变的数组快照。\r\n\r\n**1. 独占锁效率低：采用读写分离思想解决**\r\n\r\n**2. 写线程获取到锁，其他写线程阻塞**\r\n\r\n**3. 复制思想**\r\n\r\n\r\n\r\n<font color=\'red\'>有点像JUC03中讲的JMM多线程对变量的读写过程，将共享变量复制到自己的工作内存中，再使用volatile实现可见性和有序性（猜测可能是这个，本人不确定）</font>\r\n\r\n当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容\r\n\r\n器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素\r\n\r\n之后，再将原容器的引用指向新的容器。\r\n\r\n**这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来**\r\n\r\n**得及写会内存，其他的线程就会读到了脏数据。**解决：通过 volatile 和互斥锁（马上就讲）\r\n\r\n==**这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。**==\r\n\r\n![image-20230711004453480](image/JUCBase.assets/image-20230711004453480.png)\r\n\r\n\r\n\r\n使用CopyOnWriteArrayList 没有线程安全问题\r\n\r\n**原因分析**(**重点**):==**动态数组与线程安全**==\r\n\r\n下面从“动态数组”和“线程安全”两个方面进一步对\r\n\r\nCopyOnWriteArrayList 的原理进行说明。\r\n\r\n• **“动态数组”机制**\r\n\r\no 它内部有个“volatile 数组”(array)来保持数据。在“添加/修改/删除”数据\r\n\r\n时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该\r\n\r\n数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因\r\n\r\no **由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的**\r\n\r\n**操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，**\r\n\r\n**效率比较高。**\r\n\r\n• **“线程安全”机制**\r\n\r\no 通过 volatile 和互斥锁来实现的。\r\n\r\no 通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看\r\n\r\n到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读\r\n\r\n取到的数据总是最新的”这个机制的保证。\r\n\r\no 通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，\r\n\r\n再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥\r\n\r\n锁”，就达到了保护数据的目的\r\n\r\n\r\n\r\n## **4.5 小结(重点)** \r\n\r\n**1.线程安全与线程不安全集合**\r\n\r\n集合类型中存在线程安全与线程不安全的两种,常见例如:\r\n\r\nArrayList ----- Vector\r\n\r\nHashMap -----HashTable\r\n\r\n但是以上都是通过 synchronized 关键字实现,效率较低\r\n\r\n**2.Collections 构建的线程安全集合**\r\n\r\n**3.java.util.concurrent 并发包下**\r\n\r\nCopyOnWriteArrayList 和CopyOnWriteArraySet 类型,通过动态数组与线程安\r\n\r\n全个方面保证线程安全\r\n\r\n\r\n\r\n# 5 多线程锁 \r\n\r\n\r\n\r\n## 5.1 锁的八个问题演示 \r\n\r\n```java\r\nclass Phone {\r\n\r\n    public static synchronized void sendSMS() throws Exception {\r\n        //停留4秒\r\n        TimeUnit.SECONDS.sleep(4);\r\n        System.out.println(\"------sendSMS\");\r\n    }\r\n\r\n    public synchronized void sendEmail() throws Exception {\r\n        System.out.println(\"------sendEmail\");\r\n    }\r\n\r\n    public void getHello() {\r\n        System.out.println(\"------getHello\");\r\n    }\r\n}\r\n\r\n/**\r\n * @Description: 8锁\r\n *\r\n1 标准访问，先打印短信还是邮件\r\n------sendSMS\r\n------sendEmail\r\n\r\n2 停4秒在短信方法内，先打印短信还是邮件\r\n------sendSMS\r\n------sendEmail\r\n\r\n3 新增普通的hello方法，是先打短信还是hello\r\n------getHello\r\n------sendSMS\r\n\r\n4 现在有两部手机，先打印短信还是邮件\r\n------sendEmail\r\n------sendSMS\r\n\r\n5 两个静态同步方法，1部手机，先打印短信还是邮件\r\n------sendSMS\r\n------sendEmail\r\n\r\n6 两个静态同步方法，2部手机，先打印短信还是邮件\r\n------sendSMS\r\n------sendEmail\r\n\r\n7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件\r\n------sendEmail\r\n------sendSMS\r\n\r\n8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件\r\n------sendEmail\r\n------sendSMS\r\n\r\n */\r\n\r\npublic class Lock_8 {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        Phone phone = new Phone();\r\n        Phone phone2 = new Phone();\r\n\r\n        new Thread(() -> {\r\n            try {\r\n                phone.sendSMS();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }, \"AA\").start();\r\n\r\n        Thread.sleep(100);\r\n\r\n        new Thread(() -> {\r\n            try {\r\n               // phone.sendEmail();\r\n               // phone.getHello();\r\n                phone2.sendEmail();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }, \"BB\").start();\r\n    }\r\n}\r\n```\r\n\r\n**结论：**\r\n\r\n一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的\r\n\r\n一个 synchronized 方法了，\r\n\r\n其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些\r\n\r\nsynchronized 方法\r\n\r\n锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的\r\n\r\nsynchronized 方法\r\n\r\n加个普通方法后发现和同步锁无关\r\n\r\n换成两个对象后，不是同一把锁了，情况立刻变化。\r\n\r\nsynchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。\r\n\r\n**具体表现为以下** **3** **种形式。**\r\n\r\n**对于普通同步方法，锁是当前实例对象。**\r\n\r\n**对于静态同步方法，锁是当前类的** **Class** **对象。**\r\n\r\n**对于同步方法块，锁是** **Synchonized** **括号里配置的对象**\r\n\r\n当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。\r\n\r\n也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方\r\n\r\n法必须等待获取锁的方法释放锁后才能获取锁，\r\n\r\n可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，\r\n\r\n所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。\r\n\r\n所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所\r\n\r\n以静态同步方法与非静态同步方法之间是不会有竞态条件的。\r\n\r\n但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才\r\n\r\n能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同\r\n\r\n步方法之间，只要它们同一个类的实例对象！\r\n\r\n\r\n\r\n## 5.2 公平锁和可重入锁\r\n\r\n**公平锁**\r\n\r\n```java\r\n    /**\r\n     * 公平锁\r\n     */\r\n    //创建可重入锁\r\n    private final ReentrantLock lock = new ReentrantLock(false);       //设置是否为公平锁，默认为false，代表抢占式锁，若为true，则表示若有人，则自觉排队\r\n```\r\n\r\n![image-20230711160825024](image/JUCBase.assets/image-20230711160825024.png)\r\n\r\n可重入锁也叫递归锁：多层锁机制只需要同一把锁即可自由出入\r\n\r\n**可重入锁案例演示**\r\n\r\n```java\r\npublic class SyncLockDemo {\r\n\r\n    public synchronized void add() {\r\n        add();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        /**\r\n         * 可重入锁（递归锁）：多层锁机制只需要同一把锁即可自由出入\r\n         * synchronized(隐式)    lock(显式)\r\n         */\r\n        //synchronized可重入锁演示1：\r\n        /*Object o = new Object();\r\n        new Thread(() -> {\r\n            synchronized (o){\r\n                System.out.println(Thread.currentThread().getName() + \"外层\");\r\n\r\n                synchronized (o){\r\n                    System.out.println(Thread.currentThread().getName() + \"中层\");\r\n\r\n                    synchronized (o){\r\n                        System.out.println(Thread.currentThread().getName() + \"内层\");\r\n                    }\r\n                }\r\n            }\r\n        },\"t1\").start();*/\r\n\r\n\r\n        //synchronized可重入锁演示2：\r\n        new SyncLockDemo().add();   //将会报栈内存溢出，证明可以递归调用add方法自己，是可重入锁\r\n    }\r\n\r\n    /**\r\n     * lock演示可重入锁       递归使用锁必须一上锁对应一解锁，加入内部锁上锁了不解锁，自己线程使用会没问题，但是会影响其它线程\r\n     */\r\n    @Test\r\n    public void testLock() {\r\n        Lock lock = new ReentrantLock();\r\n        new Thread(() -> {\r\n            try {\r\n                lock.lock();\r\n                System.out.println(Thread.currentThread().getName() + \" 外层\");\r\n\r\n                try {\r\n                    //上锁\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName() + \" 内层\");\r\n                } finally {\r\n                    //释放锁\r\n                    lock.unlock();\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }, \"t1\").start();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 5.3 死锁\r\n\r\n![image-20230711160927379](image/JUCBase.assets/image-20230711160927379.png)\r\n\r\n```java\r\n/**\r\n * 死锁：两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象，如果设有外力干涉，他们无法再执行下去\r\n * \r\n * 死锁的验证方式：第一步：jps  第二步：jstack 进程号\r\n */\r\npublic class DeadLockDemo {\r\n    \r\n    //先创建两个对象充当两把锁\r\n    static Object a = new Object();\r\n    static Object b = new Object();\r\n\r\n    public static void main(String[] args) {\r\n        new Thread(() -> {\r\n            synchronized (a){\r\n                System.out.println(Thread.currentThread().getName() + \"持有锁a，试图获取锁b\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (b){\r\n                    System.out.println(Thread.currentThread().getName() + \"获取锁b\");\r\n                }\r\n            }\r\n        },\"A\").start();\r\n\r\n        new Thread(() -> {\r\n            synchronized (b){\r\n                System.out.println(Thread.currentThread().getName() + \"持有锁b，试图获取锁a\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (a){\r\n                    System.out.println(Thread.currentThread().getName() + \"获取锁a\");\r\n                }\r\n            }\r\n        },\"B\").start();\r\n    }    \r\n}\r\n```\r\n\r\n\r\n\r\n# 6 Callable&Future 接口 \r\n\r\n\r\n\r\n## 6.1 Callable 接口\r\n\r\n![image-20230711005529315](image/JUCBase.assets/image-20230711005529315.png)\r\n\r\n目前我们学习了有两种创建线程的方法-一种是通过创建 Thread 类，另一种是\r\n\r\n通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程\r\n\r\n终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，\r\n\r\nJava 中提供了 Callable 接口。\r\n\r\n==**现在我们学习的是创建线程的第三种方案---Callable 接口**==\r\n\r\n**Callable 接口的特点如下(重点)**\r\n\r\n• 为了实现 Runnable，需要实现不返回任何内容的 run（）方法，而对于\r\n\r\nCallable，需要实现在完成时返回结果的 call（）方法。\r\n\r\n• call（）方法可以引发异常，而 run（）则不能。\r\n\r\n• 为实现 Callable 而必须重写 call 方法\r\n\r\n• 不能直接替换 runnable,因为 Thread 类的构造方法根本没有 Callable\r\n\r\n```java\r\n//实现Runnable：\r\nclass MyThread1 implements Runnable{\r\n    @Override\r\n    public void run() {\r\n        \r\n    }\r\n}\r\n\r\n//实现Callable：\r\nclass MyThread2 implements Callable{\r\n    @Override\r\n    public Integer call() throws Exception {\r\n        System.out.println(Thread.currentThread().getName()+\" come in callable\");\r\n        return 200;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 6.2 Future 接口\r\n\r\n当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可\r\n\r\n以知道该线程返回的结果。为此，可以使用 Future 对象。\r\n\r\n将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦\r\n\r\nCallable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的\r\n\r\n一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:\r\n\r\n\r\n\r\n• **public boolean cancel（boolean mayInterrupt）：**用于停止任务。\r\n\r\n==如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true==\r\n\r\n==时才会中断任务。==\r\n\r\n\r\n\r\n• **public Object get（）抛出 InterruptedException，ExecutionException：**\r\n\r\n用于获取任务的结果。\r\n\r\n==如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。==\r\n\r\n\r\n\r\n• **public boolean isDone（）：**如果任务完成，则返回 true，否则返回 false\r\n\r\n可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封\r\n\r\n装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结\r\n\r\n果。实际上，future 也可以与 Runnable 一起使用。\r\n\r\n要创建线程，需要 Runnable。为了获得结果，需要 future。\r\n\r\n\r\n\r\n## 6.3 FutureTask \r\n\r\nJava 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方\r\n\r\n便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建\r\n\r\nFutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建\r\n\r\nThread 对象。因此，间接地使用 Callable 创建线程。\r\n\r\n**核心原理:(重点)**\r\n\r\n在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些\r\n\r\n作业交给 Future 对象在后台完成\r\n\r\n• 当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执\r\n\r\n行状态\r\n\r\n• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去\r\n\r\n获取结果。\r\n\r\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法\r\n\r\n• 一旦计算完成，就不能再重新开始或取消计算\r\n\r\n• get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完\r\n\r\n成状态，然后会返回结果或者抛出异常\r\n\r\n• get 只计算一次,因此 get 方法放到最后\r\n\r\n\r\n\r\n## 6.4 使用 Callable 和 Future\r\n\r\n```java\r\n/**\r\n * 通过Callable接口创建线程 ：可以有返回值 jdk1.5 新增\r\n */\r\n\r\n/**\r\n * 比较Runnable和Callable接口\r\n * \r\n * Runnable     run()       无返回值        不抛出异常       创建方式不同\r\n * Callable     call()      有返回值        会抛出异常       创建方式不同\r\n */\r\n\r\n//实现Runnable：\r\nclass MyThread1 implements Runnable{\r\n    @Override\r\n    public void run() {\r\n        \r\n    }\r\n}\r\n\r\n//实现Callable：\r\nclass MyThread2 implements Callable{\r\n    @Override\r\n    public Integer call() throws Exception {\r\n        System.out.println(Thread.currentThread().getName()+\" come in callable\");\r\n        return 200;\r\n    }\r\n}\r\n\r\npublic class CallableDemo1 {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        //创建Runnable线程\r\n        new Thread(new MyThread1(),\"AA\").start();\r\n        \r\n        //创建Callable线程  报错\r\n//        new Thread(new MyThread2(),\"BB\").start();\r\n        \r\n        //创建FutureTask\r\n        FutureTask<Integer> futureTask1 = new FutureTask<>(new MyThread2());\r\n        \r\n        //lambda表达式\r\n        FutureTask<Integer> futureTask2 = new FutureTask<>(() -> {\r\n            System.out.println(Thread.currentThread().getName()+\" come in callable\");\r\n            return 1024;\r\n        });\r\n        \r\n        //创建Callable线程:\r\n        new Thread(futureTask2,\"Lucy\").start();\r\n        new Thread(futureTask1,\"mary\").start();\r\n        \r\n        //调用FutureTask的get()方法得到Callable接口的返回值\r\n        System.out.println(futureTask2.get());\r\n\r\n        System.out.println(futureTask1.get());\r\n\r\n        System.out.println(Thread.currentThread().getName()+\" come over\");\r\n        \r\n        //FutureTask原理  未来任务\r\n        /**\r\n         * 1、老师上课，口渴了，去买票不合适，讲课线程继续。\r\n         *   单开启线程找班上班长帮我买水，把水买回来，需要时候直接get\r\n         *\r\n         * 2、4个同学， 1同学 1+2...5   ，  2同学 10+11+12....50， 3同学 60+61+62，  4同学 100+200\r\n         *      第2个同学计算量比较大，\r\n         *     FutureTask单开启线程给2同学计算，先汇总 1 3 4 ，最后等2同学计算位完成，统一汇总\r\n         *\r\n         * 3、考试，做会做的题目，最后看不会做的题目\r\n         *\r\n         * 汇总一次\r\n         *\r\n         */\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 6.5 小结(重点) \r\n\r\n• 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些\r\n\r\n作业交给 Future 对象在后台完成, **当主线程将来需要时**，就可以通过 Future\r\n\r\n对象获得后台作业的计算结果或者执行状态\r\n\r\n• **一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去**\r\n\r\n**获取结果**\r\n\r\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计\r\n\r\n算完成，就不能再重新开始或取消计算。**get 方法而获取结果只有在计算完成**\r\n\r\n**时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异**\r\n\r\n**常。**\r\n\r\n• **只计算一次**\r\n\r\n\r\n\r\n# 7 JUC 三大辅助类\r\n\r\nJUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过\r\n\r\n多时 Lock 锁的频繁操作。这三种辅助类为：\r\n\r\n• CountDownLatch: 减少计数\r\n\r\n• CyclicBarrier: 循环栅栏\r\n\r\n• Semaphore: 信号灯\r\n\r\n## 7.1 减少计数 CountDownLatch\r\n\r\nCountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行\r\n\r\n减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法\r\n\r\n之后的语句。\r\n\r\n• CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这\r\n\r\n些线程会阻塞\r\n\r\n• 其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程\r\n\r\n不会阻塞)\r\n\r\n• 当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行\r\n\r\n**可使用在原子类AtomicInteger等场景中等待线程执行完毕后才获取值**\r\n\r\n\r\n\r\n**场景: 6 个同学陆续离开教室后值班同学才可以关门。**\r\n\r\n```java\r\n/**\r\n * 演示JUC辅助类：CountDownLatch\r\n * await()，阻塞线程，等待计数器为0后才执行后面的语句\r\n * countDown()，每次对计数器  -1\r\n */\r\npublic class CountDownLatchDemo {\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n        //6位同学，都离开教室后，班长才锁门\r\n        CountDownLatch countDownLatch = new CountDownLatch(6);\r\n\r\n        for (int i = 1; i <= 6; i++) {\r\n            new Thread(() -> {\r\n                System.out.println(Thread.currentThread().getName() + \"离开\");\r\n                \r\n                //计数器 -1\r\n                countDownLatch.countDown();\r\n            },String.valueOf(i)).start();\r\n        }\r\n        //阻塞线程等待计数器为0\r\n        countDownLatch.await();\r\n        System.out.println(Thread.currentThread().getName() + \"班长锁门走人了\");\r\n        \r\n    }\r\n}\r\n```\r\n\r\n## 7.2 循环栅栏 CyclicBarrier \r\n\r\nCyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中\r\n\r\nCyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一\r\n\r\n次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后\r\n\r\n的语句，即new CyclicBarrier 时定义的Runnable接口中的语句。\r\n\r\n可以将 CyclicBarrier 理解为加 1 操作\r\n\r\n**场景: 集齐 7 颗龙珠就可以召唤神龙**\r\n\r\n```java\r\n/**\r\n * JUC辅助类CyclicBarrier演示：\r\n * 理解：循环栅栏\r\n * new CyclicBarrier(int parties,Runnable barrierAction)\r\n * await()：当调用 parties 次await()方法后，将执行barrierAction中定义的语句\r\n * 若未达到parties次调用，则一直阻塞barrierAction的调用\r\n */\r\npublic class CyclicBarrierDemo {\r\n    \r\n    public static final int NUMBER = 7;\r\n    \r\n    //集齐7颗龙珠才能召唤神龙\r\n    public static void main(String[] args) {\r\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER,() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"成功召唤神龙\");\r\n        });\r\n\r\n\r\n        for (int i = 1; i <= 7; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    System.out.println(\"成功收集到\" + Thread.currentThread().getName() + \"星龙珠\");\r\n                    cyclicBarrier.await();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 7.3 信号灯 Semaphore \r\n\r\nSemaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线\r\n\r\n程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方\r\n\r\n法获得许可证，release 方法释放许可\r\n\r\n**场景: 抢车位, 6 部汽车 3 个停车位**\r\n\r\n```java\r\n/**\r\n * 演示JUC辅助类：SemaphoreDemo:\r\n * new Semaphore(3);设置许可数量permits\r\n * acquire()：抢占许可\r\n * release()：释放许可\r\n */\r\npublic class SemaphoreDemo {\r\n    \r\n    //6辆车抢3个车位\r\n    public static void main(String[] args) {\r\n\r\n        //创建semaphore，设置许可数量\r\n        Semaphore semaphore = new Semaphore(3);\r\n        \r\n        //模拟6辆汽车\r\n        for (int i = 1; i <=6 ; i++) {\r\n            new Thread(() -> {\r\n\r\n                try {\r\n                    //抢占\r\n                    semaphore.acquire();\r\n                    System.out.println(Thread.currentThread().getName() + \"抢到了车位\");\r\n                    \r\n                    //设置随机停车时间\r\n                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));\r\n                    System.out.println(Thread.currentThread().getName() + \"---------离开了车位\");\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    //释放\r\n                    semaphore.release();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 8 读写锁\r\n\r\n\r\n\r\n## 8.1 读写锁介绍 \r\n\r\n现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那\r\n\r\n么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以\r\n\r\n应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，\r\n\r\n就不应该允许其他线程对该资源进行读和写的操作了。\r\n\r\n针对这种场景，**JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，**\r\n\r\n**它表示两个锁，一个是读操作相关的锁，称为<font color=\'red\'>共享锁</font>；一个是写相关的锁，称**\r\n\r\n**为<font color=\'red\'>排他锁（独占锁）</font>**\r\n\r\n<font color=\'red\'>**读的时候不能写，写的时候可以读**</font>\r\n\r\n1. 线程进入读锁的前提条件：\r\n\r\n• 没有其他线程的写锁\r\n\r\n• 没有写请求, 或者==有写请求，但调用线程和持有锁的线程是同一个(可重入==\r\n\r\n==锁)。==\r\n\r\n2. 线程进入写锁的前提条件：\r\n\r\n• 没有其他线程的读锁\r\n\r\n• 没有其他线程的写锁\r\n\r\n而读写锁有以下三个重要的特性：\r\n\r\n（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公\r\n\r\n平优于公平。\r\n\r\n（2）重进入：读锁和写锁都支持线程重进入。\r\n\r\n（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，<font color=\'cornflowerblue\'>写锁能够降级成为</font>\r\n\r\n<font color=\'cornflowerblue\'>读锁</font>\r\n\r\n\r\n\r\n## 8.2 ReentrantReadWriteLock\r\n\r\nReentrantReadWriteLock 类的整体结构\r\n\r\n```java\r\npublic class ReentrantReadWriteLock implements ReadWriteLock,java.io.Serializable {\r\n    /**\r\n     * 读锁\r\n     */\r\n    private final ReentrantReadWriteLock.ReadLock readerLock;\r\n    /**\r\n     * 写锁\r\n     */\r\n    private final ReentrantReadWriteLock.WriteLock writerLock;\r\n    final Sync sync;\r\n\r\n    /**\r\n     * 使用默认（非公平）的排序属性创建一个新的\r\n     * ReentrantReadWriteLock\r\n     */\r\n    public ReentrantReadWriteLock() {\r\n        this(false);\r\n    }\r\n\r\n    /**\r\n     * 使用给定的公平策略创建一个新的 ReentrantReadWriteLock\r\n     */\r\n    public ReentrantReadWriteLock(boolean fair) {\r\n        sync = fair ? new FairSync() : new NonfairSync();\r\n        readerLock = new ReadLock(this);\r\n        writerLock = new WriteLock(this);\r\n    }\r\n\r\n    /**\r\n     * 返回用于写入操作的锁\r\n     */\r\n    public ReentrantReadWriteLock.WriteLock writeLock() {\r\n        return\r\n                writerLock;\r\n    }\r\n\r\n    /**\r\n     * 返回用于读取操作的锁\r\n     */\r\n    public ReentrantReadWriteLock.ReadLock readLock() {\r\n        return\r\n                readerLock;\r\n    }\r\n\r\n    abstract static class Sync extends AbstractQueuedSynchronizer {\r\n    }\r\n\r\n    static final class NonfairSync extends Sync {\r\n    }\r\n\r\n    static final class FairSync extends Sync {\r\n    }\r\n\r\n    public static class ReadLock implements Lock, java.io.Serializable {\r\n    }\r\n\r\n    public static class WriteLock implements Lock, java.io.Serializable {\r\n    }\r\n}\r\n```\r\n\r\n可以看到，ReentrantReadWriteLock 实现了 ReadWriteLock 接口，\r\n\r\nReadWriteLock 接口定义了获取读锁和写锁的规范，具体需要实现类去实现；\r\n\r\n同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看\r\n\r\n到 ReentrantReadWriteLock 实现了自己的序列化逻辑。\r\n\r\n\r\n\r\n## 8.3 入门案例 \r\n\r\n**场景: 使用 ReentrantReadWriteLock 对一个 hashmap 进行读和写操作**\r\n\r\n```java\r\n/**\r\n * 读写锁：ReadWriteLock\r\n * 读锁：共享锁   会发生死锁\r\n * 写锁：独占锁   会发生死锁\r\n * 读的时候不能写，写的时候可以读\r\n */\r\n//新建资源类\r\nclass MyCache{\r\n    //创建map集合\r\n    private volatile Map<String,Object> map = new HashMap<>();\r\n\r\n    //创建读写锁对象\r\n    private ReadWriteLock rwLock = new ReentrantReadWriteLock();\r\n    \r\n    //放数据\r\n    public void put(String key,Object value){\r\n        //添加写锁\r\n        rwLock.writeLock().lock();\r\n\r\n        try {\r\n            System.out.println(Thread.currentThread().getName()+\" 正在写操作\"+key);\r\n            //暂停一会\r\n            TimeUnit.MICROSECONDS.sleep(300);\r\n            //放数据\r\n            map.put(key,value);\r\n            System.out.println(Thread.currentThread().getName() + \"写完了\" + key);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放写锁\r\n            rwLock.writeLock().unlock();\r\n        }\r\n    }\r\n\r\n    //取数据\r\n    public Object get(String key){\r\n        //添加写锁\r\n        rwLock.readLock().lock();\r\n        Object result = null;\r\n\r\n        try {\r\n            System.out.println(Thread.currentThread().getName()+\" 正在读操作\"+key);\r\n            //暂停一会\r\n            TimeUnit.MICROSECONDS.sleep(300);\r\n            //放数据\r\n            result = map.get(key);\r\n            System.out.println(Thread.currentThread().getName() + \"读完了\" + key);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //释放写锁\r\n            rwLock.readLock().unlock();\r\n        }\r\n        return result;\r\n    }\r\n    \r\n}    \r\n\r\npublic class ReadWriteLockDemo {\r\n    public static void main(String[] args) {\r\n        \r\n        MyCache myCache = new MyCache();\r\n        \r\n        for (int i = 1; i <= 5; i++) {\r\n            int num = i;\r\n            new Thread(()->{\r\n                myCache.put(num+\"\",num+\"\");\r\n            },String.valueOf(i)).start();\r\n        }\r\n\r\n        for (int i = 1; i <= 5; i++) {\r\n            int num = i;\r\n            new Thread(()->{\r\n                myCache.get(num+\"\");\r\n            },String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 8.4 读写锁的演变\r\n\r\n![image-20230711155904877](image/JUCBase.assets/image-20230711155904877.png)\r\n\r\n缺点：\r\n\r\n(1)造成锁饥饿，一直读，设有写\r\n\r\n操作，比如坐地铁\r\n\r\n(2)读时候，不能写，只有读\r\n\r\n完成之后，才可以写，写操作\r\n\r\n可以读\r\n\r\n\r\n\r\n## 8.5 锁降级\r\n\r\n![image-20230711160212543](image/JUCBase.assets/image-20230711160212543.png)\r\n\r\n```java\r\n/**\r\n * 读写锁降级：写锁 -》 读锁 -》 释放写锁 -》 释放读锁\r\n * 只能由写锁降级为读锁\r\n * 但是不能由读锁升级为写锁\r\n * 因为读锁是共享的，你读的时候可能还有其他人正在读\r\n * 而写锁是独占的，当前只有你一个人在写，所以可以降级为读锁\r\n */\r\npublic class ReadWriteLockDemo2 {\r\n    public static void main(String[] args) {\r\n        ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\r\n        ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();\r\n        ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();\r\n        \r\n        writeLock.lock();\r\n\r\n        System.out.println(\"write\");\r\n        \r\n        readLock.lock();\r\n\r\n        System.out.println(\"read\");\r\n\r\n        writeLock.unlock();\r\n\r\n        readLock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 8.6 读写锁的死锁\r\n\r\n![image-20230711161304079](image/JUCBase.assets/image-20230711161304079.png)\r\n\r\n<font color=\'red\'>**读的时候不能写，写的时候可以读**</font>\r\n\r\n**死锁案例：**\r\n\r\n当使用**表锁**时，线程1和线程2都正在读某张表时（因为读锁共享），此时线程1想要写操作，\r\n\r\n他需要等待线程2读完，但线程2此时也想要写操作，他也需要等待线程1读完，此时就造成死锁\r\n\r\n当使用**行锁**时，线程1正在写操作第一行，线程2正在写操作第二行，于此同时，线程1想要操作第二行\r\n\r\n线程2想要操作第一行，此时就造成死锁\r\n\r\n\r\n\r\n## 8.7 小结(重要) \r\n\r\n• 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发\r\n\r\n现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\r\n\r\n• 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写\r\n\r\n锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。\r\n\r\n原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把\r\n\r\n获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写\r\n\r\n锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释\r\n\r\n放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。\r\n\r\n\r\n\r\n\r\n\r\n# 9 阻塞队列\r\n\r\n\r\n\r\n## 9.1 BlockingQueue 简介\r\n\r\nConcurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全\r\n\r\n“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建\r\n\r\n高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭\r\n\r\n中的所有成员，包括他们各自的功能以及常见使用场景。\r\n\r\n阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据\r\n\r\n由队列的一端输入，从另外一端输出；\r\n\r\n![image-20230711162419099](image/JUCBase.assets/image-20230711162419099.png)\r\n\r\n<font color=\'cornflowerblue\'>当队列是空的，从队列中获取元素的操作将会被阻塞</font>\r\n\r\n<font color=\'cornflowerblue\'>当队列是满的，从队列中添加元素的操作将会被阻塞</font>\r\n\r\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\r\n\r\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多\r\n\r\n个元素或者完全清空，使队列变得空闲起来并后续新增\r\n\r\n\r\n\r\n常用的队列主要有以下两种：\r\n\r\n<font color=\'cornflowerblue\'>• 先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。</font>\r\n\r\n<font color=\'cornflowerblue\'>从某种程度上来说这种队列也体现了一种公平性</font>\r\n\r\n<font color=\'cornflowerblue\'>• 后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发</font>\r\n\r\n<font color=\'cornflowerblue\'>生的事件(栈)</font>\r\n\r\n在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起\r\n\r\n的线程又会自动被唤起\r\n\r\n为什么需要 BlockingQueue\r\n\r\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切\r\n\r\nBlockingQueue 都给你一手包办了\r\n\r\n在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细\r\n\r\n节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。\r\n\r\n\r\n\r\n多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和\r\n\r\n“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我\r\n\r\n们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准\r\n\r\n备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地\r\n\r\n解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一\r\n\r\n发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度\r\n\r\n大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么\r\n\r\n生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的\r\n\r\n数据处理完毕，反之亦然。\r\n\r\n• <font color=\'cornflowerblue\'>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</font>\r\n\r\n<font color=\'cornflowerblue\'>直到有数据放入队列</font>\r\n\r\n<font color=\'cornflowerblue\'>• 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</font>\r\n\r\n<font color=\'cornflowerblue\'>直到队列中有空的位置，线程被自动唤醒</font>\r\n\r\n\r\n\r\n## 9.2 BlockingQueue 核心方法 \r\n\r\n![image-20230711162552598](image/JUCBase.assets/image-20230711162552598.png)\r\n\r\n**BlockingQueue 的核心方法**：\r\n\r\n**1.放入数据**\r\n\r\n• offer(anObject):表示如果可能的话,将 anObject 加到 BlockingQueue 里,即\r\n\r\n如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.**（本方法不阻塞当**\r\n\r\n**前执行方法的线程）**\r\n\r\n• offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定\r\n\r\n的时间内，还不能往队列中加入 BlockingQueue，则返回失败\r\n\r\n• put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有\r\n\r\n空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.\r\n\r\n\r\n\r\n**2.获取数据**\r\n\r\n• poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,**则可以等**\r\n\r\n**time 参数规定的时间,取不到时返回 null**\r\n\r\n• poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，\r\n\r\n如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知\r\n\r\n道时间超时还没有数据可取，返回失败。\r\n\r\n• take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,**阻断**\r\n\r\n**进入等待状态直到 BlockingQueue 有新的数据被加入**;\r\n\r\n• drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定\r\n\r\n获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加\r\n\r\n锁或释放锁。\r\n\r\n\r\n\r\n## 9.3 入门案例 \r\n\r\n```java\r\n/**\r\n * 阻塞队列\r\n */\r\npublic class BlockingQueueDemo {\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n\r\n        //创建阻塞队列，长度为3\r\n        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);\r\n        \r\n        //第一组：抛出异常\r\n//        System.out.println(blockingQueue.add(\"a\"));\r\n//        System.out.println(blockingQueue.add(\"b\"));\r\n//        System.out.println(blockingQueue.add(\"c\"));\r\n//        System.out.println(blockingQueue.element());\r\n//        \r\n//        System.out.println(blockingQueue.add(\"w\"));\r\n//\r\n//        System.out.println(blockingQueue.remove());\r\n//        System.out.println(blockingQueue.remove());\r\n//        System.out.println(blockingQueue.remove());\r\n//        System.out.println(blockingQueue.remove());\r\n        \r\n        //第二组：返回true false\r\n//        System.out.println(blockingQueue.offer(\"a\"));\r\n//        System.out.println(blockingQueue.offer(\"b\"));\r\n//        System.out.println(blockingQueue.offer(\"c\"));\r\n//        System.out.println(blockingQueue.offer(\"w\"));\r\n//\r\n//        System.out.println(blockingQueue.poll());\r\n//        System.out.println(blockingQueue.poll());\r\n//        System.out.println(blockingQueue.poll());\r\n//        System.out.println(blockingQueue.poll());\r\n        \r\n        //第三组：阻塞\r\n//        blockingQueue.put(\"a\");\r\n//        blockingQueue.put(\"b\");\r\n//        blockingQueue.put(\"c\");\r\n//        blockingQueue.put(\"w\");\r\n//\r\n//        System.out.println(blockingQueue.take());\r\n//        System.out.println(blockingQueue.take());\r\n//        System.out.println(blockingQueue.take());\r\n//        System.out.println(blockingQueue.take());\r\n        \r\n        //第四组：设置阻塞超时时间\r\n        System.out.println(blockingQueue.offer(\"a\"));\r\n        System.out.println(blockingQueue.offer(\"b\"));\r\n        System.out.println(blockingQueue.offer(\"c\"));\r\n        System.out.println(blockingQueue.offer(\"w\",3L, TimeUnit.SECONDS));\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 9.4 常见的 BlockingQueue \r\n\r\n### 9.4.1 ArrayBlockingQueue(常用)\r\n\r\n基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数\r\n\r\n组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数\r\n\r\n组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的\r\n\r\n头部和尾部在数组中的位置\r\n\r\n\r\n\r\nArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处\r\n\r\n在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者\r\n\r\n则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数\r\n\r\n据的系统中，其对于GC 的影响还是存在一定的区别。\r\n\r\n而在创建 ArrayBlockingQueue 时，我们还、可以控制对象的内部锁是否采用\r\n\r\n公平锁，默认采用非公平锁。\r\n\r\n==**一句话总结: 由数组结构组成的有界阻塞队列。**==\r\n\r\n\r\n\r\n### 9.4.2 LinkedBlockingQueue(常用)\r\n\r\n基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一\r\n\r\n个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据\r\n\r\n时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；\r\n\r\n只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过\r\n\r\n构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份\r\n\r\n数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。\r\n\r\n而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生\r\n\r\n产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发\r\n\r\n的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列\r\n\r\n的并发性能。\r\n\r\n**ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用**\r\n\r\n**的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个**\r\n\r\n**类足以。**\r\n\r\n==**一句话总结: 由链表结构组成的有界（但大小默认值为**==\r\n\r\n==**integer.MAX_VALUE）阻塞队列。**==\r\n\r\n\r\n\r\n### 9.4.3 DelayQueue\r\n\r\nDelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到\r\n\r\n该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的\r\n\r\n操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻\r\n\r\n塞。\r\n\r\n==**一句话总结: 使用优先级队列实现的延迟无界阻塞队列。**==\r\n\r\n\r\n\r\n### 9.4.4 PriorityBlockingQueue\r\n\r\n基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来\r\n\r\n决定），但需要注意的是 PriorityBlockingQueue 并**不会阻塞数据生产者，而**\r\n\r\n**只会在没有可消费的数据时，阻塞数据的消费者**。\r\n\r\n因此使用的时候要特别注意，**生产者生产数据的速度绝对不能快于消费者消费**\r\n\r\n**数据的速度**，否则时间一长，会最终耗尽所有的可用堆内存空间。\r\n\r\n在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是**公平锁**。\r\n\r\n==**一句话总结: 支持优先级排序的无界阻塞队列。**==\r\n\r\n\r\n\r\n### 9.4.5 SynchronousQueue\r\n\r\n一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产\r\n\r\n者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须\r\n\r\n亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么\r\n\r\n对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一\r\n\r\n个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经\r\n\r\n销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以\r\n\r\n库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式\r\n\r\n会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得\r\n\r\n产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能\r\n\r\n可能会降低。\r\n\r\n声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的\r\n\r\n行为。\r\n\r\n**公平模式和非公平模式的区别:**\r\n\r\n• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞\r\n\r\n多余的生产者和消费者，从而体系整体的公平策略；\r\n\r\n• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平\r\n\r\n锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，\r\n\r\n如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有\r\n\r\n某些生产者或者是消费者的数据永远都得不到处理。\r\n\r\n==**一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。**==\r\n\r\n\r\n\r\n### 9.4.6 LinkedTransferQueue\r\n\r\nLinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队\r\n\r\n列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和\r\n\r\ntransfer 方法。\r\n\r\nLinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如\r\n\r\n果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素\r\n\r\n为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时\r\n\r\n发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到\r\n\r\n该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的\r\n\r\n方法返回。\r\n\r\n==**一句话总结: 由链表组成的无界阻塞队列。**==\r\n\r\n\r\n\r\n### 9.4.7 LinkedBlockingDeque\r\n\r\nLinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队\r\n\r\n列的两端插入和移除元素。\r\n\r\n对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作\r\n\r\n可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情\r\n\r\n况\r\n\r\n• 插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时\r\n\r\n再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作\r\n\r\n失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异\r\n\r\n常\r\n\r\n• 读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可\r\n\r\n以通过设置超时参数\r\n\r\n==**一句话总结: 由链表组成的双向阻塞队列**==\r\n\r\n\r\n\r\n## 9.5 小结\r\n\r\n**1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件**\r\n\r\n**满足，被挂起的线程又会自动被唤起**\r\n\r\n**2. 为什么需要 BlockingQueue?** 在 concurrent 包发布以前，在多线程环境下，\r\n\r\n我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，\r\n\r\n而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要\r\n\r\n阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手\r\n\r\n包办了\r\n\r\n\r\n\r\n# 10 ThreadPool 线程池 \r\n\r\n\r\n\r\n## 10.1 线程池简介\r\n\r\n线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，\r\n\r\n进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理\r\n\r\n者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代\r\n\r\n价。线程池不仅能够保证内核的充分利用，还能防止过分调度。\r\n\r\n例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需\r\n\r\n要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换\r\n\r\n效率高。\r\n\r\n**线程池的优势：** 线程池做的工作只要是控制运行的线程数量，处理过程中将任\r\n\r\n务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，\r\n\r\n超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。\r\n\r\n**它的主要特点为：**\r\n\r\n• 降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。\r\n\r\n• 提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。\r\n\r\n• 提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资\r\n\r\n源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\r\n\r\n• **Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，**\r\n\r\n**ExecutorService，ThreadPoolExecutor这几个类**\r\n\r\n![image-20230711163322964](image/JUCBase.assets/image-20230711163322964.png)\r\n\r\n\r\n\r\n## 10.2 线程池参数说明\r\n\r\n\r\n\r\n### 10.2.1 常用参数(重点)\r\n\r\n• corePoolSize 线程池的核心线程数\r\n\r\n• maximumPoolSize 能容纳的最大线程数\r\n\r\n• keepAliveTime 空闲线程存活时间\r\n\r\n• unit 存活的时间单位\r\n\r\n• workQueue 存放提交但未执行任务的队列\r\n\r\n• threadFactory 创建线程的工厂类\r\n\r\n• handler 等待队列满后的拒绝策略\r\n\r\n线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线\r\n\r\n程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -\r\n\r\n最大线程数：\r\n\r\n当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻\r\n\r\n塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到\r\n\r\nmaximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池\r\n\r\n的拒绝策略了。\r\n\r\n总结起来，也就是一句话，**当提交的任务数大于（workQueue.size() +** \r\n\r\n**maximumPoolSize ），就会触发线程池的拒绝策略**。\r\n\r\n\r\n\r\n### 10.2.2 拒绝策略(重点)\r\n\r\n![image-20230711164218645](image/JUCBase.assets/image-20230711164218645.png)\r\n\r\n**AbortPolicy**: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常\r\n\r\n信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执\r\n\r\n行流程，影响后续的任务执行。\r\n\r\n**CallerRunsPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用\r\n\r\n线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由\r\n\r\n于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效\r\n\r\n率上必然的损失较大\r\n\r\n**DiscardOldestPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞\r\n\r\n队列 workQueue 中最老的一个任务，并将新任务加入\r\n\r\n**DiscardPolicy**: 直接丢弃，其他啥都没有\r\n\r\n\r\n\r\n## 10.3 线程池的常用种类\r\n\r\n### 10.3.1 newCachedThreadPool(常用)\r\n\r\n**作用**：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空\r\n\r\n闲线程，若无可回收，则新建线程.\r\n\r\n**特点**: \r\n\r\n• 线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）\r\n\r\n• 线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）\r\n\r\n• 当线程池中，没有可用线程，会重新创建一个线程\r\n\r\n\r\n\r\n**场景:** 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较\r\n\r\n短，任务多的场景\r\n\r\n\r\n\r\n### 10.3.2 newFixedThreadPool(常用)\r\n\r\n**作用**：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这\r\n\r\n些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线\r\n\r\n程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中\r\n\r\n等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线\r\n\r\n程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池\r\n\r\n中的线程将一直存在。\r\n\r\n**特征：**\r\n\r\n• 线程池中的线程处于一定的量，可以很好的控制线程的并发量\r\n\r\n• 线程可以重复被使用，在显示关闭之前，都将一直存在\r\n\r\n• 超出一定量的线程被提交时候需在队列中等待\r\n\r\n\r\n\r\n**场景:** 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严\r\n\r\n格限制的场景\r\n\r\n\r\n\r\n### 10.3.3 newSingleThreadExecutor(常用)\r\n\r\n**作用**：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该\r\n\r\n线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，\r\n\r\n那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各\r\n\r\n个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的\r\n\r\nnewFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即\r\n\r\n可使用其他的线程。\r\n\r\n**特征：** 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此\r\n\r\n执行\r\n\r\n**场景:** 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个\r\n\r\n线程的场景\r\n\r\n\r\n\r\n### 10.3.4 newScheduleThreadPool(了解)\r\n\r\n**作用:** 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参\r\n\r\n数，最大线程数为整形的最大数的线程池\r\n\r\n**特征:**\r\n\r\n（1）线程池中具有指定数量的线程，即便是空线程也将保留 \r\n\r\n（2）可定时或者延迟执行线程活动\r\n\r\n**场景:** 适用于需要多个后台线程执行周期任务的场景\r\n\r\n\r\n\r\n## 10.4 常用线程池入门案例\r\n\r\n**场景: 火车站 3 个售票口, 10 个用户买票**\r\n\r\n```java\r\n/**\r\n * 线程池      创建多线程的第四种办法\r\n */\r\npublic class ThreadPoolDemo {\r\n    //演示线程池三种常用分类\r\n    public static void main(String[] args) {\r\n\r\n        //一池五线程\r\n        ExecutorService threadPool1 = Executors.newFixedThreadPool(5);\r\n\r\n        //一池一线程\r\n        ExecutorService threadPool2 = Executors.newSingleThreadExecutor();\r\n\r\n        //一池可扩容线程\r\n        ExecutorService threadPool3 = Executors.newCachedThreadPool();\r\n\r\n        try {\r\n            //10个顾客请求\r\n            for (int i = 1; i <= 20; i++){\r\n                //执行\r\n                threadPool3.execute(() -> {\r\n                    System.out.println(Thread.currentThread().getName() + \" 办理事务\");\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            //关闭线程池\r\n            threadPool3.shutdown();\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 10.5 线程池底层工作原理(重要)\r\n\r\n![image-20230711164040893](image/JUCBase.assets/image-20230711164040893.png)\r\n\r\n1. 在创建了线程池后，线程池中的线程数为零\r\n\r\n2. 当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： 2.1 如\r\n\r\n果正在运行的线程数量**小于 corePoolSize，那么马上创建线程运行这个任务**；\r\n\r\n2.2 如果正在运行的线程数量**大于或等于 corePoolSize，那么将这个任务放入**\r\n\r\n**队列**； 2.3 如果这个时候**队列满了且正在运行的线程数量还小于**\r\n\r\n**maximumPoolSize，那么还是要创建非核心线程<font color=\'red\'>立刻</font>运行这个任务**； 2.4 如\r\n\r\n果**队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程**\r\n\r\n**池会启动饱和拒绝策略来执行**。（大于QueueSize + MaxPoolSize才拒绝）\r\n\r\n3. 当一个线程完成任务时，它会从队列中取下一个任务来执行\r\n\r\n4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：\r\n\r\n4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 4.2 \r\n\r\n所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\r\n\r\n\r\n\r\n## 10.6 自定义线程池(重要)\r\n\r\n1. 项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都\r\n\r\n有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用\r\n\r\nLinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，\r\n\r\n容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参\r\n\r\n数，自定义线程池\r\n\r\n2. 创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建\r\n\r\no corePoolSize 线程池的核心线程数\r\n\r\no maximumPoolSize 能容纳的最大线程数\r\n\r\no keepAliveTime 空闲线程存活时间\r\n\r\no unit 存活的时间单位\r\n\r\no workQueue 存放提交但未执行任务的队列\r\n\r\no threadFactory 创建线程的工厂类\r\n\r\no handler 等待队列满后的拒绝策略\r\n\r\n3. 为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图\r\n\r\n![image-20230711164326660](image/JUCBase.assets/image-20230711164326660.png)\r\n\r\n\r\n\r\n**自定义线程池案例：**\r\n\r\n```java\r\n/**\r\n * 自定义线程池\r\n * 开发中前面讲的三种线程池创建方式都不会用，会造成OOM\r\n * 所以一般使用自定义线程池\r\n    • corePoolSize 线程池的核心线程数\r\n\r\n    • maximumPoolSize 能容纳的最大线程数\r\n\r\n    • keepAliveTime 空闲线程存活时间\r\n\r\n    • unit 存活的时间单位\r\n\r\n    • workQueue 存放提交但未执行任务的队列\r\n\r\n    • threadFactory 创建线程的工厂类\r\n\r\n    • handler 等待队列满后的拒绝策略\r\n */\r\n//自定义线程池创建\r\npublic class ThreadPoolDemo2 {\r\n    public static void main(String[] args) {\r\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\r\n                2,\r\n                5,\r\n                3L,\r\n                TimeUnit.SECONDS,\r\n                new ArrayBlockingQueue<>(3),    //阻塞队列\r\n                Executors.defaultThreadFactory(),       //线程工厂\r\n                new ThreadPoolExecutor.AbortPolicy()    //拒绝策略\r\n        );\r\n\r\n        try {\r\n            //10个顾客请求\r\n            for (int i = 0; i < 10; i++) {\r\n                threadPool.execute(() -> {\r\n                    System.out.println(Thread.currentThread().getName() + \"办理事务\");\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            threadPool.shutdown();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 11 Fork/Join 分支合并框架\r\n\r\n\r\n\r\n## 11.1 Fork/Join 框架简介\r\n\r\nFork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子\r\n\r\n任务结果合并成最后的计算结果，并进行输出。Fork/Join 框架要完成两件事\r\n\r\n情：\r\n\r\n> **Fork：把一个复杂任务进行分拆，大事化小**\r\n\r\n> **Join：把分拆任务的结果进行合并**\r\n\r\n1. **任务分割**：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果\r\n\r\n子任务比较大的话还要对子任务进行继续分割\r\n\r\n2. **执行任务并合并结果**：分割的子任务分别放到双端队列里，然后几个启动线程\r\n\r\n分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，\r\n\r\n启动一个线程从队列里取数据，然后合并这些数据。\r\n\r\n在 Java 的 Fork/Join 框架中，使用两个类完成上述操作\r\n\r\n• **ForkJoinTask**:我们要使用 Fork/Join 框架，首先需要创建一个 ForkJoin 任务。\r\n\r\n该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集\r\n\r\n成 ForkJoinTask 类，只需要继承它的子类，Fork/Join 框架提供了两个子类：\r\n\r\n a.RecursiveAction：用于没有返回结果的任务\r\n\r\n b.RecursiveTask:用于有返回结果的任务\r\n\r\n• **ForkJoinPool**:ForkJoinTask 需要通过 ForkJoinPool 来执行\r\n\r\n• **RecursiveTask**: 继承后可以实现递归(自己调自己)调用的任务\r\n\r\n**Fork/Join 框架的实现原理**\r\n\r\nForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，\r\n\r\nForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而\r\n\r\nForkJoinWorkerThread 负责执行这些任务。\r\n\r\n\r\n\r\n## 11.2 任务拆分案例\r\n\r\n**Fork 方法的实现原理：** 当我们调用 ForkJoinTask 的 fork 方法时，程序会把\r\n\r\n任务放在 ForkJoinWorkerThread 的 pushTask 的 **workQueue** 中，异步地\r\n\r\n执行这个任务，然后立即返回结果\r\n\r\n\r\n\r\n递归任务：继承后可以实现递归（自己调自己）调用的任务\r\n\r\n**案例：**\r\n\r\n**场景: 生成一个计算任务，计算 1+2+3.........+1000**,**==每 100 个数切分一个**\r\n\r\n**子任务==**\r\n\r\n```java\r\n/**\r\n * 分支合并框架：任务拆分合并\r\n */\r\nclass MyTask extends RecursiveTask<Integer>{\r\n    //拆分差值不能超过10，计算10以内运算\r\n    private static final Integer VALUE = 10;\r\n    private int begin;//拆分开始值\r\n    private int end;//拆分结束值\r\n    private int result;\r\n\r\n    public MyTask(int begin, int end) {\r\n        this.begin = begin;\r\n        this.end = end;\r\n    }\r\n\r\n    //拆分和合并过程\r\n    @Override\r\n    protected Integer compute() {\r\n\r\n        //判断相加两个数值是否大于10\r\n        if ((end - begin) <= VALUE){\r\n            //相加操作\r\n            for (int i = begin; i <= end; i++) {\r\n                result = result + i;\r\n            }\r\n        }else {\r\n            //进一步拆分\r\n            //获取中间值\r\n            int middle = begin + (end - begin) / 2;\r\n            //拆分左边\r\n            MyTask task01 = new MyTask(begin,middle);\r\n            //拆分右边\r\n            MyTask task02 = new MyTask(middle+1,end);\r\n            //调用方法拆分\r\n            task01.fork();\r\n            task02.fork();\r\n            //合并结果\r\n            result = task01.join() + task02.join();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\npublic class ForkJoinDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        //创建MyTask对象\r\n        MyTask myTask = new MyTask(0,100);\r\n        //创建分支合并池对象\r\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\r\n        ForkJoinTask<Integer> forkJoinTask = forkJoinPool.submit(myTask);\r\n        //获取最终合并之后结果\r\n        Integer result = forkJoinTask.get();\r\n        System.out.println(result);\r\n        //关闭池对象\r\n        forkJoinPool.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 12 CompletableFuture\r\n\r\n\r\n\r\n## 12.1 CompletableFuture 简介\r\n\r\nCompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，\r\n\r\n可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可\r\n\r\n以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。\r\n\r\n\r\n\r\nCompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future\r\n\r\n接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程\r\n\r\n的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的\r\n\r\nCompletableFuture 类。\r\n\r\n\r\n\r\n## 12.2 Future 与 CompletableFuture\r\n\r\nFutrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提\r\n\r\n交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方\r\n\r\n法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获\r\n\r\n取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或\r\n\r\n者不断轮询才能知道任务是否完成。\r\n\r\n\r\n\r\n**Future 的主要缺点如下：**\r\n\r\n（1）不支持手动完成\r\n\r\n我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，\r\n\r\n现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直\r\n\r\n等待它执行完成\r\n\r\n（2）不支持进一步的非阻塞调用\r\n\r\n通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行\r\n\r\n额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能\r\n\r\n（3）不支持链式调用\r\n\r\n对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成\r\n\r\n一个链式的 pipline 调用，这在 Future 中是没法实现的。\r\n\r\n（4）不支持多个 Future 合并\r\n\r\n比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，\r\n\r\n执行某些函数，是没法通过 Future 实现的。\r\n\r\n（5）不支持异常处理\r\n\r\nFuture 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题\r\n\r\n是不好定位的。\r\n\r\n\r\n\r\n## 12.3 异步调用\r\n\r\n```java\r\n/**\r\n * 异步调用和同步调用\r\n */\r\npublic class CompletableFutureDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        //没有返回值的异步调用\r\n        CompletableFuture<Void> completableFuture1 = CompletableFuture.runAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"completableFuture1\");  \r\n        });\r\n        completableFuture1.get();\r\n        \r\n        //由返回值的异步调用\r\n        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"completableFuture2\");\r\n            //模拟异常\r\n            int i = 1/0;\r\n            return 1024;\r\n        });\r\n        completableFuture2.whenComplete((t,u) -> {\r\n            System.out.println(\"-------t=\" + t);\r\n            System.out.println(\"-------u=\" + u);\r\n        }).get();\r\n    }\r\n}\r\n```\r\n\r\n','image/JUCBase.assets/image-20230711003002637.png','原创',0,_binary '',_binary '',_binary '\0','2023-07-11 19:36:28','2023-07-22 22:01:20',2022576839,'JUC工具包的基础使用，构建JUC整体架构，包含synchronized、lock、Callable接口、线程池、JUC辅助类、读写锁、阻塞队列、分支合并、异步调用等的初步概念和初步使用',NULL,NULL,'0'),(1679024302076227586,'JVM运行时数据区（01）','[TOC]\r\n\r\n> 部分图片来源于网络\r\n\r\n# 前置知识-类的加载简单了解\r\n\r\n\r\n\r\n### 类的加载过程\r\n\r\n- 加载（Loading）：查找编译后该类对应的 .class文件，并对常量进行默认初始化赋值0\r\n- 链接（Linking）：\r\n  - 验证（Verify）：验证class文件是否符合当前虚拟机的要求\r\n  - 准备（Prepare）：为类变量分配内存并设置默认初始值0，并为常量进行显式赋值\r\n  - 解析（Resolve）：将常量池内的符号引用转换为直接引用的过程\r\n\r\n- 初始化（Initialization）：执行类构造器 clinit()方法的过程，对类变量初始化赋值\r\n\r\n\r\n\r\n### 类的加载器\r\n\r\n- 引导类/启动类 加载器Bootstrap ClassLoader：用c/c++编写，不继承于Classloader类，用于加载Java核心类库等，若要输出该类的对象，将会输出NULL\r\n- 扩展类加载器Extension ClassLoader：用Java编写，继承于Classloader类\r\n- 系统类加载器Application ClassLoader：用Java编写，继承于Classloader类，是默认的类加载器\r\n- 特殊的：自定义类加载器自己重写loadClass()或findClass()方法的加载器\r\n\r\n<font color=\'cornflowerblue\'>自定义类加载器的父类是系统类加载器</font>\r\n\r\n\r\n\r\n### 获取ClassLoader类对象的途径\r\n\r\n方式一：获取当前类的ClassLoader\r\nclazz.getClassLoader()\r\n方式二：获取当前线程上下文的ClassLoader\r\nThread.currentThread().getContextClassLoader()\r\n方式三：获取系统的ClassLoader\r\nClassLoader.getsystemClassLoader()\r\n方式四：获取调用者的ClassLoader\r\nDriverManager.getCallerClassLoader()\r\n\r\n\r\n\r\n### 双亲委派机制	\r\n\r\n![image-20230703163721280](image/JVMRuntimeDataArea1.assets/image-20230703163721280.png)\r\n\r\n**工作原理**\r\n\r\n- 1)如果一个类加载器收到了类加载请求，它并不会自已先去加载，而是把这个请求委托给父类的加载器去执行：\r\n- 2)如果父类加载器还存在其父类加载器则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器\r\n- 3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自已去加载，这就是双亲委派模式。\r\n\r\n\r\n\r\n**优势**\r\n\r\n- 避免类的重复加载\r\n- 保护程序安全，防止核心API被随意篡改\r\n  - 自定义类：java.lang.String\r\n  - 自定义类：java.lang.Shkstart\r\n\r\n举例：在自己的项目中写一个目录为Java.lang下的类String，当new这个自己写的String类时，逐层向上委托过后，最高层的启动类加载器可以执行该请求，故new的String类时核心类库中的String类，自己写的没有办法被new到，保护了API不被篡改（<font color=\'cornflowerblue\'>自己写的类都由Application ClassLoader加载</font>）\r\n\r\n\r\n\r\n### 类的主动使用和被动使用\r\n\r\nJava程序对类的使用方式分为：主动使用和被动使用。\r\n\r\n<font color=\'cornflowerblue\'>主动使用即会造成类的初始化（Initialization）</font>\r\n\r\n**主动使用**，又分为八种情况：\r\n\r\n1. 创建类的实例，包括new、反射、克隆、反序列化\r\n2. 访问某个类或接口的静态变量，或者对该静态变量赋值\r\n3. 调用类的静态方法\r\n4. 反射中使用Class.forName(\"com.atguigu.Test\")加载类时，会进行初始化2\r\n5. 初始化一个类的子类，但是不会初始化其实现的接口\r\n6. 若是一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化\r\n7. Java虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类，虚拟机会先初始化这个主类）\r\n8. JDK7开始提供的动态语言支持：\r\n\r\n     - java.lang.invoke.MethodHandle实例的解析结果，当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。\r\n\r\n\r\n     - REF_getstatic、REF_putStatic、REF_invokeStatic方法句柄对应的类没有初始化，则初始化\r\n\r\n\r\n<font color=\'red\'>只有类的主动使用，才会进行类的初始化，执行clinit()方法进行初始化赋值</font>\r\n\r\n\r\n\r\n除了以上八种情况，其他使用Java类的方式都被看作是对<font color=\'red\'>类的被动使用，都不会导致类的初始化</font>（<font color=\'cornflowerblue\'>即类的加载过程中的Initialization</font>）\r\n\r\n**被动使用**\r\n\r\n关于类的被动使用，即不会进行类的初始化操作，即不会调用clinit.>()\r\n\r\n1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。\r\n   - 当通过子类引用父类的静态变量，不会导致子类初始化\r\n2. 通过数组定义类引用，不会触发此类的初始化\r\n3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。\r\n4. 调用ClassLoader类的了loadcLass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\r\n   - ClassLoader.getSystemClassLoader().loadClass(\"com.spongehah.java.Person\")，该种反射加载类的方式并不会造成类的初始化\r\n\r\n# 运行时数据区（01）\r\n\r\n## 课程内容概览	\r\n\r\n**该部分包含：**\r\n\r\n- 程序计数器\r\n- 虚拟机栈\r\n- 本地方法栈\r\n\r\n\r\n\r\n# 基础知识了解\r\n\r\n\r\n\r\n## HotSpot虚拟机结构\r\n\r\n![image-20230703170639531](image/JVMRuntimeDataArea1.assets/image-20230703170639531.png)\r\n\r\n![image-20230703162327913](image/JVMRuntimeDataArea1.assets/image-20230703162327913.png)\r\n\r\n【HotSpot虚拟机结构图】\r\n\r\n当我们通过前面的：类的加载 --> 验证 --> 准备 --> 解析 --> 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区\r\n\r\nJava虚拟机定义了若千种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\r\n\r\n灰色的为单独线程私有的，红色的为多个线程共享的。即：\r\n\r\n- 每个线程：独立包括程序计数器、栈、本地栈\r\n- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）\r\n\r\n![image-20230703162256930](image/JVMRuntimeDataArea1.assets/image-20230703162256930.png)\r\n\r\n\r\n\r\n## 线程\r\n\r\n**JVM 线程**\r\n\r\n- 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行\r\n- **在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射**\r\n  - 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收\r\n- 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法\r\n\r\n\r\n\r\n**JVM系统线程**\r\n\r\n- 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用`public static void main(String[])`的main线程以及所有这个main线程自己创建的线程。\r\n\r\n- 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：\r\n\r\n  - **虚拟机线程**：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括\"stop-the-world\"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。\r\n\r\n  - **周期任务线程**：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。\r\n\r\n  - **GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。\r\n\r\n  - **编译线程**：这种线程在运行时会将字节码编译成到本地代码。\r\n\r\n  - **信号调度线程**：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。\r\n\r\n\r\n\r\n# 程序计数器PC Register\r\n\r\n![image-20230703163236435](image/JVMRuntimeDataArea1.assets/image-20230703163236435.png)\r\n\r\n【运行时数据区结构图】\r\n\r\n## PC寄存器介绍\r\n\r\nJVM中的程序计数寄存器(Program Counter Register)中，Reqister的命名源于CPU的寄存器，**寄存器存储指令相关的现场信息**，CPU只有把数据存储到寄存器才能够运行。\r\n\r\n这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<font color=\'red\'>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</font>\r\n\r\n- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。\r\n- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\r\n- 任何时间一个线程都只有一个方法在执行，也就是所调的<font color=\'red\'>当前方法</font>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)，本地方法的指令地址存储在本地方法栈中\r\n- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\r\n- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\r\n- 它是**唯一一个**在Java虚拟机规范中没有规定任何OutotMemoryError情况的区域。\r\n- <font color=\'red\'>PC Register没有GC和OOM</font>\r\n\r\n\r\n\r\n## PC寄存器作用\r\n\r\nPC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。\r\n\r\n![image-20230703171158679](image/JVMRuntimeDataArea1.assets/image-20230703171158679.png)\r\n\r\n\r\n\r\n## 举例\r\n\r\n```java\r\npublic class PCRegisterTest {\r\n\r\n    public static void main(String[] args) {\r\n        int i = 10;\r\n        int j = 20;\r\n        int k = i + j;\r\n\r\n        String s = \"abc\";\r\n        System.out.println(i);\r\n        System.out.println(k);\r\n\r\n    }\r\n}\r\n```\r\n\r\n查看字节码\r\n\r\n> 看字节码的方法：https://blog.csdn.net/21aspnet/article/details/88351875\r\n\r\n```java\r\nClassfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.class\r\n  Last modified 2020-11-2; size 675 bytes\r\n  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3\r\n  Compiled from \"PCRegisterTest.java\"\r\npublic class com.atguigu.java.PCRegisterTest\r\n  minor version: 0\r\n  major version: 52\r\n  flags: ACC_PUBLIC, ACC_SUPER\r\nConstant pool:\r\n   #1 = Methodref          #6.#26         // java/lang/Object.\"<init>\":()V\r\n   #2 = String             #27            // abc\r\n   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;\r\n   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V\r\n   #5 = Class              #32            // com/atguigu/java/PCRegisterTest\r\n   #6 = Class              #33            // java/lang/Object\r\n   #7 = Utf8               <init>\r\n   #8 = Utf8               ()V\r\n   #9 = Utf8               Code\r\n  #10 = Utf8               LineNumberTable\r\n  #11 = Utf8               LocalVariableTable\r\n  #12 = Utf8               this\r\n  #13 = Utf8               Lcom/atguigu/java/PCRegisterTest;\r\n  #14 = Utf8               main\r\n  #15 = Utf8               ([Ljava/lang/String;)V\r\n  #16 = Utf8               args\r\n  #17 = Utf8               [Ljava/lang/String;\r\n  #18 = Utf8               i\r\n  #19 = Utf8               I\r\n  #20 = Utf8               j\r\n  #21 = Utf8               k\r\n  #22 = Utf8               s\r\n  #23 = Utf8               Ljava/lang/String;\r\n  #24 = Utf8               SourceFile\r\n  #25 = Utf8               PCRegisterTest.java\r\n  #26 = NameAndType        #7:#8          // \"<init>\":()V\r\n  #27 = Utf8               abc\r\n  #28 = Class              #34            // java/lang/System\r\n  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;\r\n  #30 = Class              #37            // java/io/PrintStream\r\n  #31 = NameAndType        #38:#39        // println:(I)V\r\n  #32 = Utf8               com/atguigu/java/PCRegisterTest\r\n  #33 = Utf8               java/lang/Object\r\n  #34 = Utf8               java/lang/System\r\n  #35 = Utf8               out\r\n  #36 = Utf8               Ljava/io/PrintStream;\r\n  #37 = Utf8               java/io/PrintStream\r\n  #38 = Utf8               println\r\n  #39 = Utf8               (I)V\r\n{\r\n  public com.atguigu.java.PCRegisterTest();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=1, args_size=1\r\n         0: aload_0\r\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 7: 0\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       5     0  this   Lcom/atguigu/java/PCRegisterTest;\r\n\r\n  public static void main(java.lang.String[]);\r\n    descriptor: ([Ljava/lang/String;)V\r\n    flags: ACC_PUBLIC, ACC_STATIC\r\n    Code:\r\n      stack=2, locals=5, args_size=1\r\n         0: bipush        10\r\n         2: istore_1\r\n         3: bipush        20\r\n         5: istore_2\r\n         6: iload_1\r\n         7: iload_2\r\n         8: iadd\r\n         9: istore_3\r\n        10: ldc           #2                  // String abc\r\n        12: astore        4\r\n        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\r\n        17: iload_1\r\n        18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\r\n        21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\r\n        24: iload_3\r\n        25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V\r\n        28: return\r\n      LineNumberTable:\r\n        line 10: 0\r\n        line 11: 3\r\n        line 12: 6\r\n        line 14: 10\r\n        line 15: 14\r\n        line 16: 21\r\n        line 18: 28\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0      29     0  args   [Ljava/lang/String;\r\n            3      26     1     i   I\r\n            6      23     2     j   I\r\n           10      19     3     k   I\r\n           14      15     4     s   Ljava/lang/String;\r\n}\r\nSourceFile: \"PCRegisterTest.java\"\r\n```\r\n\r\n\r\n\r\n*   左边的数字代表**指令地址（指令偏移）**，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令\r\n\r\n![0009](image/JVMRuntimeDataArea1.assets/0009.png)\r\n\r\n\r\n\r\n## 两个面试题\r\n\r\n**使用PC寄存器存储字节码指令地址有什么用呢？**或者问**为什么使用 PC 寄存器来记录当前线程的执行地址呢？**\r\n\r\n1.  因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行\r\n  \r\n2.  JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令\r\n\r\n![0010](image/JVMRuntimeDataArea1.assets/0010.png)\r\n\r\n\r\n\r\n**PC寄存器为什么被设定为私有的？**\r\n\r\n1.  我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**<font color=\'red\'>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</font>**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。\r\n2.  由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。\r\n3.  这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。\r\n\r\n> 注意并行和并发的区别\r\n\r\n\r\n\r\n## CPU 时间片\r\n\r\n1.  CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。\r\n  \r\n2.  在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\r\n  \r\n3.  但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，**每个程序轮流执行**。\r\n\r\n![0011](image/JVMRuntimeDataArea1.assets/0011.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 虚拟机栈\r\n\r\n\r\n\r\n## 虚拟机栈基本内容\r\n\r\n<font color=\'red\'>首先栈是运行时的单位，而堆是存储的单位。</font>\r\n\r\n即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里\r\n\r\n![0001](image/JVMRuntimeDataArea1.assets/0001.png)\r\n\r\n\r\n\r\n\r\n\r\n- Java虚拟机栈是什么？\r\n  - Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。**每个线程在创建时都会创建一个虚拟机栈**，其内部**保存一个个的栈帧**（Stack Frame），**对应着一次次的Java方法调用**，栈是线程私有的\r\n- 虚拟机栈的生命周期\r\n  - **生命周期和线程一致**，也就是线程结束了，该虚拟机栈也销毁了\r\n\r\n- 虚拟机栈的作用\r\n\r\n  - 主管Java程序的运行，它保**存方法的局部变量**（8 种基本数据类型、对象的引用地址）、**部分结果**，并**参与方法的调用和返回**。\r\n\r\n  - 局部变量，它是相比于成员变量来说的（或属性）\r\n  - 基本数据类型变量 VS 引用类型变量（类、数组、接口）\r\n\r\n举例：\r\n\r\n```java\r\npublic class StackTest {\r\n\r\n    public static void main(String[] args) {\r\n        StackTest test = new StackTest();\r\n        test.methodA();\r\n    }\r\n\r\n    public void methodA() {\r\n        int i = 10;\r\n        int j = 20;\r\n\r\n        methodB();\r\n    }\r\n\r\n    public void methodB(){\r\n        int k = 30;\r\n        int m = 40;\r\n    }\r\n}\r\n```\r\n\r\n![0002](image/JVMRuntimeDataArea1.assets/0002.png)\r\n\r\n\r\n\r\n**虚拟机栈的特点**\r\n\r\n- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。\r\n\r\n- JVM直接对Java栈的操作只有两个：\r\n  - 每个方法执行，伴随着**进栈**（入栈、压栈）\r\n  - 执行结束后的**出栈**工作\r\n\r\n- 对于栈来说不存在垃圾回收问题\r\n  - <font color=\'red\'>栈不需要GC，但是可能存在OOM</font>\r\n  \r\n  \r\n\r\n**虚拟机栈的异常**\r\n\r\n**面试题：栈中可能出现的异常？**\r\n\r\n- Java 虚拟机规范允许Java栈的大小是<font color=\'cornflowerblue\'>动态</font>的或者是<font color=\'cornflowerblue\'>固定不变</font>的。\r\n\r\n  - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackoverflowError** 异常。\r\n\r\n  - 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 **OutofMemoryError** 异常。\r\n\r\n\r\n\r\n## 设置栈内存大小\r\n\r\n**概念**\r\n\r\n> 多去官方文档看看：https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE\r\n>\r\n> 地址经常变\r\n\r\n我们可以使用参数 **<font color=\'red\'>-Xss</font>** 选项来设置线程的**最大栈空间**，栈的大小直接决定了函数调用的最大可达深度。\r\n\r\n> Sets the thread stack size (in bytes). Append the letter `k` or `K` to indicate KB, `m` or `M` to indicate MB, and `g` or `G` to indicate GB. The default value depends on the platform:\r\n>\r\n> * Linux/x64 (64-bit): 1024 KB\r\n> * macOS (64-bit): 1024 KB\r\n> * Oracle Solaris/x64 (64-bit): 1024 KB\r\n> * Windows: The default value depends on virtual memory\r\n\r\n\r\n\r\nThe following examples set the thread stack size to 1024 KB in different units:\r\n\r\n```java\r\n-Xss1m\r\n-Xss1024k\r\n-Xss1048576\r\n```\r\n\r\n**举例**\r\n\r\n![0004](image/JVMRuntimeDataArea1.assets/0004-16890796567761.png)\r\n\r\n```java\r\npublic class StackErrorTest {\r\n    private static int count = 1;\r\n    public static void main(String[] args) {\r\n        System.out.println(count);\r\n        count++;\r\n        main(args);\r\n    }\r\n}\r\n```\r\n\r\n**没设置参数前**\r\n\r\n部分输出结果：\r\n\r\n```java\r\n11404\r\n11405\r\n11406\r\nException in thread \"main\" java.lang.StackOverflowError\r\n	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)\r\n```\r\n\r\n说明栈在11406这个深度溢出了\r\n\r\n\r\n\r\n**设置栈参数之后**\r\n\r\n\r\n\r\n部分输出结果\r\n\r\n```java\r\n2474\r\n2475\r\n2476\r\nException in thread \"main\" java.lang.StackOverflowError\r\n	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)\r\n```\r\n\r\n说明参数起作用了\r\n\r\n\r\n\r\n## 栈的存储单位-栈帧\r\n\r\n1.  每个线程都有自己的栈，栈中的数据都是以**<font color=\'red\'>栈帧</font>**（Stack Frame）的格式存在\r\n2.  在这个线程上正在执行的<font color=\'red\'>每个方法都各自对应一个栈帧</font>（Stack Frame）。\r\n3.  栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。\r\n\r\n\r\n\r\n### 栈运行原理\r\n\r\n1.  JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈和出栈**，遵循先进后出（后进先出）原则\r\n  \r\n2.  在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即**只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的**。这个栈帧被称为**<font color=\'cornflowerblue\'>当前栈帧</font>（Current Frame）**，与当前栈帧相对应的方法就是**<font color=\'cornflowerblue\'>当前方法</font>（Current Method）**，定义这个方法的类就是**<font color=\'cornflowerblue\'>当前类<（Current Class）**\r\n\r\n3.  执行引擎运行的所有字节码指令只针对当前栈帧进行操作。\r\n  \r\n4.  如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。\r\n\r\n![0005](image/JVMRuntimeDataArea1.assets/0005.png)\r\n\r\n1.  **不同线程中所包含的栈帧是不允许存在相互引用的**，即不可能在一个栈帧之中引用另外一个线程的栈帧。\r\n2.  如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。\r\n3.  Java方法有两种返回函数的方式。\r\n    - 一种是正常的函数返回，使用return指令。\r\n    - 另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。\r\n    - 但不管使用哪种方式，都会导致栈帧被弹出。\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 栈帧的内部结构\r\n\r\n每个栈帧中存储着：\r\n\r\n- <font color=\'red\'>局部变量表</font>（Local Variables）\r\n\r\n- <font color=\'red\'>操作数栈</font>（Operand Stack）（或<font color=\'red\'>表达式栈</font>）\r\n\r\n- 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）\r\n\r\n- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）\r\n\r\n- 一些附加信息\r\n\r\n![0006](image/JVMRuntimeDataArea1.assets/0006.png)\r\n\r\n并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的\r\n\r\n\r\n\r\n## 局部变量表\r\n\r\n\r\n\r\n**概念**\r\n\r\n1.  局部变量表也被称之为局部变量数组或本地变量表\r\n2.  **定义为一个<font color=\'red\'>数字数组</font>，主要用于<font color=\'red\'>存储方法参数和定义在方法体内的局部变量</font>**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。\r\n3.  由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**<font color=\'red\'>不存在数据安全问题</font>**\r\n4.  **局部变量表所需的容量<font color=\'red\'>大小是在编译期确定下来</font>的**，并保存在方法的Code属性的**maximum local variables**数据项中。在方法<font color=\'red\'>运行期间是不会改变局部变量表的大小</font>的。\r\n5.  方法嵌套调用的次数由栈的大小决定。一般来说，<font color=\'cornflowerblue\'>栈越大，方法嵌套调用次数越多</font>。（主要取决于局部变量表的大小）\r\n    *   对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。\r\n    *   进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。\r\n6.  <font color=\'cornflowerblue\'>局部变量表中的变量只在当前方法调用中有效</font>。\r\n    *   在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。\r\n    *   当方法调用结束后，<font color=\'cornflowerblue\'>随着方法栈帧的销毁，局部变量表也会随之销毁</font>。\r\n\r\n**举例**\r\n\r\n```java\r\npublic class LocalVariablesTest {\r\n    private int count = 0;\r\n\r\n    public static void main(String[] args) {\r\n        LocalVariablesTest test = new LocalVariablesTest();\r\n        int num = 10;\r\n        test.test1();\r\n    }\r\n\r\n    //练习：\r\n    public static void testStatic(){\r\n        LocalVariablesTest test = new LocalVariablesTest();\r\n        Date date = new Date();\r\n        int count = 10;\r\n        System.out.println(count);\r\n        //因为this变量不存在于当前方法的局部变量表中！！\r\n//        System.out.println(this.count);\r\n    }\r\n\r\n    //关于Slot的使用的理解\r\n    public LocalVariablesTest(){\r\n        this.count = 1;\r\n    }\r\n\r\n    public void test1() {\r\n        Date date = new Date();\r\n        String name1 = \"atguigu.com\";\r\n        test2(date, name1);\r\n        System.out.println(date + name1);\r\n    }\r\n\r\n    public String test2(Date dateP, String name2) {\r\n        dateP = null;\r\n        name2 = \"songhongkang\";\r\n        double weight = 130.5;//占据两个slot\r\n        char gender = \'男\';\r\n        return dateP + name2;\r\n    }\r\n\r\n    public void test3() {\r\n        this.count++;\r\n    }\r\n\r\n    public void test4() {\r\n        int a = 0;\r\n        {\r\n            int b = 0;\r\n            b = a + 1;\r\n        }\r\n        //变量c使用之前已经销毁的变量b占据的slot的位置\r\n        int c = a + 1;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。\r\n\r\n\r\n\r\n### Slot槽\r\n\r\n<font color=\'red\'>即局部变量表数组的每一个小格</font>\r\n\r\n1.  参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。\r\n2.  局部变量表，**<font color=\'red\'>最基本的存储单元是Slot（变量槽）</font>**，局部变量表中存放编译期可知的各种<font color=\'cornflowerblue\'>基本数据类型（8种），引用类型（reference），returnAddress类型的变量</font>。\r\n3.  在局部变量表里，**<font color=\'red\'>32位以内的类型只占用一个slot</font>**（包括returnAddress类型），**<font color=\'red\'>64位的类型占用两个slot</font>**（long和double）。\r\n    - byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true\r\n    - long和double则占据两个slot\r\n4.  JVM会为局部变量表中的每一个Slot都<font color=\'cornflowerblue\'>分配一个访问索引</font>，通过这个索引即可成功访问到局部变量表中指定的局部变量值\r\n5.  当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**<font color=\'red\'>按照顺序被复制</font>**到局部变量表中的每一个slot上\r\n6.  如果需要访问局部变量表中一个64bit的局部变量值时，<font color=\'red\'>只需要使用前一个索引即可</font>。（比如：访问long或double类型变量）\r\n7.  如果当前帧是由构造方法或者实例方法创建的，那么**<font color=\'red\'>该对象引用this将会存放在index为0的slot处</font>**，其余的参数按照参数表顺序继续排列。（this也相当于一个变量），<font color=\'red\'>**即非static方法，this将会被放在index0处**</font>\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0014.png)\r\n\r\n**Slot代码示例**\r\n\r\n**this 存放在 index = 0 的位置：**\r\n\r\n代码\r\n\r\n```java\r\n	public void test3() {\r\n        this.count++;\r\n    }\r\n```\r\n\r\n\r\n\r\n局部变量表：this 存放在 index = 0 的位置\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0015.png)\r\n\r\n\r\n\r\n**64位的类型（1ong和double）占用两个slot**\r\n\r\n代码\r\n\r\n```java\r\n 	public String test2(Date dateP, String name2) {\r\n        dateP = null;\r\n        name2 = \"songhongkang\";\r\n        double weight = 130.5;//占据两个slot\r\n        char gender = \'男\';\r\n        return dateP + name2;\r\n    }\r\n```\r\n\r\nweight 为 double 类型，index 直接从 3 蹦到了 5\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0016.png)\r\n\r\n\r\n\r\n**static 无法调用 this**\r\n\r\nthis 不存在与 static 方法的局部变量表中，所以无法调用\r\n\r\n```java\r\n    public static void testStatic(){\r\n        LocalVariablesTest test = new LocalVariablesTest();\r\n        Date date = new Date();\r\n        int count = 10;\r\n        System.out.println(count);\r\n        //因为this变量不存在于当前方法的局部变量表中！！\r\n//        System.out.println(this.count);\r\n    }\r\n```\r\n\r\n\r\n\r\n### Slot的重复利用\r\n\r\n栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\r\n\r\n\r\n\r\n代码\r\n\r\n```java\r\n    public void test4() {\r\n        int a = 0;\r\n        {\r\n            int b = 0;\r\n            b = a + 1;\r\n        }\r\n        //变量c使用之前已经出了作用域的变量b占据的slot的位置\r\n        int c = a + 1;\r\n    }\r\n```\r\n\r\n局部变量 c 重用了局部变量 b 的 slot 位置\r\n\r\n\r\n\r\n**举例：静态变量与局部变量的对比**\r\n\r\n\r\n\r\n```java\r\n变量的分类：\r\n1、按照数据类型分：① 基本数据类型  ② 引用数据类型\r\n2、按照在类中声明的位置分：\r\n  2-1、成员变量：在使用前，都经历过默认初始化赋值\r\n       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值\r\n              ---> initial阶段：给类变量显式赋值即静态代码块赋值\r\n       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值\r\n  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。\r\n```\r\n\r\n\r\n\r\n1.  参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。\r\n2.  我们知道<font color=\'cornflowerblue\'>类变量</font>有两次初始化的机会**，**第一次是在“<font color=\'red\'>准备阶段</font>”，执行系统初始化，对类变量设置零值，另一次则是在“<font color=\'red\'>初始化</font>”阶段，赋予程序员在代码中定义的初始值。\r\n3.  和类变量初始化不同的是，**局部变量表不存在系统初始化的过程**，这意味着一旦定义了<font color=\'red\'>局部变量则必须人为的初始化</font>，否则无法使用。\r\n\r\n```java\r\npublic void test()	{\r\n	int i;		//报错，因为局部变量必须显式赋值\r\n	System.out.println(i);\r\n}\r\n```\r\n\r\n\r\n\r\n### 补充说明\r\n\r\n1.  在栈帧中，<font color=\'cornflowerblue\'>与性能调优关系最为密切的部分就是前面提到的局部变量表</font>。在方法执行时，虚拟机使用局部变量表完成方法的传递。\r\n  \r\n2.  局部变量表中的变量也是重要的垃圾回收<font color=\'cornflowerblue\'>根节点</font>，<font color=\'red\'>只要被局部变量表中直接或间接引用的对象都不会被回收</font>。\r\n\r\n\r\n\r\n\r\n## 操作数栈\r\n\r\n### 操作数栈的特点\r\n\r\n1.  每一个独立的栈帧除了包含局部变量表以外，还包含一个<font color=\'red\'>后进先出</font>（Last - In - First -Out）的 操作数栈，也可以称之为**<font color=\'red\'>表达式栈</font>**（Expression Stack）\r\n  \r\n2.  操作数栈，在方法执行过程中，**根据字节码指令，往栈中写入数据或提取数据**，即入栈（push）和 出栈（pop）\r\n  - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，\r\n  - 比如：执行复制、交换、求和等操作\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0018.png)\r\n\r\n\r\n\r\n\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0019.png)\r\n\r\n\r\n\r\n### 操作数栈的作用\r\n\r\n\r\n\r\n1.  操作数栈，**<font color=\'red\'>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</font>**。\r\n  \r\n2.  操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。\r\n  \r\n3.  每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的<font color=\'red\'>最大深度在编译期就定义好了</font>，保存在方法的Code属性中，为**maxstack**的值。\r\n  \r\n4.  栈中的任何一个元素都是可以任意的Java数据类型\r\n  \r\n    *   32bit的类型占用一个栈单位深度\r\n    *   64bit的类型占用两个栈单位深度\r\n5.  操作数栈<font color=\'red\'>并非采用访问索引的方式来进行数据访问的</font>，而是只能通过标准的入栈和出栈操作来完成一次数据访问。\r\n  \r\n6.  <font color=\'red\'>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</font>，并更新PC寄存器中下一条需要执行的字节码指令。\r\n  \r\n7.  操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。\r\n  \r\n8.  另外，**我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈**。\r\n\r\n\r\n\r\n\r\n\r\n### 操作数栈代码追踪\r\n\r\n```java\r\n	public void testAddOperation() {\r\n        //byte、short、char、boolean：都以int型来保存\r\n        byte i = 15;\r\n        int j = 8;\r\n        int k = i + j;\r\n\r\n       // int m = 800;\r\n\r\n    }\r\n```\r\n\r\n对应字节码指令\r\n\r\n```java\r\n 0 bipush 15\r\n 2 istore_1\r\n 3 bipush 8\r\n 5 istore_2\r\n 6 iload_1\r\n 7 iload_2\r\n 8 iadd\r\n 9 istore_3\r\n10 return\r\n```\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0021.png)\r\n\r\n**一步一步看流程**\r\n\r\n1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0022.png)\r\n\r\n2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了\r\n\r\n*   解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0023.png)\r\n\r\n3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0024.png)\r\n\r\n\r\n\r\n4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作\r\n\r\niload_1：取出局部变量表中索引为1的数据入操作数栈\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0025.png)\r\n\r\n5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0026.png)\r\n\r\n\r\n\r\n**小问题**\r\n\r\n**关于类型转换的说明**\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0027.png)\r\n\r\n\r\n\r\n*   因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8\r\n*   但是存储在局部变量的时候，会转成 int 类型的变量：istore_4\r\n\r\n\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0028.png)\r\n\r\n- m改成800之后，byte存储不了，就成了short型，sipush 800\r\n\r\n\r\n\r\n\r\n\r\n**如果被调用的方法带有返回值，返回值入操作数栈**\r\n\r\n```java\r\n  public int getSum(){\r\n        int m = 10;\r\n        int n = 20;\r\n        int k = m + n;\r\n        return k;\r\n    }\r\n\r\n    public void testGetSum(){\r\n        //获取上一个栈桢返回的结果，并保存在操作数栈中\r\n        int i = getSum();\r\n        int j = 10;\r\n    }\r\n```\r\n\r\n\r\n\r\ngetSum() 方法字节码指令：最后带着个 ireturn\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0029.png)\r\n\r\ntestGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0030.png)\r\n\r\n\r\n\r\n\r\n\r\n### 栈顶缓存技术\r\n\r\n**栈顶缓存技术：Top Of Stack Cashing**\r\n\r\n1.  前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。\r\n  \r\n2.  由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**\r\n  \r\n3.  寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多\r\n\r\n\r\n\r\n\r\n## 动态链接\r\n\r\n**动态链接（或指向运行时常量池的方法引用）**\r\n\r\n1.  每一个栈帧内部都包含**<font color=\'red\'>一个指向运行时常量池中该栈帧所属方法的引用</font>**。包含这个引用的目的就是**为了支持当前方法的代码能够实现<font color=\'red\'>动态链接</font>**（Dynamic Linking），比如：invokedynamic指令\r\n  \r\n3.  在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**<font color=\'red\'>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</font>**\r\n\r\n\r\n\r\n![image-20230711214051104](image/JVMRuntimeDataArea1.assets/image-20230711214051104.png)\r\n\r\n\r\n\r\n**为什么要用常量池呢？**\r\n\r\n1.  因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。\r\n  \r\n2.  常量池的作用：就是为了提供一些符号和常量，便于指令的识别\r\n\r\n\r\n\r\n### 静态链接与动态链接\r\n\r\n在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关\r\n\r\n- **静态链接**：\r\n\r\n当一个字节码文件被装载进JVM内部时，如果被调用的<font color=\'cornflowerblue\'>目标方法在编译期确定，且运行期保持不变时</font>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接\r\n\r\n- **动态链接**：\r\n\r\n如果<font color=\'cornflowerblue\'>被调用的方法在编译期无法被确定下</font>来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。（<font color=\'red\'>如多态的使用和lamda表达式</font>）\r\n\r\n\r\n\r\n### 早期绑定与晚期绑定\r\n\r\n> 静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。\r\n\r\n静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程**，这仅仅发生一次。\r\n\r\n- **早期绑定**\r\n\r\n早期绑定就是指被调用的目标方法如果在<font color=\'cornflowerblue\'>编译期可知，且运行期保持不变时</font>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就**可以使用静态链接的方式将符号引用转换为直接引用**。\r\n\r\n- **晚期绑定**\r\n\r\n如果被调用的方法<font color=\'cornflowerblue\'>在编译期无法被确定下来</font>，**只能够在程序运行期根据实际的类型绑定相关的方法**，这种绑定方式也就被称之为晚期绑定。\r\n\r\n\r\n\r\n```java\r\nclass Animal {\r\n\r\n    public void eat() {\r\n        System.out.println(\"动物进食\");\r\n    }\r\n}\r\n\r\ninterface Huntable {\r\n    void hunt();\r\n}\r\n\r\nclass Dog extends Animal implements Huntable {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"狗吃骨头\");\r\n    }\r\n\r\n    @Override\r\n    public void hunt() {\r\n        System.out.println(\"捕食耗子，多管闲事\");\r\n    }\r\n}\r\n\r\nclass Cat extends Animal implements Huntable {\r\n\r\n    public Cat() {\r\n        super();//表现为：早期绑定\r\n    }\r\n\r\n    public Cat(String name) {\r\n        this();//表现为：早期绑定\r\n    }\r\n\r\n    @Override\r\n    public void eat() {\r\n        super.eat();//表现为：早期绑定\r\n        System.out.println(\"猫吃鱼\");\r\n    }\r\n\r\n    @Override\r\n    public void hunt() {\r\n        System.out.println(\"捕食耗子，天经地义\");\r\n    }\r\n}\r\n\r\npublic class AnimalTest {\r\n    public void showAnimal(Animal animal) {\r\n        animal.eat();//表现为：晚期绑定\r\n    }\r\n\r\n    public void showHunt(Huntable h) {\r\n        h.hunt();//表现为：晚期绑定\r\n    }\r\n}\r\n\r\n```\r\n\r\n部分字节码\r\n\r\n```java\r\n{\r\n  public com.atguigu.java2.AnimalTest();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=1, args_size=1\r\n         0: aload_0\r\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 54: 0\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       5     0  this   Lcom/atguigu/java2/AnimalTest;\r\n\r\n  public void showAnimal(com.atguigu.java2.Animal);\r\n    descriptor: (Lcom/atguigu/java2/Animal;)V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=2, args_size=2\r\n         0: aload_1\r\n         1: invokevirtual #2                  // Method com/atguigu/java2/Animal.eat:()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 56: 0\r\n        line 57: 4\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       5     0  this   Lcom/atguigu/java2/AnimalTest;\r\n            0       5     1 animal   Lcom/atguigu/java2/Animal;\r\n\r\n  public void showHunt(com.atguigu.java2.Huntable);\r\n    descriptor: (Lcom/atguigu/java2/Huntable;)V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=2, args_size=2\r\n         0: aload_1\r\n         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V\r\n         6: return\r\n      LineNumberTable:\r\n        line 60: 0\r\n        line 61: 6\r\n      LocalVariableTable:\r\n        Start  Length  Slot  Name   Signature\r\n            0       7     0  this   Lcom/atguigu/java2/AnimalTest;\r\n            0       7     1     h   Lcom/atguigu/java2/Huntable;\r\n}\r\nSourceFile: \"AnimalTest.java\"\r\n```\r\n\r\n\r\n\r\ninvokevirtual 体现为晚期绑定\r\n\r\ninvokeinterface 也体现为晚期绑定\r\n\r\ninvokespecial 体现为早期绑定\r\n\r\n\r\n\r\n\r\n### 虚方法与非虚方法\r\n\r\n**虚方法与非虚方法的区别**\r\n\r\n1.  如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。\r\n2.  <font color=\'red\'>静态方法、私有方法、final方法、实例构造器、父类方法</font>都是非虚方法。\r\n3.  其他方法称为虚方法。\r\n\r\n\r\n\r\n**子类对象的多态的使用前提：**\r\n\r\n1.  类的继承关系\r\n2.  方法的重写\r\n\r\n\r\n\r\n**虚拟机中调用方法的指令**\r\n\r\n- **普通指令：**\r\n\r\n1.  invokestatic：调用静态方法，解析阶段确定唯一方法版本\r\n2.  invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本             <font color=\'cornflowerblue\'>1和2是非虚方法</font>\r\n3.  invokevirtual：调用所有虚方法\r\n4.  invokeinterface：调用接口方法            <font color=\'cornflowerblue\'> 3和4除final修饰的方法，都是虚方法</font>\r\n\r\n- **动态调用指令**\r\n\r\ninvokedynamic：动态解析出需要调用的方法，然后执行            <font color=\'cornflowerblue\'>虚方法</font>\r\n\r\n\r\n\r\n前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。<font color=\'red\'>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</font>\r\n\r\n\r\n\r\n**举例**\r\n\r\n```java\r\nclass Father {\r\n    public Father() {\r\n        System.out.println(\"father的构造器\");\r\n    }\r\n\r\n    public static void showStatic(String str) {\r\n        System.out.println(\"father \" + str);\r\n    }\r\n\r\n    public final void showFinal() {\r\n        System.out.println(\"father show final\");\r\n    }\r\n\r\n    public void showCommon() {\r\n        System.out.println(\"father 普通方法\");\r\n    }\r\n}\r\n\r\npublic class Son extends Father {\r\n    public Son() {\r\n        //invokespecial\r\n        super();\r\n    }\r\n\r\n    public Son(int age) {\r\n        //invokespecial\r\n        this();\r\n    }\r\n\r\n    //不是重写的父类的静态方法，因为静态方法不能被重写！\r\n    public static void showStatic(String str) {\r\n        System.out.println(\"son \" + str);\r\n    }\r\n\r\n    private void showPrivate(String str) {\r\n        System.out.println(\"son private\" + str);\r\n    }\r\n\r\n    public void show() {\r\n        //invokestatic\r\n        showStatic(\"atguigu.com\");\r\n        //invokestatic\r\n        super.showStatic(\"good!\");\r\n        //invokespecial\r\n        showPrivate(\"hello!\");\r\n        //invokespecial\r\n        super.showCommon();\r\n\r\n        //invokevirtual\r\n        showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。\r\n        //虚方法如下：\r\n        \r\n        /*\r\n        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也会认为)，所以编译期间确定不下来，就是虚方法。\r\n        */\r\n        showCommon();\r\n        info();\r\n\r\n        MethodInterface in = null;\r\n        //invokeinterface\r\n        in.methodA();\r\n    }\r\n\r\n    public void info() {\r\n\r\n    }\r\n\r\n    public void display(Father f) {\r\n        f.showCommon();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Son so = new Son();\r\n        so.show();\r\n    }\r\n}\r\n\r\ninterface MethodInterface {\r\n    void methodA();\r\n}\r\n```\r\n\r\nSon 类中 show() 方法的字节码指令如下\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0032.png)\r\n\r\n\r\n\r\n**关于 invokedynamic 指令**\r\n\r\n1.  JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<font color=\'red\'>Java为了实现【动态类型语言】支持而做的一种改进</font>。\r\n  \r\n2.  但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到<font color=\'red\'>Java8的Lambda表达式的出现，invokedynamic指令的生成</font>，在Java中才有了直接的生成方式。\r\n  \r\n3.  Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。\r\n\r\n\r\n```java\r\n@FunctionalInterface\r\ninterface Func {\r\n    public boolean func(String str);\r\n}\r\n\r\npublic class Lambda {\r\n    public void lambda(Func func) {\r\n        return;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Lambda lambda = new Lambda();\r\n\r\n        Func func = s -> {\r\n            return true;\r\n        };\r\n\r\n        lambda.lambda(func);\r\n\r\n        lambda.lambda(s -> {\r\n            return true;\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**动态语言和静态语言**\r\n\r\n1.  动态类型语言和静态类型语言两者的区别就在于**对类型的检查是在编译期还是在运行期**，满足前者就是静态类型语言，反之是动态类型语言。\r\n  \r\n2.  说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。\r\n\r\nJava：String info = \"mogu blog\";     		(Java是静态类型语言的，会先编译就进行类型检查)\r\n    JS：var name = \"shkstart\";    var name = 10;	（运行时才进行检查）\r\n    \r\n\r\n    Python: info = 130.5 (运行时才检查)\r\n\r\n\r\n\r\n### 虚方法表\r\n\r\n\r\n\r\n1.  在面向对象的编程中，会很频繁的使用到**动态分派**，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<font color=\'cornflowerblue\'>为了提高性能</font>，**JVM采用在类的<font color=\'red\'>方法区建立一个虚方法表</font>（virtual method table）来实现**，<font color=\'red\'>非虚方法不会出现在表中</font>。<font color=\'red\'>使用索引表来代替查找</font>。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】\r\n  \r\n3.  <font color=\'cornflowerblue\'>每个类中都有一个虚方法表</font>，表中存放着各个方法的实际入口。\r\n  \r\n4.  虚方法表是什么时候被创建的呢？虚方法表会在<font color=\'cornflowerblue\'>类加载的链接阶段被创建并开始初始化</font>，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。（<font color=\'cornflowerblue\'>类的准备阶段完成后成表</font>）\r\n\r\n  \r\n\r\n**例子**\r\n\r\n如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0034.png)\r\n\r\n1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。\r\n\r\n2、下次Son对象再调用toString就直接去找Object，不用先找Son-->再找Father-->最后才到Object的这样的一个过程。\r\n\r\n\r\n\r\n## 方法返回地址\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0039.png)\r\n\r\n> 在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区\r\n\r\n1.  存放<font color=\'red\'>调用该方法的pc寄存器的值</font>。一个方法的结束，有两种方式：\r\n  \r\n    *   正常执行完成\r\n    *   出现未处理的异常，非正常退出\r\n2.  无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**<font color=\'red\'>调用者（即外层方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</font>**。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。\r\n3.  本质上，方法的退出就是当前<font color=\'cornflowerblue\'>栈帧出栈</font>的过程。此时，需要<font color=\'red\'>恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值</font>等，让**调用者方法继续执行下去**。\r\n4.  正常完成出口和异常完成出口的区别在于：<font color=\'red\'>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</font>\r\n\r\n\r\n\r\n\r\n**方法退出的两种方式**\r\n\r\n当一个方法开始执行后，只有两种方式可以退出这个方法，\r\n\r\n**正常退出：**\r\n\r\n1.  执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称**正常完成出口**；\r\n2.  一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。\r\n3. 在字节码指令中，返回指令包含：\r\n    - ireturn：当返回值是boolean，byte，char，short和int类型时使用\r\n\r\n    - lreturn：Long类型\r\n\r\n    - freturn：Float类型\r\n\r\n    - dreturn：Double类型\r\n\r\n    - areturn：引用类型\r\n\r\n    - return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法\r\n\r\n\r\n\r\n**异常退出：**\r\n\r\n1.  在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称**异常完成出口**。\r\n  \r\n2.  方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码\r\n\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0040.png)\r\n\r\n\r\n\r\n异常处理表：\r\n\r\n*   反编译字节码文件，可得到 Exception table\r\n*   from ：字节码指令起始地址\r\n*   to ：字节码指令结束地址\r\n*   target ：出现异常跳转至地址为 11 的指令执行\r\n*   type ：捕获异常的类型\r\n\r\n![](image/JVMRuntimeDataArea1.assets/0041.png)\r\n\r\n\r\n\r\n## 一些附加信息\r\n\r\n栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。\r\n\r\n\r\n\r\n## 栈相关面试题\r\n\r\n**举例栈溢出的情况？**\r\n\r\nSOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM\r\n\r\n\r\n\r\n**调整栈大小，就能保证不出现溢出么？**\r\n\r\n不能保证不溢出，只能保证SOF出现的几率小\r\n\r\n\r\n\r\n**分配的栈内存越大越好么？**\r\n\r\n不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的\r\n\r\n\r\n\r\n**垃圾回收是否涉及到虚拟机栈？**\r\n\r\n不会\r\n\r\n\r\n\r\n| 位置                                        | 是否有Error  | 是否存在GC |\r\n| ------------------------------------------- | ------------ | ---------- |\r\n| PC计数器                                    | 无           | 不存在     |\r\n| 虚拟机栈                                    | 有，SOF、OOM | 不存在     |\r\n| 本地方法栈(在HotSpot的实现中和虚拟机栈一样) |              |            |\r\n| 堆                                          | 有，OOM      | 存在       |\r\n| 方法区                                      | 有           | 存在       |\r\n\r\n\r\n\r\n**方法中定义的局部变量是否线程安全？**\r\n\r\n具体问题具体分析\r\n\r\n1.  如果只有一个线程才可以操作此数据，则必是线程安全的。\r\n2.  如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。\r\n\r\n**具体问题具体分析：**\r\n\r\n* 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。\r\n\r\n    \r\n\r\n\r\n```java\r\n/**\r\n * 面试题：\r\n * 方法中定义的局部变量是否线程安全？具体情况具体分析\r\n *\r\n *   何为线程安全？\r\n *      如果只有一个线程才可以操作此数据，则必是线程安全的。\r\n *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。\r\n */\r\npublic class StringBuilderTest {\r\n\r\n    int num = 10;\r\n\r\n    //s1的声明方式是线程安全的（只在方法内部用了）\r\n    public static void method1(){\r\n        //StringBuilder:线程不安全\r\n        StringBuilder s1 = new StringBuilder();\r\n        s1.append(\"a\");\r\n        s1.append(\"b\");\r\n        //...\r\n    }\r\n    //sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）\r\n    public static void method2(StringBuilder sBuilder){\r\n        sBuilder.append(\"a\");\r\n        sBuilder.append(\"b\");\r\n        //...\r\n    }\r\n    //s1的操作：方法内部是线程安全的，外部是不安全的（有返回值，可能被其它线程操作）\r\n    public static StringBuilder method3(){\r\n        StringBuilder s1 = new StringBuilder();\r\n        s1.append(\"a\");\r\n        s1.append(\"b\");\r\n        return s1;\r\n    }\r\n    //s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）\r\n    public static String method4(){\r\n        StringBuilder s1 = new StringBuilder();\r\n        s1.append(\"a\");\r\n        s1.append(\"b\");\r\n        return s1.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        StringBuilder s = new StringBuilder();\r\n\r\n        new Thread(() -> {\r\n            s.append(\"a\");\r\n            s.append(\"b\");\r\n        }).start();\r\n\r\n        method2(s);\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 本地方法接口\r\n\r\n## 本地方法\r\n\r\n\r\n\r\n1. 简单地讲，**<font color=\'cornflowerblue\'>一个Native Method是一个Java调用非Java代码的接囗</font>**一个Native Method是这样一个Java方法：\r\n1. <font color=\'cornflowerblue\'>该方法的实现由非Java语言实现</font>，比如<font color=\'cornflowerblue\'>**C**</font>。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。\r\n4. “A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）\r\n5. 在定义<font color=\'cornflowerblue\'>一个native method时，并不提供实现体（不提供并非没有）</font>（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\r\n6. 本地接口的作用是融合不同的编程语言为Java所用，它的<font color=\'cornflowerblue\'>初衷是融合C/C++程序</font>。\r\n\r\n\r\n\r\n**举例**\r\n\r\n需要注意的是：<font color=\'red\'>标识符native可以与其它java标识符连用，但是abstract除外</font>\r\n\r\n```java\r\npublic class IHaveNatives {\r\n    public native void Native1(int x);\r\n\r\n    public native static long Native2();\r\n\r\n    private native synchronized float Native3(Object o);\r\n\r\n    native void Native4(int[] ary) throws Exception;\r\n}\r\n```\r\n\r\n\r\n\r\n**为什么要使用 Native Method？**\r\n\r\nJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\r\n\r\n\r\n\r\n- **与Java环境外交互**\r\n\r\n**有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因**。你可以想想Java需要与一些**底层系统**，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。\r\n\r\n\r\n\r\n- **与操作系统的交互**\r\n\r\n1. JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。\r\n2. 然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。\r\n3. **通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的**。\r\n4. 还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\r\n\r\n\r\n\r\n- **Sun’s Java**\r\n\r\n1. Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。\r\n2. 例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。\r\n\r\n\r\n\r\n**本地方法的现状**\r\n\r\n目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。\r\n\r\n1. 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。\r\n   * <font color=\'red\'>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</font>\r\n   * <font color=\'red\'>它甚至可以直苦使处理器中的寄存器</font>\r\n   * <font color=\'red\'>直接从本地内存的堆中分配任意数量的内存。</font>\r\n   * <font color=\'cornflowerblue\'>本地方法栈通过本地方法接口访问运行时数据区</font>\r\n2. 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。\r\n3. 在Hotspot JVM中支持，并且直接将木地方法栈和虚拟机栈合二为一。\r\n\r\n\r\n\r\n## 本地方法栈\r\n\r\n1. **Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**。\r\n2. 本地方法栈，**也是线程私有的**。\r\n3. 允许被实现成**固定**或者是可**动态扩展**的内存大小（在内存溢出方面和虚拟机栈相同）\r\n   * 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。\r\n   * 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。\r\n4. 本地方法一般是使用C语言或C++语言实现的。\r\n5. 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nPC Register没有GC和OOM\r\n\r\nJava栈没有GC，有OOM\r\n\r\n本地方法栈没有GC，有OOM\r\n','image/JVMRuntimeDataArea1.assets/image-20230703162327913.png','原创',3,_binary '',_binary '',_binary '\0','2023-07-12 15:06:03',NULL,2022576839,'JVM内存-运行时数据区部分01篇，包含程序计数器、虚拟机栈和本地方法栈的相关知识',NULL,NULL,'0'),(1679025014147411970,'JVM运行时数据区（02）','[TOC]\r\n\r\n# 运行时数据区（02）\r\n\r\n## 课程内容概览\r\n\r\n**该部分包含：**\r\n\r\n- 堆\r\n\r\n\r\n\r\n# 堆\r\n\r\n堆的核心概述\r\n--------\r\n\r\n### 堆与进程\r\n\r\n\r\n\r\n1.  堆针对一个JVM进程来说是唯一的。也就是**一个进程只有一个JVM实例**，一个JVM实例中就有一个运行时数据区，**一个运行时数据区只有一个堆和一个方法区**。\r\n2.  但是**进程包含多个线程，他们是<font color=\'red\'>共享同一堆空间</font>的**。\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0001.png)\r\n\r\n\r\n\r\n1.  一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。\r\n2.  Java堆区在<font color=\'red\'>JVM启动的时候即被创建</font>，其空间大小也就确定了，堆是JVM管理的<font color=\'red\'>最大一块内存空间</font>，并且<font color=\'red\'>堆内存的大小是可以调节</font>的。\r\n3.  《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\r\n4.  所有的线程共享Java堆，在这里还<font color=\'red\'>可以划分**线程私有**的缓冲区</font>（Thread Local Allocation Buffer，**<font color=\'red\'>TLAB</font>**）。\r\n5.  《Java虚拟机规范》中对Java堆的描述是：**<font color=\'red\'>所有的对象实例以及数组都应当在运行时分配在堆上</font>**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）(<font color=\'cornflowerblue\'>因为HotSpot虚拟机不采取栈上分配</font>)\r\n    - 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）\r\n6.  <font color=\'cornflowerblue\'>数组和对象**可能**永远不会存储在栈上</font>（**不一定，逃逸分析的时候**），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\r\n7.  在<font color=\'red\'>方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</font>。\r\n\r\n    *   也就是触发了GC的时候，才会进行回收\r\n    *   如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word\r\n8.  堆，<font color=\'red\'>是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域</font>。\r\n\r\n> 随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。\r\n\r\n```java\r\npublic class SimpleHeap {\r\n    private int id;//属性、成员变量\r\n\r\n    public SimpleHeap(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(\"My ID is \" + id);\r\n    }\r\n    public static void main(String[] args) {\r\n        SimpleHeap sl = new SimpleHeap(1);\r\n        SimpleHeap s2 = new SimpleHeap(2);\r\n\r\n        int[] arr = new int[10];\r\n\r\n        Object[] arr1 = new Object[10];\r\n    }\r\n}\r\n```\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0002.png)\r\n\r\n\r\n\r\n### 堆内存细分\r\n\r\n现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：\r\n\r\n1.  <font color=\'cornflowerblue\'>Java7 </font>及之前堆内存逻辑上分为三部分：<font color=\'red\'>新生区+养老区+**永久区**</font>\r\n    *   Young Generation Space    新生区      Young/New\r\n        *   又被划分为Eden区和Survivor区\r\n    *   Old generation space    养老区           Old/Tenure\r\n    *   Permanent Space   永久区                   Perm\r\n2.  <font color=\'cornflowerblue\'>Java 8</font>及之后堆内存逻辑上分为三部分：<font color=\'red\'>新生区+养老区+**元空间**</font>\r\n    *   Young Generation Space <font color=\'red\'>新生区，又被划分为Eden区和Survivor区</font>\r\n    *   Old generation space 养老区\r\n    *   Meta Space 元空间 Meta\r\n\r\n约定：新生区 <–> 新生代 <–> 年轻代 、 养老区 <–> 老年区 <–> 老年代、 永久区 <–\\> 永久代\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0003.png)\r\n\r\n\r\n\r\n2.  堆空间内部结构，JDK1.8之前从永久代 替换成 <font color=\'red\'>元空间（元空间不适用JVM内存）</font>\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0004.png)\r\n\r\n\r\n\r\n## JVisualVM可视化查看堆内存\r\n\r\n运行下面代码\r\n\r\n```java\r\npublic class HeapDemo {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"start...\");\r\n        try {\r\n            TimeUnit.MINUTES.sleep(30);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(\"end...\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n1、双击jdk目录下的这个文件\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0005.png)\r\n\r\n\r\n\r\n2、工具 -> 插件 -> 安装Visual GC插件\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0006.png)\r\n\r\n3、运行上面的代码\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0007.png)\r\n\r\n\r\n\r\n设置堆内存大小与 OOM\r\n--------------\r\n\r\n### 设置堆内存\r\n\r\n\r\n\r\n1.  Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项\"-Xms\"和\"-Xmx\"来进行设置。\r\n  \r\n    *   **<font color=\'red\'>-Xms</font>**用于表示**堆区的起始内存**，等价于**-XX:InitialHeapSize**\r\n    *   **<font color=\'red\'>-Xmx</font>**则用于表示**堆区的最大内存**，等价于**-XX:MaxHeapSize**\r\n2.  一旦堆区中的内存大小超过“-Xmx\"所指定的最大内存时，将会抛出OutofMemoryError异常。\r\n3.  <font color=\'red\'>通常会将-Xms和-Xmx两个参数配置相同的值</font>（<font color=\'cornflowerblue\'>其目的是为了能够在java垃圾回收机制清理完成堆区后不需要重新分隔计算堆区的大小</font>）\r\n\r\n  - 解释：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。\r\n  - 如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM\r\n4.  默认情况下:\r\n\r\n    *   **初始内存大小：物理电脑内存大小/64**\r\n    *   **最大内存大小：物理电脑内存大小/4**\r\n\r\n\r\n\r\n```java\r\n/**\r\n * 1. 设置堆空间大小的参数\r\n * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小\r\n *      -X 是jvm的运行参数\r\n *      ms 是memory start\r\n * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小\r\n *\r\n * 2. 默认堆空间的大小\r\n *    初始内存大小：物理电脑内存大小 / 64\r\n *             最大内存大小：物理电脑内存大小 / 4\r\n * 3. 手动设置：-Xms600m -Xmx600m\r\n *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。\r\n *\r\n * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id\r\n *                  方式二：-XX:+PrintGCDetails\r\n */\r\npublic class HeapSpaceInitial {\r\n    public static void main(String[] args) {\r\n\r\n        //返回Java虚拟机中的堆内存总量\r\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\r\n        //返回Java虚拟机试图使用的最大堆内存量\r\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\r\n\r\n        System.out.println(\"-Xms : \" + initialMemory + \"M\");\r\n        System.out.println(\"-Xmx : \" + maxMemory + \"M\");\r\n\r\n        System.out.println(\"系统内存大小为：\" + initialMemory * 64.0 / 1024 + \"G\");\r\n        System.out.println(\"系统内存大小为：\" + maxMemory * 4.0 / 1024 + \"G\");\r\n\r\n        try {\r\n            Thread.sleep(1000000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出结果：\r\n\r\n```java\r\n-Xms : 123M\r\n-Xmx : 1794M\r\n系统内存大小为：7.6875G\r\n系统内存大小为：7.0078125G\r\n```\r\n\r\n1、笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些。\r\n\r\n2、两个不一样的原因待会再说\r\n\r\n\r\n\r\n设置下参数再看\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0008.png)\r\n\r\n```java\r\npublic class HeapSpaceInitial {\r\n    public static void main(String[] args) {\r\n\r\n        //返回Java虚拟机中的堆内存总量\r\n        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;\r\n        //返回Java虚拟机试图使用的最大堆内存量\r\n        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;\r\n\r\n        System.out.println(\"-Xms : \" + initialMemory + \"M\");\r\n        System.out.println(\"-Xmx : \" + maxMemory + \"M\");\r\n\r\n\r\n        try {\r\n            Thread.sleep(1000000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出结果：\r\n\r\n```java\r\n-Xms : 575M\r\n-Xmx : 575M\r\n```\r\n\r\n为什么会少25M\r\n\r\n**方式一： jps   /  jstat -gc 进程id**\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0009.png)\r\n\r\n> jps：查看java进程\r\n>\r\n> jstat：查看某进程内存使用情况\r\n\r\n```java\r\nSOC: S0区总共容量\r\nS1C: S1区总共容量\r\nS0U: S0区使用的量\r\nS1U: S1区使用的量\r\nEC: 伊甸园区总共容量\r\nEU: 伊甸园区使用的量\r\nOC: 老年代总共容量\r\nOU: 老年代使用的量\r\n```\r\n\r\n1、\r\n\r\n25600+25600+153600+409600 = 614400K\r\n\r\n614400 /1024 = 600M\r\n\r\n2、\r\n\r\n25600+153600+409600 = 588800K\r\n\r\n588800 /1024 = 575M\r\n\r\n3、\r\n\r\n并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）\r\n\r\n<font color=\'red\'>即S区只计算一个的值</font>\r\n\r\n **方式二：-XX:+PrintGCDetails**\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0010.png)\r\n\r\n\r\n\r\n### OOM\r\n\r\n```java\r\npublic class OOMTest {\r\n    public static void main(String[] args) {\r\n        ArrayList<Picture> list = new ArrayList<>();\r\n        while(true){\r\n            try {\r\n                Thread.sleep(20);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            list.add(new Picture(new Random().nextInt(1024 * 1024)));\r\n        }\r\n    }\r\n}\r\n\r\nclass Picture{\r\n    private byte[] pixels;\r\n\r\n    public Picture(int length) {\r\n        this.pixels = new byte[length];\r\n    }\r\n}\r\n```\r\n\r\n1、设置虚拟机参数\r\n\r\n`-Xms600m -Xmx600m`\r\n\r\n最终输出结果：\r\n\r\n```java\r\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\r\n	at com.atguigu.java.Picture.<init>(OOMTest.java:29)\r\n	at com.atguigu.java.OOMTest.main(OOMTest.java:20)\r\n\r\nProcess finished with exit code 1\r\n```\r\n\r\n\r\n\r\n2、堆内存变化图\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0011.png)\r\n\r\n3、原因：大对象导致堆内存溢出\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0012.png)\r\n\r\n\r\n\r\n年轻代与老年代\r\n---------\r\n\r\n\r\n\r\n1、存储在JVM中的Java对象可以被划分为两类：\r\n\r\n	- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速\r\n	- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致\r\n\r\n2、Java堆区进一步细分的话，可以划分为<font color=\'red\'>年轻代（YoungGen）和老年代（oldGen）</font>\r\n\r\n3、其中<font color=\'red\'>年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</font>\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0013.png)\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0014.png)\r\n\r\n- 配置新生代与老年代在堆结构的占比\r\n\r\n  - 默认<font color=\'red\'>**-XX:NewRatio**=2</font>，表示新生代占1，老年代占2，新生代占整个堆的1/3\r\n\r\n  - 可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5\r\n\r\n\r\n\r\n\r\n\r\n1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，\r\n\r\n2. 当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如<font color=\'red\'>-XX:SurvivorRatio=8（默认值为8，但因为自适应调节机制，实际比例可能为6:1:1）</font>\r\n\r\n3. <font color=\'red\'>几乎</所有的Java对象都是在Eden区被new出来的。</font>\r\n\r\n4. 绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。\r\n\r\n5. 可以使用选项\"<font color=\'red\'>-Xmn\"设置新生代最大内存大小（会与NewRatio造成冲突，优先级比NewRatio高，一般不设置）</font>，但这个参数一般使用默认值就可以了。\r\n\r\n   \r\n\r\n![](image/JVMRuntimeDataArea2.assets/0015.png)\r\n\r\n\r\n\r\n```java\r\n/**\r\n * -Xms600m -Xmx600m\r\n *\r\n * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.\r\n * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8\r\n * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）\r\n * -Xmn:设置新生代的空间的大小。 （一般不设置）\r\n */\r\npublic class EdenSurvivorTest {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"我只是来打个酱油~\");\r\n        try {\r\n            Thread.sleep(1000000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n图解对象分配过程\r\n----------\r\n\r\n\r\n\r\n为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\r\n\r\n\r\n\r\n**具体过程**\r\n\r\n1. <font color=\'red\'>new的对象先放伊甸园区</font>。此区有大小限制。\r\n\r\n2. <font color=\'red\'>当伊甸园的空间填满时</font>，程序又需要创建对象，JVM的垃圾回收器将<font color=\'red\'>对伊甸园区进行垃圾回收（MinorGC）</font>，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。\r\n\r\n3. <font color=\'red\'>然后将伊甸园中的剩余对象移动到幸存者0区</font>。\r\n\r\n4. <font color=\'red\'>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区</font>。\r\n\r\n5. 如果再次经历垃圾回收，此时会<font color=\'red\'>重新放回幸存者0区，接着再去幸存者1区</font>。\r\n\r\n6. 啥时候能去养老区呢？可以设置次数。<font color=\'red\'>默认是15次</font>。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：\r\n\r\n   <font color=\'cornflowerblue\'>**-XX:MaxTenuringThreshold**=N</font> 进行设置\r\n\r\n7. 在养老区，相对悠闲。当<font color=\'red\'>养老区内存不足时，再次触发GC：Major GC</font>，进行养老区的内存清理\r\n\r\n8.  <font color=\'red\'>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常</font>。\r\n\r\n\r\n\r\n### 图解对象分配（一般情况）\r\n\r\n1、我们创建的对象，一般都是存放在Eden区的，**当我们Eden区满了后，就会触发GC操作**，一般被称为 YGC / Minor GC操作\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0016.png)\r\n\r\n2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。\r\n\r\n3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1\r\n\r\n> 下一次再进行GC的时候，\r\n>\r\n> 1、这一次的s0区为空，所以成为下一次GC的S1区\r\n>\r\n> 2、这一次的s1区则成为下一次GC的S0区\r\n>\r\n> 3、也就是<font color=\'red\'>说s0区和s1区在互相转换</font>。\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0017.png)\r\n\r\n4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0018.png)\r\n\r\n关于垃圾回收：<font color=\'red\'>频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</font>\r\n\r\n![0019](image/JVMRuntimeDataArea2.assets/0019.png)\r\n\r\n\r\n\r\n### 特殊情况说明\r\n\r\n\r\n\r\n<font color=\'red\'>**对象分配的特殊情况**</font>\r\n\r\n1.  **如果来了一个新对象，先看看 Eden 是否放的下？**\r\n    *   **如果 Eden 放得下，则直接放到 Eden 区**\r\n    *   **如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？**\r\n2.  **将对象放到老年区又有两种情况：**\r\n    *   **如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代**\r\n    *   **那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM** \r\n3.  **如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些年龄还没满15的对象，让他们直接晋升至老年区**\r\n3.  **若是Eden区往S区放对象时，要是该对象比S区大小还大，则该对象会直接别放入老年区**\r\n3.  **若S区中，某年龄大小的所有对象占S区的一半及以上，则大于等于该年龄的所有对象直接晋升老年区**\r\n\r\n\r\n\r\n### 常用调优工具\r\n\r\n\r\n\r\n1.  JDK命令行\r\n2.  Eclipse：Memory Analyzer Tool\r\n3.  Jconsole\r\n4.  Visual VM（实时监控，推荐）\r\n5.  Jprofiler（APP+IDEA插件）\r\n6.  Java Flight Recorder（实时监控）\r\n7.  GCViewer\r\n8.  GCEasy\r\n\r\n\r\n\r\nGC分类\r\n----------\r\n\r\n\r\n\r\n1.  我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，**而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上**\r\n  \r\n2.  JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，<font color=\'cornflowerblue\'>大部分时候回收的都是指新生代</font>。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）\r\n\r\n\r\n\r\n\r\n- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：\r\n  - **新生代收集**（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集\r\n  - **老年代收集**（Major GC/Old GC）：只是老年代的圾收集。\r\n  - 目前，只有CMS GC会有单独收集老年代的行为。\r\n  - <font color=\'red\'>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font>\r\n  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为\r\n\r\n- **整堆收集**（**Full GC**）：收集整个java堆和方法区的垃圾收集。\r\n\r\n> 由于历史原因，外界各种解读，majorGC和Full GC有些混淆。\r\n\r\n\r\n\r\n### Young GC\r\n\r\n**年轻代 GC（Minor GC）触发机制**\r\n\r\n1.  当<font color=\'red\'>年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满</font>。<font color=\'cornflowerblue\'>Survivor满不会主动引发GC</font>，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）\r\n  \r\n2.  因为Java对象<font color=\'red\'>大多都具备朝生夕灭</font>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\r\n  \r\n3.  Minor GC会引发<font color=\'cornflowerblue\'>STW</font>（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行\r\n\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0020.png)\r\n\r\n\r\n\r\n### Major/Full GC\r\n\r\n> Full GC有争议，后续详解两者区别，暂时先看着\r\n\r\n**老年代GC（MajorGC）触发机制**\r\n\r\n1.  指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了\r\n2.  出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）\r\n\r\n    *   也就是在<font color=\'cornflowerblue\'>老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</font>\r\n3.  Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\r\n4.  <font color=\'cornflowerblue\'>如果Major GC后，内存还不足，就报OOM了</font>\r\n\r\n\r\n\r\n**Full GC 触发机制（后面细讲）**\r\n\r\n**触发Full GC执行的情况有如下五种：**\r\n\r\n1.  调用System.gc()时，系统建议执行FullGC，但是<font color=\'cornflowerblue\'>不必然</font>执行\r\n2.  超大对象晋升时老年代空间不足（正常情况老年代空间不足也可能是Major GC，注意分晓）\r\n3.  方法区空间不足\r\n4.  通过Minor GC后进入老年代的平均大小大于老年代的可用内存（空间分配担保策略为true）\r\n5.  由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\r\n\r\n说明：<font color=\'red\'>Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</font>\r\n\r\n\r\n\r\n### GC日志分析\r\n\r\n```java\r\n/**\r\n * 测试MinorGC 、 MajorGC、FullGC\r\n * -Xms9m -Xmx9m -XX:+PrintGCDetails\r\n */\r\npublic class GCTest {\r\n    public static void main(String[] args) {\r\n        int i = 0;\r\n        try {\r\n            List<String> list = new ArrayList<>();\r\n            String a = \"atguigu.com\";\r\n            while (true) {\r\n                list.add(a);\r\n                a = a + a;\r\n                i++;\r\n            }\r\n\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n            System.out.println(\"遍历次数为：\" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出：\r\n\r\n```java\r\n[GC (Allocation Failure) [PSYoungGen: 2037K->504K(2560K)] 2037K->728K(9728K), 0.0455865 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 2246K->496K(2560K)] 2470K->1506K(9728K), 0.0009094 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 2294K->488K(2560K)] 3305K->2210K(9728K), 0.0009568 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 1231K->488K(2560K)] 7177K->6434K(9728K), 0.0005594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 488K->472K(2560K)] 6434K->6418K(9728K), 0.0005890 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[Full GC (Allocation Failure) [PSYoungGen: 472K->0K(2560K)] [ParOldGen: 5946K->4944K(7168K)] 6418K->4944K(9728K), [Metaspace: 3492K->3492K(1056768K)], 0.0045270 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 4944K->4944K(8704K), 0.0004954 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[Full GC (Allocation Failure) java.lang.OutOfMemoryError: Java heap space\r\n	at java.util.Arrays.copyOf(Arrays.java:3332)\r\n	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\r\n	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)\r\n	at java.lang.StringBuilder.append(StringBuilder.java:136)\r\n	at com.atguigu.java1.GCTest.main(GCTest.java:20)\r\n[PSYoungGen: 0K->0K(1536K)] [ParOldGen: 4944K->4877K(7168K)] 4944K->4877K(8704K), [Metaspace: 3492K->3492K(1056768K)], 0.0076061 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] \r\n遍历次数为：16\r\nHeap\r\n PSYoungGen      total 1536K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)\r\n  eden space 1024K, 5% used [0x00000000ffd00000,0x00000000ffd0f058,0x00000000ffe00000)\r\n  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)\r\n  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\r\n ParOldGen       total 7168K, used 4877K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)\r\n  object space 7168K, 68% used [0x00000000ff600000,0x00000000ffac3408,0x00000000ffd00000)\r\n Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K\r\n  class space    used 391K, capacity 394K, committed 512K, reserved 1048576K\r\n```\r\n\r\n\r\n\r\n```java\r\n[GC (Allocation Failure) [PSYoungGen: 2037K->504K(2560K)] 2037K->728K(9728K), 0.0455865 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] \r\n\r\n```\r\n\r\n\r\n\r\n* [PSYoungGen: 2037K->504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K\r\n\r\n* 2037K->728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K\r\n\r\n    \r\n\r\n   \r\n\r\n\r\n\r\n堆空间分代思想\r\n---------\r\n\r\n\r\n\r\n为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。\r\n\r\n<font color=\'red\'>先说结论：不分代每次垃圾收集时，都会进行整堆扫描，遍历所有对象，非常浪费时间和性能</font>\r\n\r\n\r\n\r\n*   新生代：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。\r\n*   老年代：存放新生代中经历多次GC仍然存活的对象。\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0021.png)\r\n\r\n\r\n\r\n其实不分代完全可以，分代的唯一理由就是优化GC性能。\r\n\r\n- 如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）\r\n\r\n*   而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）\r\n\r\n\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0022.png)\r\n\r\n\r\n\r\n对象内存分配策略\r\n--------\r\n\r\n\r\n\r\n1.  如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。\r\n2.  对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代\r\n3.  对象晋升老年代的年龄阀值，可以通过选项**<font color=\'red\'>-XX:MaxTenuringThreshold</font>**来设置\r\n\r\n\r\n\r\n**针对不同年龄段的对象分配原则如下所示：**\r\n\r\n1.  **优先分配到Eden**：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢\r\n2.  **大对象直接分配到老年代**：尽量避免程序中出现过多的大对象\r\n3.  **长期存活的对象分配到老年代**\r\n4.  **动态对象年龄判断**：如果Survivor区中**相同年龄**的所有对象大小的**总和大于Survivor空间的一半**，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\r\n4.  **S区放不下的对象直接进入老年代**\r\n5.  **空间分配担保**： -XX:HandlePromotionFailure 。（默认开启，后面有讲）\r\n\r\n\r\n\r\n> 一些细节放在后面说\r\n\r\n\r\n\r\nTLAB为对象分配内存（保证线程安全）\r\n---------\r\n\r\n### 为什么有 TLAB\r\n\r\n\r\n\r\n2.  堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\r\n3.  由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的\r\n4.  为避免多个线程操作同一地址，需要使用<font color=\'cornflowerblue\'>**加锁等机制**，进而影响分配速度。</font>\r\n\r\n\r\n\r\n### 什么是 TLAB\r\n\r\nTLAB（Thread Local Allocation Buffer）\r\n\r\n1.  从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<font color=\'red\'>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</font>\r\n2.  多线程同时分配内存时，<font color=\'red\'>**使用TLAB可以避免一系列的非线程安全问题（因为是线程私有的，可以无视锁问题，效率提升）**</font>，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<font color=\'red\'>**快速分配策略**。</font>\r\n3.  据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0023.png)\r\n\r\n1、每个线程都有一个TLAB空间\r\n\r\n2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的\r\n\r\n\r\n\r\n### TLAB再说明\r\n\r\n\r\n\r\n1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<font color=\'red\'>**JVM确实是将TLAB作为内存分配的首选**。</font>\r\n\r\n2. 在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。\r\n\r\n3. 默认情况下，TLAB空间的内存非常小，<font color=\'cornflowerblue\'>仅占有整个Eden空间的1%</font>，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。\r\n\r\n4. <font color=\'cornflowerblue\'>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制确保数据操作的原子性**，从而直接在Eden空间中分配内存。</font>\r\n\r\n   \r\n\r\n> 哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，**分配新的缓存区时才需要同步锁定**                   \r\n>\r\n> ----这是《深入理解JVM》--第三版里说的\r\n\r\n\r\n\r\n**TLAB 分配过程**\r\n\r\n![](image/JVMRuntimeDataArea2.assets/0024.png)\r\n\r\n\r\n\r\n堆空间参数设置\r\n---------\r\n\r\n### 常用参数设置\r\n\r\n> **官方文档**：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\r\n>\r\n> 我们只说常用的\r\n\r\n\r\n\r\n```java\r\n/**\r\n * 测试堆空间常用的jvm参数：\r\n * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值\r\n * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）\r\n *      具体查看某个参数的指令： jps：查看当前运行中的进程\r\n *                             jinfo -flag SurvivorRatio 进程id\r\n *\r\n * -Xms：初始堆空间内存 （默认为物理内存的1/64）\r\n * -Xmx：最大堆空间内存（默认为物理内存的1/4）\r\n * -Xmn：设置新生代的大小。(初始值及最大值)\r\n * -XX:NewRatio：配置新生代与老年代在堆结构的占比\r\n * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例\r\n * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄\r\n * -XX:+PrintGCDetails：输出详细的GC处理日志\r\n * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc\r\n * -XX:HandlePromotionFailure：是否设置空间分配担保\r\n */\r\n```\r\n\r\n\r\n\r\n### 空间分配担保策略\r\n\r\n\r\n\r\n1、在发生Minor GC之前，虚拟机会<font color=\'red\'>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</font>。\r\n\r\n*   如果大于，则此次Minor GC是安全的\r\n*   如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。\r\n    *   如果HandlePromotionFailure=true，那么会继续<font color=\'red\'>检查**老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**</font>。\r\n        *   如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；\r\n        *   如果小于，则进行一次Full GC。\r\n    *   如果HandlePromotionFailure=false，则进行一次Full GC。\r\n\r\n    \r\n    \r\n\r\n**历史版本**\r\n\r\n1.  <font color=\'red\'>在JDK6 Update 24之后</font>，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。\r\n2.  JDK6 Update 24之后的规则变为**<font color=\'red\'>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</font>**，否则将进行Full GC。<font color=\'red\'>即 HandlePromotionFailure=true，不能为false</font>\r\n\r\n\r\n\r\n## 逃逸分析\r\n\r\n\r\n\r\n**堆是分配对象的唯一选择么？**\r\n\r\n\r\n\r\n**在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：**\r\n\r\n1.  随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换**优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。\r\n  \r\n2.  在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**<font color=\'red\'>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</font>**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。\r\n  \r\n3.  此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。\r\n\r\n\r\n\r\n**逃逸分析概述**\r\n\r\n1.  如何将堆上的对象分配到栈，需要使用逃逸分析手段。\r\n2.  这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。\r\n3.  通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。\r\n4.  <font color=\'red\'>逃逸分析的基本行为就是分析对象动态作用域：</font>\r\n    *   **当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。**\r\n    *   **当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。**\r\n\r\n\r\n\r\n**逃逸分析举例**\r\n\r\n1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）\r\n\r\n```java\r\npublic void my_method() {\r\n    V v = new V();\r\n    // use v\r\n    // ....\r\n    v = null;\r\n}\r\n```\r\n\r\n\r\n\r\n2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配\r\n\r\n````java\r\npublic static StringBuffer createStringBuffer(String s1, String s2) {\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(s1);\r\n    sb.append(s2);\r\n    return sb;\r\n}\r\n````\r\n\r\n\r\n\r\n3、如果想要StringBuffer sb不发生逃逸，可以这样写\r\n\r\n```java\r\npublic static String createStringBuffer(String s1, String s2) {\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(s1);\r\n    sb.append(s2);\r\n    return sb.toString();\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\n\r\n/**\r\n * 逃逸分析\r\n *\r\n *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。\r\n */\r\npublic class EscapeAnalysis {\r\n\r\n    public EscapeAnalysis obj;\r\n\r\n    /*\r\n    方法返回EscapeAnalysis对象，发生逃逸\r\n     */\r\n    public EscapeAnalysis getInstance(){\r\n        return obj == null? new EscapeAnalysis() : obj;\r\n    }\r\n    /*\r\n    为成员属性赋值，发生逃逸\r\n     */\r\n    public void setObj(){\r\n        this.obj = new EscapeAnalysis();\r\n    }\r\n    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。\r\n\r\n    /*\r\n    对象的作用域仅在当前方法中有效，没有发生逃逸\r\n     */\r\n    public void useEscapeAnalysis(){\r\n        EscapeAnalysis e = new EscapeAnalysis();\r\n    }\r\n    /*\r\n    引用成员变量的值，发生逃逸\r\n     */\r\n    public void useEscapeAnalysis1(){\r\n        EscapeAnalysis e = getInstance();\r\n        //getInstance().xxx()同样会发生逃逸\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n**逃逸分析参数设置**\r\n\r\n1.  在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析\r\n  \r\n2.  如果使用的是较早的版本，开发人员则可以通过：\r\n  \r\n    *   选项“**-XX:+DoEscapeAnalysis**\"显式开启逃逸分析\r\n    *   通过选项“**-XX:+PrintEscapeAnalysis**\"查看逃逸分析的筛选结果\r\n\r\n\r\n\r\n**总结**\r\n\r\n<font color=\'red\'>**开发中能使用局部变量的，就不要使用在方法外定义。**</font>\r\n\r\n\r\n\r\n### 代码优化策略\r\n\r\n使用逃逸分析，编译器可以对代码做如下优化：\r\n\r\n1.  **栈上分配**：**将堆分配转化为栈分配**。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配\r\n2.  **同步省略**：如果一个对象被发现**只有一个线程被访问到，**那么对于这个对象的操作**可以不考虑同步。**\r\n3.  **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。（**将聚合量分解为标量和更小的聚合量**）\r\n\r\n\r\n\r\n### 栈上分配\r\n\r\n\r\n\r\n1.  **JIT编译器在编译期间根据逃逸分析的结果**，发现如果一个对象并**<font color=\'cornflowerblue\'>没有逃逸出方法的话，就可能被优化成栈上分配</font>**。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就<font color=\'red\'>无须进行垃圾回收</font>了。\r\n3.  常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。\r\n\r\n\r\n\r\n**栈上分配举例**\r\n\r\n```java\r\n/**\r\n * 栈上分配测试\r\n * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\r\n */\r\npublic class StackAllocation {\r\n    public static void main(String[] args) {\r\n        long start = System.currentTimeMillis();\r\n\r\n        for (int i = 0; i < 10000000; i++) {\r\n            alloc();\r\n        }\r\n        // 查看执行时间\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"花费的时间为： \" + (end - start) + \" ms\");\r\n        // 为了方便查看堆内存中对象个数，线程sleep\r\n        try {\r\n            Thread.sleep(1000000);\r\n        } catch (InterruptedException e1) {\r\n            e1.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static void alloc() {\r\n        User user = new User();//未发生逃逸\r\n    }\r\n\r\n    static class User {\r\n\r\n    }\r\n}\r\n```\r\n\r\n输出结果：\r\n\r\n```\r\n[GC (Allocation Failure) [PSYoungGen: 33280K->808K(38400K)] 33280K->816K(125952K), 0.0483350 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 34088K->808K(38400K)] 34096K->816K(125952K), 0.0008411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 34088K->792K(38400K)] 34096K->800K(125952K), 0.0008427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \r\n[GC (Allocation Failure) [PSYoungGen: 34072K->808K(38400K)] 34080K->816K(125952K), 0.0012223 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] \r\n花费的时间为： 114 ms\r\n```\r\n\r\n\r\n\r\n1、JVM 参数设置\r\n\r\n-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\r\n\r\n2、日志打印：发生了 GC ，耗时 114ms\r\n\r\n\r\n\r\n**开启逃逸分析的情况**\r\n\r\n输出结果：\r\n\r\n```\r\n花费的时间为： 5 ms\r\n```\r\n\r\n1、参数设置\r\n\r\n-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails\r\n\r\n2、日志打印：并没有发生 GC ，耗时5ms 。\r\n\r\n\r\n\r\n### 同步省略（同步消除）\r\n\r\n\r\n\r\n1.  线程同步的代价是相当高的，同步的后果是降低并发性和性能。\r\n  \r\n2.  在动态编译同步块的时候，JIT编译器可以<font color=\'red\'>借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**</font>。\r\n  \r\n3.  如果没有，那么<font color=\'cornflowerblue\'>JIT编译器</font>在编译这个同步块的时候<font color=\'cornflowerblue\'>就会取消对这部分代码的同步</font>。这样就能大大提高并发性和性能。这个**取消同步的过程就叫同步省略，也叫<font color=\'red\'>锁消除</font>**。\r\n\r\n\r\n\r\n\r\n例如下面的代码\r\n\r\n```java\r\npublic void f() {\r\n    Object hollis = new Object();\r\n    synchronized(hollis) {\r\n        System.out.println(hollis);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：\r\n\r\n```java\r\npublic void f() {\r\n    Object hellis = new Object();\r\n	System.out.println(hellis);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**字节码分析**\r\n\r\n```\r\npublic class SynchronizedTest {\r\n    public void f() {\r\n        Object hollis = new Object();\r\n        synchronized(hollis) {\r\n            System.out.println(hollis);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\n 0 new #2 <java/lang/Object>\r\n 3 dup\r\n 4 invokespecial #1 <java/lang/Object.<init>>\r\n 7 astore_1\r\n 8 aload_1\r\n 9 dup\r\n10 astore_2\r\n11 monitorenter\r\n12 getstatic #3 <java/lang/System.out>\r\n15 aload_1\r\n16 invokevirtual #4 <java/io/PrintStream.println>\r\n19 aload_2\r\n20 monitorexit\r\n21 goto 29 (+8)\r\n24 astore_3\r\n25 aload_2\r\n26 monitorexit\r\n27 aload_3\r\n28 athrow\r\n29 return\r\n```\r\n\r\n注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**同步省略操作是在解释运行时发生的**\r\n\r\n\r\n\r\n### 标量替换\r\n\r\n**分离对象或标量替换**\r\n\r\n1.  **标量（scalar）是指一个无法再分解成更小的数据的数据**。Java中的原始数据类型就是标量。\r\n  \r\n2.  相对的，**那些还可以分解的数据叫做聚合量（Aggregate）**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。\r\n  \r\n3.  在JIT阶段，**如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过<font color=\'cornflowerblue\'>JIT</font>优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<font color=\'red\'>标量替换</font>。**\r\n\r\n\r\n\r\n**标量替换举例**\r\n\r\n代码\r\n\r\n```java\r\npublic static void main(String args[]) {\r\n    alloc();\r\n}\r\nprivate static void alloc() {\r\n    Point point = new Point(1,2);\r\n    System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);\r\n}\r\nclass Point {\r\n    private int x;\r\n    private int y;\r\n}\r\n```\r\n\r\n\r\n\r\n以上代码，经过标量替换后，就会变成\r\n\r\n```java\r\nprivate static void alloc() {\r\n    int x = 1;\r\n    int y = 2;\r\n    System.out.println(\"point.x = \" + x + \"; point.y=\" + y);\r\n}\r\n```\r\n\r\n\r\n\r\n1.  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。\r\n2.  那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。\r\n3.  <font color=\'red\'>标量替换为栈上分配提供了很好的基础</font>。\r\n\r\n\r\n\r\n**标量替换参数设置**\r\n\r\n参数 **-XX:+ElimilnateAllocations**：开启了标量替换（默认打开），允许将对象打散分配在栈上。\r\n\r\n\r\n\r\n**代码示例**\r\n\r\n```java\r\n/**\r\n * 标量替换测试\r\n *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations\r\n * @author shkstart  shkstart@126.com\r\n * @create 2020  12:01\r\n */\r\npublic class ScalarReplace {\r\n    public static class User {\r\n        public int id;\r\n        public String name;\r\n    }\r\n\r\n    public static void alloc() {\r\n        User u = new User();//未发生逃逸\r\n        u.id = 5;\r\n        u.name = \"www.atguigu.com\";\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        long start = System.currentTimeMillis();\r\n        for (int i = 0; i < 10000000; i++) {\r\n            alloc();\r\n        }\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"花费的时间为： \" + (end - start) + \" ms\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**未开启标量替换**\r\n\r\n1、JVM 参数\r\n\r\n-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations\r\n\r\n2、日志\r\n\r\n```java\r\n[GC (Allocation Failure)  25600K->880K(98304K), 0.0012658 secs]\r\n[GC (Allocation Failure)  26480K->832K(98304K), 0.0012124 secs]\r\n[GC (Allocation Failure)  26432K->784K(98304K), 0.0009719 secs]\r\n[GC (Allocation Failure)  26384K->832K(98304K), 0.0009071 secs]\r\n[GC (Allocation Failure)  26432K->768K(98304K), 0.0010643 secs]\r\n[GC (Allocation Failure)  26368K->824K(101376K), 0.0012354 secs]\r\n[GC (Allocation Failure)  32568K->712K(100864K), 0.0011291 secs]\r\n[GC (Allocation Failure)  32456K->712K(100864K), 0.0006368 secs]\r\n花费的时间为： 99 ms\r\n```\r\n\r\n\r\n\r\n**开启标量替换**\r\n\r\n1、JVM 参数\r\n\r\n-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations\r\n\r\n2、日志：时间减少很多，且无GC\r\n\r\n```\r\n花费的时间为： 6 ms\r\n```\r\n\r\n\r\n\r\n上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：\r\n\r\n`-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations`\r\n\r\n\r\n\r\n**这里设置参数如下：**\r\n\r\n1.  参数 -server：启动Server模式，因为**在server模式下，才可以启用逃逸分析**。（X86机器只能使用server模式）\r\n2.  参数 **-XX:+DoEscapeAnalysis**：启用逃逸分析\r\n3.  参数 **-Xmx**10m：指定了堆空间最大为10MB\r\n4.  参数 **-XX:+PrintGC**：将打印GC日志。\r\n5.  参数 **-XX:+EliminateAllocations**：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配\r\n\r\n\r\n\r\n### 逃逸分析的不足\r\n\r\n1.  关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。\r\n2.  其根本原因就是<font color=\'red\'>无法保证逃逸分析的性能消耗一定能高于他的消耗</font>。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是<font color=\'red\'>逃逸分析自身也是需要进行一系列复杂的分析</font>的，这其实也是一个相对耗时的过程。\r\n3.  一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。\r\n4.  虽然这项技术并不十分成熟，但是它也<font color=\'red\'>是JIT即时编译器优化技术中一个十分重要的手段</font>。\r\n5.  注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，**<font color=\'red\'>Oracle Hotspot JVM中并未这么做</font>**（刚刚演示的效果，是<font color=\'cornflowerblue\'>因为HotSpot实现了标量替换</font>），这一点在逃逸分析相关的文档里已经说明，<font color=\'red\'>**所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上**。</font>\r\n6.  目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是**intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配**，**所以这一点同样符合前面一点的结论：对象实例都是分配在堆上**。\r\n\r\n\r\n\r\n\r\n> **堆是分配对象的唯一选择么？**\r\n\r\n综上：**HotSpot虚拟机所有对象实例都是分配在堆上**。\r\n\r\n\r\n\r\n小结\r\n------\r\n\r\n\r\n\r\n1.  年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。\r\n  \r\n2.  老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。\r\n  \r\n3.  当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；\r\n  \r\n4.  如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；\r\n  \r\n5.  如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。\r\n  \r\n6.  当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。\r\n  \r\n7.  当GC发生在老年代时则被称为Major GC或者Full GC。\r\n  \r\n8.  一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。','image/JVMRuntimeDataArea2.assets/0022.png','原创',1,_binary '',_binary '',_binary '\0','2023-07-12 15:08:52',NULL,2022576839,'JVM内存-运行时数据区部分02篇，包含堆的相关知识',NULL,NULL,'0'),(1682752951065538561,'JUC01-Future接口、CompletableFuture异步任务、Java8函数式接口和Stream流式编程','[TOC]\r\n\r\n# JUC01\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- 多线程的一些基本概念\r\n- Future接口复习\r\n- <font color=\'red\'>CompletableFuture异步任务</font>\r\n- Java8新语法介绍：函数式编程、Chain链式调用、<font color=\'red\'>Stream流式编程</font>\r\n\r\n\r\n\r\n# 多线程的一些概念\r\n\r\n\r\n\r\n## 并发与并行\r\n\r\n**并发（Concurrent）：**\r\n\r\n- 是在一个实体上的多个事件\r\n- 是在一台服务器上“同时”处理多个任务\r\n- 同一时刻，其实是只有一个事件在发生\r\n- eg：抢票、秒杀商品\r\n\r\n**并行（Parallel）：**\r\n\r\n- 是在不同实体上的多个事件\r\n- 是在多台处理器上同时处理多个任务\r\n- 同一时刻，大家真的都在做事情，你做你的，我做我的，但是我们都在做\r\n- eg：泡方便面\r\n\r\n\r\n\r\n![image-20230712195903638](image/JUC01.assets/image-20230712195903638.png)\r\n\r\n\r\n\r\n\r\n\r\n## 进程、线程、管程\r\n\r\n\r\n\r\n**进程（Process）：**\r\n\r\n简单的说，在系统中运行的一个应用程序就是一个进程，每一个进程都有它自己的内存空间和系统资源。\r\n\r\n\r\n\r\n**线程（Thread）：**\r\n\r\n也被称为<font color=\'red\'>轻量级进程</font>，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元\r\n\r\n\r\n\r\n**管程/Monitor(监视器)**，<font color=\'red\'>也就是我们平时所说的锁</font>\r\n\r\nMonitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。\r\n\r\nJVM中同步是基于进入和退出监视器对象（Monitor，管程对象）来实现的，每个对象实例都会有一个Monitor对象\r\n\r\n```java\r\nObject o new Object();\r\n\r\nnew Thread(()->{\r\n    synchronized (o){\r\n    }\r\n},\"t1\").start();\r\n```\r\n\r\nMonitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。\r\n\r\n\r\n\r\n> 执行线程就要求朱成功持有管程，然后才能热行方法，最后当方法宗成（无论是正常完成还是非正常完成)时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程无法再获取到同一个管程。																			——JVM第三版\r\n\r\n\r\n\r\n## 用户线程和守护线程\r\n\r\n**用户线程（User Thread）：**\r\n\r\n- 是系统的工作线程，它会完成这个程序需要完成的业务操作。\r\n- 一般情况下不做特别说明配置，<font color=\'red\'>默认都是用户线程</font>\r\n\r\n\r\n\r\n**守护线程（Daemon Thread）：**\r\n\r\n- 是一种特殊的线程<font color=\'red\'>为其它线程服务的</font>，在后台默默地完成一些系统性的服务，比如垃圾回收线程就是最典型的例子\r\n- 守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出。\r\n\r\n\r\n\r\n>可以使用 `isDaemon()`方法判断是否是守护线程，true代表是守护线程\r\n>\r\n>可以使用`setDaemon(true)`方法设置为守护线程\r\n\r\n\r\n\r\n<font color=\'red\'>如果用户线程全部结束，意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作</font>\r\n\r\n`setDaemon(true)`方法<font color=\'cornflowerblue\'>必须在线程start()之前</font>，否则报IllegalThreadStateException\r\n\r\n\r\n\r\n## wait/sleep 的区别 \r\n\r\n1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都\r\n\r\n能调用。\r\n\r\n2）**sleep 不会释放锁**，它也不需要占用锁。**wait 会释放锁**，但调用它的前提\r\n\r\n是当前线程占有锁(即代码要在 synchronized 中)。\r\n\r\n3）后续在JUC02中会讲到LockSupport类的静态方法park()，**park()不会释放锁**\r\n\r\n4）它们都可以被 interrupt() 方法中断。\r\n\r\n\r\n\r\n\r\n\r\n# ==CompletableFuture==\r\n\r\n\r\n\r\n## Future接口复习\r\n\r\n**Future作用**\r\n\r\nFuture接口(FutureTask实现类)定义了操作<font color=\'red\'>**异步任务**执行一些方法</font>，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。\r\n\r\n比如<font color=\'cornflowerblue\'>主线程</font>让一个<font color=\'cornflowerblue\'>子线程</font>去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙其它事情或者先执行完，过了一会才去获取子任务的执行结果或变更的任务状态。\r\n\r\n<font color=\'red\'>一句话：Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。</font>\r\n\r\n\r\n\r\n**Future实现方式**\r\n\r\nFuture是Java5新加的一个接口，它提供了一种<font color=\'red\'>异步并行计算的功能</font>。\r\n\r\n如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。\r\n\r\n主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。\r\n\r\n代码说话:\r\n\r\nRunnable接口\r\n\r\n**Callable接口**\r\n\r\nFuture接口和**FutureTask**实现类\r\n\r\n<font color=\'red\'>目的:异步多线程任务执行且返回有结果，三个特点:多线程/有返回/异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</font>\r\n\r\n\r\n\r\nThread构造器中没有可传入Callable接口的构造器，但是有传入Future接口的构造器。\r\n\r\n<font color=\'cornflowerblue\'>所以异步任务我们选中Callable接口（有返回值）和**FutureTask**实现类（实现Future和可构造注入Callable）</font>\r\n\r\n\r\n\r\n## FutureTask实现类\r\n\r\n\r\n\r\n### Callable + FutureTask的入门调用\r\n\r\n知道如何使用Callable + FutureTask创建一个线程和得到它的返回值\r\n\r\n```java\r\n/**\r\n * 演示FutureTask + Callable接口的入门调用\r\n */\r\npublic class CompletableFutureDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {\r\n            @Override\r\n            public String call() throws Exception {\r\n                System.out.println(\"-----------come in call()\");\r\n                return \"hello Callable\";\r\n            }\r\n        });\r\n        \r\n        new Thread(futureTask,\"t1\").start();\r\n\r\n        //调用get()方法获取返回值\r\n        System.out.println(futureTask.get());\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Future接口优点\r\n\r\n**Future优点**：<font color=\'red\'>Future+线程池**异步**多线程任务配合，能显著提高程序的执行效率。</font>\r\n\r\n**案例**\r\n\r\n```java\r\n/**\r\n * Future + ThreadPool异步任务耗时低演示\r\n */\r\npublic class FutureThreadPoolDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        \r\n        //三个线程完成三个任务的耗时（即异步任务）\r\n        //不调用get()：353 毫秒\r\n        //调用get()： 865 毫秒\r\n\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n        \r\n        long startTime = System.currentTimeMillis();\r\n        FutureTask<String> futureTask1 = new FutureTask<>(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(500);} catch (InterruptedException e) {e.printStackTrace();}\r\n            return \"task1 over\";\r\n        });\r\n        threadPool.submit(futureTask1);\r\n\r\n        FutureTask<String> futureTask2 = new FutureTask<>(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace();}\r\n            return \"task2 over\";\r\n        });\r\n        threadPool.submit(futureTask2);\r\n\r\n//        System.out.println(futureTask1.get());\r\n//        System.out.println(futureTask2.get());\r\n\r\n        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace();}\r\n        \r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime：\" + (endTime - startTime) + \" 毫秒\");\r\n\r\n        \r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----end\");\r\n        threadPool.shutdown();\r\n        \r\n    }\r\n    \r\n    @Test\r\n    public void m1(){\r\n        //一个线程完成三个任务的耗时     耗时1125 毫秒\r\n        long startTime = System.currentTimeMillis();\r\n        try {TimeUnit.MILLISECONDS.sleep(500);} catch (InterruptedException e) {e.printStackTrace();}\r\n        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace();}\r\n        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace();}\r\n\r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime：\" + (endTime - startTime) + \" 毫秒\");\r\n\r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----end\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n我们可以看到，当一个线程完成三个任务的耗时  ：  耗时1125 毫秒，\r\n\r\n三个线程完成三个任务的耗时（即异步任务）：\r\n不调用get()：353 毫秒\r\n调用get()： 865 毫秒\r\n\r\n使用异步任务耗时都明显低于单线程执行\r\n\r\n\r\n\r\n### Future接口缺点\r\n\r\n**Future缺点：**\r\n\r\n- **get()方法容易导致阻塞**\r\n  - 一般建议放在程序后面，一且调用不见不散，非要等到结果才会离开，不管你是否计算完成，调用不当容易导致<font color=\'red\'>其它线程堵塞</font>。\r\n  - 假如我不愿意等待很长时间，我希望过时不候，可以自动离开。**get()方法可以设置等待时间**，若超过则直接抛出异常\r\n- **isDone()轮询耗费CPU**\r\n  - 轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果。\r\n  - 如果想要异步获取结果，**通常都会以轮询的方式去获取结果**尽量不要阻塞\r\n\r\n结果：Future对于结果的获取不太友好\r\n\r\n**案例演示**\r\n\r\n```java\r\n/**\r\n * 缺点演示：1 get()容易导致线程阻塞\r\n *         2 isDone()轮询消耗CPU\r\n */\r\npublic class FutureAPIDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {\r\n        FutureTask<String> futureTask = new FutureTask<>(() -> {\r\n            try {TimeUnit.SECONDS.sleep(5);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName() + \"take over\");\r\n            return \"take over\";\r\n        });\r\n        \r\n        new Thread(futureTask,\"t1\").start();\r\n\r\n//        futureTask.get();   //会阻塞下面main线程的语句执行\r\n        futureTask.get(3,TimeUnit.SECONDS); //可设置等待时间\r\n        \r\n        System.out.println(Thread.currentThread().getName() + \"正在执行其它任务中\");\r\n        \r\n        while (true){\r\n            if (futureTask.isDone()){\r\n                System.out.println(futureTask.get());\r\n                break;\r\n            }else {\r\n                try {TimeUnit.MILLISECONDS.sleep(500);} catch (InterruptedException e) {e.printStackTrace();}\r\n                System.out.println(\"正在等待get中\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## CompletableFuture实现类引入\r\n\r\n\r\n\r\n**CompletableFuture为什么会出现？**\r\n\r\nget()方法在Future计算完成之前会一直处在<font color=\'red\'>阻塞状态</font>下，\r\n\r\nisDone()方法容易耗费CPU资源，\r\n\r\n对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。\r\n\r\n\r\n\r\n<font color=\'red\'>阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源</font>。因此：\r\n\r\nJDK8设计出CompletableFuture。\r\n\r\n- **CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方**。\r\n- **whenComplete()不用轮询，完成后直接获得返回值**\r\n\r\n\r\n\r\n**什么是CompletableFuture？**\r\n\r\n- 在Java8中，CompletableFuture提供了非常强大的**Future的扩展功能**，可以帮助我们**简化异步编程的复杂性**，并且**提供了函数式编程的能力**，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法。\r\n- 它<font color=\'red\'>可能代表一个明确完成的Future,也有可能代表一个完成阶段</font>（CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。**它实现了Future和CompletionStage接口**\r\n\r\n\r\n\r\n## CompletableFuture的初步使用\r\n\r\n\r\n\r\n### 创建一个CompletableFuture异步任务\r\n\r\n一共有四种常用的创建CompletableFuture的方式：\r\n\r\n- 无返回值\r\n\r\n  - ```java\r\n    public static CompletableFuture<Void> runAsync(Runnable runnable)\r\n    ```\r\n\r\n  - ```java\r\n    public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)\r\n    ```\r\n\r\n- 有返回值\r\n\r\n  - ```java\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)\r\n    ```\r\n\r\n  - ```java\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)\r\n    ```\r\n\r\n如果没有指定Executor的方法，直接使用默认的**ForkJoinPool..commonPool()**\r\n作为它的线程池执行异步代码。如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码\r\n\r\n<font color=\'red\'>若使用默认线程池主线程不要立刻结束</font>，否则CompletableFuture默认使用的线程池会立刻关闭\r\n\r\n\r\n\r\n**案例演示：**\r\n\r\n```java\r\n/**\r\n * 演示CompletableFuture创建实例的四种方式\r\n */\r\npublic class CompletableFutureBuildDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n        \r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n        \r\n        //无返回值使用默认线程池   ForkJoinPool.commonPool\r\n        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName());\r\n        });\r\n        System.out.println(completableFuture.get());\r\n\r\n\r\n        //无返回值使用指定线程池\r\n        CompletableFuture<Void> completableFuture1 = CompletableFuture.runAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName());\r\n        },threadPool);\r\n        System.out.println(completableFuture1.get());\r\n\r\n        //有返回值使用默认线程池   ForkJoinPool.commonPool\r\n        CompletableFuture<String> completableFuture2 = CompletableFuture.supplyAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName());\r\n            return \"hello supply\";\r\n        });\r\n        System.out.println(completableFuture2.get());\r\n\r\n        //有返回值使用指定线程池\r\n        CompletableFuture<String> completableFuture3 = CompletableFuture.supplyAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName());\r\n            return \"hello supply\";\r\n        },threadPool);\r\n        System.out.println(completableFuture3.get());\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### CompletableFuture异步任务基本使用演示\r\n\r\n\r\n\r\n**演示1**\r\n\r\n先演示CompletableFuture能完成Future接口的工作，代表CompletableFuture能完全替代Future接口\r\n\r\n```java\r\n//演示CompletableFuture完成Future接口的任务\r\n@Test\r\npublic void testFuture() throws ExecutionException, InterruptedException {\r\n    CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n        System.out.println(Thread.currentThread().getName() + \"----come in\");\r\n        int result = ThreadLocalRandom.current().nextInt(10);\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"----1秒后出结果\" + result);\r\n        return result;\r\n    });\r\n\r\n    System.out.println(Thread.currentThread().getName() + \"主线程先去忙其它任务了\");\r\n\r\n    System.out.println(completableFuture.get());\r\n}\r\n```\r\n\r\n\r\n\r\n**演示2**\r\n\r\n主要包含两个方法：\r\n\r\n- whenComplete(BiConsumer bc)\r\n- exceptionally(Function fn)\r\n\r\n再演示使用<font color=\'red\'>whenComplete</font>方法替换Future接口的isDone轮询，<font color=\'red\'>whenComplete()不用轮询</font>\r\n\r\n使用<font color=\'red\'>exceptionally</font>对异常进行处理\r\n\r\n**注意：<font color=\'red\'>若使用默认线程池主线程不要立刻结束</font>，否则CompletableFuture默认使用的线程池会立刻关闭:**\r\n\r\n```java\r\npublic class CompletableFutureUsesDemo {\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n\r\n        try {\r\n            CompletableFuture.supplyAsync(() -> {\r\n                System.out.println(Thread.currentThread().getName() + \"----come in\");\r\n                int result = ThreadLocalRandom.current().nextInt(10);\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                if (result > 2){\r\n                    int i = 10/0;\r\n                }\r\n                System.out.println(\"----1秒后出结果\" + result);\r\n                return result;\r\n            },threadPool).whenComplete((v,e) -> {\r\n                if (e == null){\r\n                    System.out.println(\"-----计算完成，更新系统UpdateValue：\"+v);\r\n                }\r\n            }).exceptionally(e -> {\r\n                e.printStackTrace();\r\n                System.out.println(\"异常情况：\" + e.getCause() + \"\\t\" + e.getMessage());\r\n                return null;\r\n            });\r\n\r\n            System.out.println(Thread.currentThread().getName() + \"主线程先去忙其它任务了\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            threadPool.shutdown();\r\n        }\r\n\r\n        //若使用默认线程池主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程\r\n        //try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### CompletableFuture方法各类方法详解\r\n\r\n\r\n\r\n#### 获得结果和触发计算\r\n\r\n- **获得结果**\r\n  - public T get()        \r\n    - 需要抛出异常\r\n  - public T get(long timeout, TimeUnit unit)       \r\n    - 只愿意等多少时间，超过报异常\r\n  - public T join()        \r\n    - 不需要抛出异常\r\n  - public T getNow(T ValueIfAbsent)          \r\n    - 立即获取结果不阻塞：若计算完成，则返回计算结果，没算完，则返回设定值\r\n- **主动触发计算**\r\n  - public boolean complete(T value)\r\n    - 被获取计算结果时，若计算完成，则返回给获取者计算结果，没算完，则返回设定值\r\n\r\n\r\n\r\n#### 对最终结果和异常进行处理\r\n\r\n- whenComplete(BiConsumer bc)\r\n- exceptionally(Function fn)\r\n\r\n**案例演示：**\r\n\r\n```java\r\nCompletableFuture.supplyAsync(() -> {\r\n    System.out.println(\"whenComplete and exceptionally\");\r\n    return \"whenComplete and exceptionally\";\r\n}).whenComplete((v,e) -> {\r\n    if (e ==null){\r\n        System.out.println(\"计算结果：\" + v);\r\n    }\r\n}).exceptionally(e -> {\r\n    e.printStackTrace();\r\n    System.out.println(\"异常：\" + e.getCause() + \"\\t\" + e.getMessage());\r\n    return null;\r\n});\r\n```\r\n\r\n\r\n\r\n#### 对中间计算结果进行处理\r\n\r\n- thenApply(Functuon f)\r\n\r\n  - 对计算结果进行处理，计算结果之间存在依赖关系，这两个线程串行化\r\n\r\n  - <font color=\'red\'>由于存在依赖关系（当前步错，不走下一步），当前步聚有异常的话就停止执行抛出异常</font>\r\n\r\n  - ```java\r\n    /**\r\n     * thenApply演示\r\n     */\r\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\r\n            2,\r\n            5,\r\n            5,\r\n            TimeUnit.SECONDS,\r\n            new ArrayBlockingQueue<>(3),\r\n            Executors.defaultThreadFactory(),\r\n            new ThreadPoolExecutor.AbortPolicy()\r\n    );\r\n    \r\n    CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n        try {TimeUnit.SECONDS.sleep(1);} catch (InterruptedException e) {e.printStackTrace();}\r\n        System.out.println(\"111\");\r\n        return 1;\r\n    },threadPool).thenApply(f -> {\r\n        System.out.println(\"222\");\r\n        return f + 2;\r\n    }).thenApply(f -> {\r\n        System.out.println(\"333\");\r\n        return f + 3;\r\n    }).whenComplete((v,e) -> {\r\n        if(e == null){\r\n            System.out.println(\"----计算结果：\" + v);\r\n        }\r\n    }).exceptionally(e -> {\r\n        e.printStackTrace();\r\n        System.out.println(\"异常： \" + e.getCause() + \"\\t\" + e.getMessage());\r\n        return null;\r\n    });\r\n    threadPool.shutdown();\r\n    ```\r\n\r\n- handle(BiFunction <v, e> f)\r\n\r\n  - 对计算结果进行处理，计算结果之间存在依赖关系，这两个线程串行化\r\n\r\n  - <font color=\'red\'>但是：有异常也可以往下一步走，带着异常参数在最后exceptionally进行进一步处理</font>\r\n\r\n  - ```java\r\n    .handle((f,e) -> {\r\n        System.out.println(\"222\");\r\n        int i = 10/0;\r\n        return f + 2;\r\n    }).handle((f,e) -> {\r\n        System.out.println(\"333\");\r\n        return f + 3;\r\n    }).whenComplete((v,e) -> {\r\n        if(e == null){\r\n            System.out.println(\"----计算结果：\" + v);\r\n        }\r\n    }).exceptionally(e -> {\r\n        e.printStackTrace();\r\n        System.out.println(\"异常： \" + e.getCause() + \"\\t\" + e.getMessage());\r\n        return null;\r\n    });\r\n    threadPool.shutdown();\r\n    ```\r\n\r\n\r\n\r\n#### 对中间计算结果进行消费\r\n\r\n- thenRun(Runnable runnable)\r\n  - 任务A执行完执行B，并且B不需要A的结果\r\n- thenAccept(Consumer consumer)\r\n  - 任务A执行完执行B，B需要A的结果，但是任务B<font color=\'red\'>无返回值</font>\r\n- thenApply(Function fun)\r\n  - 任务A执行完执行B，B需要A的结果，同时任务B<font color=\'red\'>有返回值</font>\r\n\r\n```java\r\n/**\r\n * 演示几种结果消费方法\r\n */\r\nSystem.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenRun(() -> {}).join());\r\nSystem.out.println(CompletableFuture.supplyAsync(() ->\"resultA\").thenAccept(System.out::println).join());\r\nSystem.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenApply(f -> f + \"resultB\").join());\r\n```\r\n\r\n\r\n\r\n#### 线程池运行选择\r\n\r\n**即上面的方法后面都加上Async**\r\n\r\neg：thenRun(Runnable runnable) 和 thenRunAsync(Runnable runnable)\r\n\r\n1. 没有传入自定义线程池，都用默认线程池ForkJoinPool；\r\n2. 传入了一个<font color=\'red\'>自定义线程池</font>：如果你执行第一个任务的时候，传入了一个<font color=\'red\'>自定义线程池</font>：\r\n   - 第一个任务肯定使用自定义线程池\r\n   - 调用thenRun方法执行后续任务时，则后续任务和第一个任务是共用同一个线程池。\r\n   - 调用thenRunAsync执行后续任务时，则第一个任务到调用thenRunAsync的任务使用的是你自己传入的线程池调用thenRunAsync开始使用的是ForkJoin线程池\r\n3. 备注\r\n   - 有可能处理太快，系统优化切换原则，直接使用main线程处理\r\n\r\n其它如：thenAccept和thenAcceptAsync，thenApply.和thenApplyAsync等，它们之间的区别也是同理\r\n\r\n<font color=\'red\'>即同步的用的是同一个线程池，但是异步的话就需要使用不同的线程池了</font>\r\n\r\n<font color=\'red\'>设置异步任务中的异步任务</font>\r\n\r\n\r\n\r\n**案例演示**\r\n\r\n```java\r\n/**\r\n * 线程池选择演示\r\n */\r\npublic static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(5);\r\n\r\n    try {\r\n        CompletableFuture<Void> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(\"1号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n            return \"abcd\";\r\n        },threadPool).thenRun(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(\"2号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n        }).thenRunAsync(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(10);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(\"3号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n        }).thenRun(() -> {\r\n            try {TimeUnit.MILLISECONDS.sleep(10);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(\"4号任务\" + \"\\t\" + Thread.currentThread().getName());\r\n        });\r\n        System.out.println(completableFuture.get(2L,TimeUnit.SECONDS));\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        threadPool.shutdown();\r\n    }\r\n}\r\n```\r\n\r\n```\r\n运行结果：\r\n1号任务	pool-1-thread-1\r\n2号任务	pool-1-thread-1\r\n3号任务	ForkJoinPool.commonPool-worker-1\r\n4号任务	ForkJoinPool.commonPool-worker-1\r\nnull\r\n```\r\n\r\n\r\n\r\n#### 对两个异步任务计算速度进行选用\r\n\r\n- applyToEither(CompletionStage stage, Function fn)\r\n  - 对两个异步任务的速度进行选择，选择速度更快的那个线程\r\n\r\n**案例演示：**\r\n\r\n```java\r\n/**\r\n * 对速度进行选择\r\n */\r\npublic static void main(String[] args) {\r\n    CompletableFuture<String> playA = CompletableFuture.supplyAsync(() -> {\r\n        System.out.println(\"A come in\");\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return \"playA\";\r\n    });\r\n\r\n    CompletableFuture<String> playB = CompletableFuture.supplyAsync(() -> {\r\n        System.out.println(\"B come in\");\r\n        try {\r\n            TimeUnit.SECONDS.sleep(3);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return \"playB\";\r\n    });\r\n\r\n    CompletableFuture<String> result = playA.applyToEither(playB, f -> f + \" is winner\");\r\n    System.out.println(result.join());\r\n}\r\n```\r\n\r\n```\r\nA come in\r\nB come in\r\nplayA is winner\r\n```\r\n\r\n\r\n\r\n#### 对两个异步任务计算结果进行合并\r\n\r\n- thenCombine(CompletionStage stage, BiFunction bf)\r\n  - 对两个异步任务的结果进行合并\r\n\r\n**案例演示：**\r\n\r\n```java\r\n/**\r\n * 对两个异步任务的结果进行合并\r\n */\r\npublic static void main(String[] args) {\r\n    CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {\r\n        System.out.println(\"----come in A\");\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return 10;\r\n    });\r\n\r\n    CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {\r\n        System.out.println(\"----come in B\");\r\n        try {\r\n            TimeUnit.SECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return 20;\r\n    });\r\n\r\n    System.out.println(completableFuture1.thenCombine(completableFuture2,Integer::sum).join());\r\n}\r\n```\r\n\r\n```\r\n----come in A\r\n----come in B\r\n30\r\n```\r\n\r\n\r\n\r\n## Mall实战案例\r\n\r\n\r\n\r\n### ==Java8函数式编程、Chain链式调用、join()方法、Stream流式编程和案例需求说明==\r\n\r\n\r\n\r\n**函数式接口：**\r\n\r\n![image-20230713141445391](image/JUC01.assets/image-20230713141445391.png)\r\n\r\n\r\n\r\n**什么是函数式接口？**\r\n\r\n<font color=\'red\'>只定义了一个抽象方法的接口</font>都可以叫做函数式接口\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>只有函数式接口才可以使用lambda表达式</font>\r\n\r\n\r\n\r\n**常用函数式接口**\r\n\r\n生命在jdk1.8的 	java.util.function包下\r\n\r\n| 接口                              | 对应的抽象方法        |\r\n| --------------------------------- | --------------------- |\r\n| 消费型接口(一参)：Consumer<T>     | void accept(T t)      |\r\n| 消费型接口(两参)：BiConsumer<T>   | void accept(T t, R r) |\r\n| 供给型接口(无返回值)：Runnable<T> | void run()            |\r\n| 供给型接口(有返回值)：Supplier<T> | T get()               |\r\n| 函数型接口：Function<T,R>         | R apply(T t)          |\r\n| 判断型接口：Predicate<T>          | boolean test(T t)     |\r\n\r\n\r\n\r\n- 比如<font color=\'red\'>CompletableFuture实例的创建方法**runAsync**()</font>的参数就有**Runnable**接口，正好对应该方法是**无参数无返回值**的\r\n- 比如<font color=\'red\'>CompletableFuture实例的创建方法**supplyAsync**()</font>的参数就有**Supplier**接口，正好对应该方法是**无参数有返回值**的\r\n- 比如<font color=\'red\'>CompletableFuture实例的方法**whenComplete**()</font>的参数就有**BiConsumer**接口，正好对应该方法是**两个参数无返回值**的\r\n- 比如<font color=\'red\'>CompletableFuture实例的方法**exceptionally**()</font>的参数就有**Function**接口，正好对应该方法是**一个参数有返回值**的\r\n\r\n\r\n\r\n**Chain链式调用**\r\n\r\n```java\r\npublic class CompletableFutureMallDemo {\r\n    public static void main(String[] args) {\r\n        //链式调用\r\n        student student = new student();\r\n        \r\n        student.setId(1).setStudentName(\"zs\").setMajor(\"it\");\r\n\r\n        System.out.println(student);\r\n    }\r\n}\r\n\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Data\r\n@Accessors(chain = true)\r\nclass student{\r\n    private Integer id;\r\n    private String studentName;\r\n    private String major;\r\n}\r\n```\r\n\r\n\r\n\r\n**join()和get()**\r\n\r\n```java\r\npublic class CompletableFutureMallDemo {\r\n    public static void main(String[] args) {\r\n    \r\n        //join()方法与get()方法\r\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello 1234\";\r\n        });\r\n//        System.out.println(completableFuture.get());      //需要抛出异常\r\n        System.out.println(completableFuture.join());       //不用抛出异常，运行时出现异常就出异常就好\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### ==Stream流式编程==\r\n\r\n\r\n\r\n**什么是Stream**\r\n\r\nStream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。\r\n\r\nStream和Collection集合的区别：<font color=\'red\'>Collection是一种静态的内存数据结构，讲的是数据，而Stream是有关计算的，讲的是计算。</font>前者是主要面向内存，存储在内存中，后者主要是面向CPU,通过CPU实现计算。\r\n\r\n\r\n\r\n>- Stream API关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。\r\n>- 集合关注的数据的存储，向下内存的。\r\n>\r\n><font color=\'red\'>Stream API之于集合，类似于SQL之于数据表的查询。</font>\r\n>\r\n>即用Stream API在集合中查找数据\r\n\r\n\r\n\r\n**使用说明：**\r\n\r\n①Stream自己不会存储元素。\r\n\r\n②Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。\r\n\r\n③Stream操作是延迟执行的。这意味着他们**会等到需要结果的时候才执行**。即一旦**执行终止操作，才执行中间操作链**，并产生结果。\r\n\r\n④Stream**一旦执行了终止操作，就不能再调用其它中间操作或终止操作**了。\r\n\r\n\r\n\r\n**Stream使用的步骤**\r\n\r\n- Stream的实例化\r\n\r\n  - 方式一：通过集合\r\n\r\n    - ```java\r\n      List<Employee> list = Employee.getEmployees();\r\n      \r\n      //default Stream<E> stream() : 返回一个顺序流\r\n      Stream<Employee> stream = list.stream();\r\n      \r\n      //default Stream<E> parallelStream() : 返回一个并行流\r\n      Stream<Employee> stream1 = list.parallelStream();\r\n      ```\r\n\r\n  - 方式二：通过数组\r\n\r\n    - ```java\r\n      Integer[] arr = new Integer[]{1,2,3,4,5};\r\n      Stream<Integer> stream2 = Arrays.stream(arr);\r\n      ```\r\n\r\n  - 方式三：通过Stream的of()\r\n\r\n    - ```java\r\n      Stream<String> stream3 = Stream.of(\"aa\", \"bb\", \"cc\", \"dd\");\r\n      ```\r\n\r\n- 一系列的中间操作\r\n\r\n  - 筛选与切片\r\n\r\n    - ```java\r\n      /**\r\n       * 筛选与切片\r\n       */\r\n      //filter(Predicate p): 接收Lambda,从流中排除某些元素。\r\n      //练习：查询员工表中薪资大于7000的员工信息\r\n      List<Employee> list = Employee.getEmployees();\r\n      list.stream().filter(emp -> emp.getSalary() > 7000).forEach(System.out::println);\r\n      \r\n      System.out.println();\r\n      \r\n      //limit(n): 截断流，使其元素不超过给定数量.\r\n      //因为stream已经执行了终止操作，就不可以再调用其它的中间操作或终止操作了，所以需要重新获取流对象。\r\n      list.stream().limit(3).forEach(System.out::println);\r\n      \r\n      System.out.println();\r\n      \r\n      //skip(n): 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。\r\n      list.stream().skip(3).forEach(System.out::println);\r\n      list.stream().skip(10).forEach(System.out::println);    //返回空流\r\n      \r\n      System.out.println();\r\n      \r\n      //distinct(): 筛选，通过流所生成元素的hashCode()和equals()去除重复元素\r\n      list.add(new Employee(10,\"马斯克\",50,21000.11));\r\n      list.add(new Employee(10,\"马斯克\",50,21000.11));\r\n      list.add(new Employee(10,\"马斯克\",50,21000.11));\r\n      list.add(new Employee(10,\"马斯克\",50,21000.11));\r\n      \r\n      list.stream().distinct().forEach(System.out::println);\r\n      ```\r\n\r\n  - 映射\r\n\r\n    - ```java\r\n      /**\r\n       * 映射\r\n       */\r\n      //map(Function f)：接收一个函数作为参数，将元素转换成其它形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素\r\n      //练习：将字母转换为大写\r\n      String[] arr = new String[]{\"aa\",\"bb\",\"cc\",\"dd\"};\r\n      //方式1：\r\n      Arrays.stream(arr).map(str -> str.toUpperCase()).forEach(System.out::println);\r\n      //方式2：\r\n      Arrays.stream((arr)).map(String::toUpperCase).forEach(System.out::println);\r\n      \r\n      //练习：获取员工姓名长度大于3的员工的姓名\r\n      List<Employee> list = Employee.getEmployees();\r\n      //获取员工姓名长度大于3的员工\r\n      list.stream().filter(emp -> emp.getName().length() > 3).forEach(System.out::println);\r\n      //方式1：\r\n      list.stream().filter(emp -> emp.getName().length() > 3).map(Employee::getName).forEach(System.out::println);\r\n      //方式2：\r\n      list.stream().map(Employee::getName).filter(name -> name.length() > 3).forEach(System.out::println);\r\n      ```\r\n\r\n  - 排序\r\n\r\n    - ```java\r\n      /**\r\n       * 排序\r\n       */\r\n      //sorted(): 自然排序\r\n      Integer[] arr2 = new Integer[]{312,24123,132,4323,12,23};\r\n      Arrays.stream(arr2).sorted().forEach(System.out::println);\r\n      ```\r\n\r\n- 执行终止操作\r\n\r\n  - 匹配与查找\r\n\r\n    - ```java\r\n      /**\r\n       * 匹配与查找\r\n       */\r\n      //allMatch(Predicate p): 检查是否匹配所有元素。\r\n      //练习: 是否所有的员工的年龄都大于18\r\n      List<Employee> list = Employee.getEmployees();\r\n      System.out.println(list.stream().allMatch(emp -> emp.getAge() > 18));\r\n      \r\n      //anyMatch(Predicate p): 检查是否至少匹配一个元素。\r\n      //练习: 是否存在年龄大于18岁的员工\r\n      System.out.println(list.stream().anyMatch(emp -> emp.getAge() > 18));\r\n      \r\n      //findFirst一返回第一个元素\r\n      System.out.println(list.stream().findFirst().get());\r\n      \r\n      //count(): 返回流的数量\r\n      System.out.println(list.stream().filter(emp -> emp.getSalary() > 7000).count());\r\n      \r\n      //max(Comparator c): 返回流中最大值\r\n      //返回工资最高的员工\r\n      System.out.println(list.stream().max((e1,e2) -> Double.compare(e1.getSalary(),e2.getSalary())));\r\n      //返回最高的工资\r\n      System.out.println(list.stream().map(Employee::getSalary).max(Double::compareTo));\r\n      \r\n      //min(Comparator c): 返回流中最小值\r\n      System.out.println(list.stream().map(Employee::getSalary).min(Double::compareTo));\r\n      \r\n      //forEach(Consumer c): 内部迭代\r\n      list.stream().forEach(System.out::println);\r\n      ```\r\n\r\n  - 归约\r\n\r\n    - ```java\r\n      /**\r\n       * 归约\r\n       */\r\n      //reduce(T identity, BinaryOperator): 可以将流中元素反复结合起来，得到一个值。返回T\r\n      //练习1：计算1-10的自然数的和\r\n      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\r\n      System.out.println(list.stream().reduce(0, (x1, x2) -> x1 + x2));\r\n      System.out.println(list.stream().reduce(0, Integer::sum));//55\r\n      System.out.println(list.stream().reduce(10, Integer::sum));//65\r\n      \r\n      //reduce(BinaryOperator): 可以将流中元素反复结合起来，得到一个值。返回Optional<T>\r\n      //练习2：计算公司所有员工工资的总和\r\n      List<Employee> list2 = Employee.getEmployees();\r\n      System.out.println(list2.stream().map(Employee::getSalary).reduce(Double::sum));\r\n      ```\r\n\r\n  - 收集\r\n\r\n    - ```java\r\n      /**\r\n       * 收集\r\n       */\r\n      //collect(Collector c): 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\r\n      //练习1：查找工资大于6000的员工，结果返回为一个List或Set\r\n      List<Employee> list = Employee.getEmployees();\r\n      List<Employee> collect = list.stream().filter(emp -> emp.getSalary() > 6000).collect(Collectors.toList());\r\n      collect.forEach(System.out::println);\r\n      \r\n      //练习2：按照员工的年龄进行排序，返回到一个新的List中\r\n      List<Employee> collect1 = list.stream().sorted((e1, e2) -> e1.getAge() - e2.getAge()).collect(Collectors.toList());\r\n      collect1.forEach(System.out::println);\r\n      ```\r\n\r\n      \r\n\r\n\r\n\r\n**案例说明**\r\n\r\n```java\r\n/**\r\n * 案例说明：电商比价需求，模拟如下情况：\r\n * <p>\r\n * 1需求：\r\n * 1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;\r\n * 1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\r\n * <p>\r\n * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\r\n * 《mysql》 in jd price is 88.05\r\n * 《mysql》 in dangdang price is 86.11\r\n * 《mysql》 in taobao price is 90.43\r\n * <p>\r\n * 3 技术要求\r\n * 3.1 函数式编程\r\n * 3.2 链式编程\r\n * 3.3 Stream流式计算\r\n */\r\n```\r\n\r\n\r\n\r\n### 不使用异步任务一步步实现\r\n\r\n\r\n\r\n**NetMall电商平台类**\r\n\r\n```java\r\n@Data\r\nclass NetMall {\r\n    private String netMallName;\r\n\r\n    public NetMall(String netMallName) {\r\n        this.netMallName = netMallName;\r\n    }\r\n\r\n    //查询该电商平台的售价\r\n    public double calcPrice(String productName) {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**一步步搜查的方法**\r\n\r\n```java\r\n/**\r\n * step by step 一家家搜查\r\n * List<NetMall> ----->map------> List<String>\r\n *\r\n * @param list\r\n * @param productName\r\n * @return\r\n */\r\npublic static List<String> getPrice(List<NetMall> list, String productName) {\r\n\r\n    //格式：《mysql》 in taobao price is 90.43\r\n    return list\r\n            .stream()\r\n            .map(netMall ->\r\n                    String.format(productName + \" in %s price is %.2f\",\r\n                            netMall.getNetMallName(),\r\n                            netMall.calcPrice(productName)))\r\n            .collect(Collectors.toList());\r\n}\r\n```\r\n\r\n\r\n\r\n**main函数测试**\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    long startTime = System.currentTimeMillis();\r\n    List<String> list1 = getPrice(list, \"mysql\");\r\n    for (String element : list1) {\r\n        System.out.println(element);\r\n    }\r\n    long endTime = System.currentTimeMillis();\r\n    System.out.println(\"----costTime：\" + (endTime - startTime) + \" 毫秒\");\r\n}\r\n```\r\n\r\n\r\n\r\n### 使用异步任务实现\r\n\r\n\r\n\r\n**异步任务方法**\r\n\r\n```java\r\n/**\r\n * List<NetMall> ----->List<CompletableFuture<String>>------> List<String>\r\n * @param list\r\n * @param productName\r\n * @return\r\n */\r\npublic static List<String> getPriceByCompletableFuture(List<NetMall> list, String productName) {\r\n    return list\r\n            .stream()\r\n            .map(netMall ->\r\n                    CompletableFuture.supplyAsync(() ->\r\n                            String.format(productName + \" in %s price is %.2f\",\r\n                                    netMall.getNetMallName(),\r\n                                    netMall.calcPrice(\"mysql\"))))\r\n            .collect(Collectors.toList())\r\n            .stream()\r\n            .map(s -> s.join())\r\n            .collect(Collectors.toList());\r\n}\r\n```\r\n\r\n\r\n\r\n**main函数测试**\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\r\n    long startTime2 = System.currentTimeMillis();\r\n    List<String> list2 = getPriceByCompletableFuture(list, \"mysql\");\r\n    for (String price : list2) {\r\n        System.out.println(price);\r\n    }\r\n    long endTime2 = System.currentTimeMillis();\r\n    System.out.println(\"----costTime：\" + (endTime2 - startTime2) + \" 毫秒\");\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### 两种方法结合对比（完整代码）\r\n\r\n```java\r\n/**\r\n * 案例说明：电商比价需求，模拟如下情况：\r\n * <p>\r\n * 1需求：\r\n * 1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;\r\n * 1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\r\n * <p>\r\n * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\r\n * 《mysql》 in jd price is 88.05\r\n * 《mysql》 in dangdang price is 86.11\r\n * 《mysql》 in taobao price is 90.43\r\n * <p>\r\n * 3 技术要求\r\n * 3.1 函数式编程\r\n * 3.2 链式编程\r\n * 3.3 Stream流式计算\r\n */\r\npublic class CompletableFutureMallDemo2 {\r\n\r\n    static List<NetMall> list = Arrays.asList(\r\n            new NetMall(\"jd\"),\r\n            new NetMall(\"dangdang\"),\r\n            new NetMall(\"taoabo\"),\r\n            new NetMall(\"pdd\"),\r\n            new NetMall(\"tmall\")\r\n    );\r\n\r\n    /**\r\n     * step by step 一家家搜查\r\n     * List<NetMall> ----->map------> List<String>\r\n     *\r\n     * @param list\r\n     * @param productName\r\n     * @return\r\n     */\r\n    public static List<String> getPrice(List<NetMall> list, String productName) {\r\n\r\n        //格式：《mysql》 in taobao price is 90.43\r\n        return list\r\n                .stream()\r\n                .map(netMall ->\r\n                        String.format(productName + \" in %s price is %.2f\",\r\n                                netMall.getNetMallName(),\r\n                                netMall.calcPrice(productName)))\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    /**\r\n     * List<NetMall> ----->List<CompletableFuture<String>>------> List<String>\r\n     * @param list\r\n     * @param productName\r\n     * @return\r\n     */\r\n    public static List<String> getPriceByCompletableFuture(List<NetMall> list, String productName) {\r\n        return list\r\n                .stream()\r\n                .map(netMall ->\r\n                        CompletableFuture.supplyAsync(() ->\r\n                                String.format(productName + \" in %s price is %.2f\",\r\n                                        netMall.getNetMallName(),\r\n                                        netMall.calcPrice(\"mysql\"))))\r\n                .collect(Collectors.toList())\r\n                .stream()\r\n                .map(s -> s.join())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        long startTime = System.currentTimeMillis();\r\n        List<String> list1 = getPrice(list, \"mysql\");\r\n        for (String element : list1) {\r\n            System.out.println(element);\r\n        }\r\n        long endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime：\" + (endTime - startTime) + \" 毫秒\");\r\n\r\n        System.out.println(\"----------------------------\");\r\n\r\n        long startTime2 = System.currentTimeMillis();\r\n        List<String> list2 = getPriceByCompletableFuture(list, \"mysql\");\r\n        for (String price : list2) {\r\n            System.out.println(price);\r\n        }\r\n        long endTime2 = System.currentTimeMillis();\r\n        System.out.println(\"----costTime：\" + (endTime2 - startTime2) + \" 毫秒\");\r\n\r\n    }\r\n}\r\n\r\n@Data\r\nclass NetMall {\r\n    private String netMallName;\r\n\r\n    public NetMall(String netMallName) {\r\n        this.netMallName = netMallName;\r\n    }\r\n\r\n    //查询该电商平台的售价\r\n    public double calcPrice(String productName) {\r\n        try {\r\n            TimeUnit.SECONDS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**运行结果：**\r\n\r\n```shell\r\nmysql in jd price is 109.43\r\nmysql in dangdang price is 109.62\r\nmysql in taoabo price is 110.34\r\nmysql in pdd price is 110.01\r\nmysql in tmall price is 109.72\r\n----costTime：5085 毫秒\r\n----------------------------\r\nmysql in jd price is 110.60\r\nmysql in dangdang price is 110.07\r\nmysql in taoabo price is 109.15\r\nmysql in pdd price is 110.24\r\nmysql in tmall price is 109.89\r\n----costTime：1022 毫秒\r\n```\r\n\r\n\r\n\r\n','image/JUC01.assets/image-20230712195903638.png','原创',2,_binary '',_binary '',_binary '\0','2023-07-22 22:02:22','2023-07-22 22:02:37',2022576839,'JUC01-Future接口、CompletableFuture异步任务、Java8函数式接口和Stream流式编程',NULL,NULL,'0'),(1682753916854366210,'JUC02-多线程锁、线程中断机制、LockSupport线程间通信','[TOC]\r\n\r\n\r\n\r\n# JUC02\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- 多线程锁各种锁的概览	\r\n  - <font color=\'red\'>获得所得流程</font>\r\n\r\n- <font color=\'red\'>线程中断机制</font>\r\n- <font color=\'red\'>LockSupport的pork替换wait和await方法</font>\r\n\r\n\r\n\r\n# 多线程锁\r\n\r\n\r\n\r\n## 悲观锁和乐观锁\r\n\r\n\r\n\r\n- **悲观锁**\r\n  - 显式的<font color=\'red\'>锁定之后再操作同步资源</font>\r\n\r\n  - 适合**写操作多**的场景，先加锁可以保证写操作时数据正确。\r\n\r\n  - <font color=\'cornflowerblue\'>synchronized</font>关键字和<font color=\'cornflowerblue\'>lock</font>的实现类都是采用悲观锁\r\n\r\n- **乐观锁**\r\n- 认为自己在使用数据时<font color=\'red\'>不会有别的线程修改数据或资源</font>，所以不会添加锁。\r\n\r\n- 在Java中是通过使用<font color=\'cornflowerblue\'>无锁编程</font>来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。\r\n\r\n  - 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。\r\n\r\n  - 如果这个数据己经被其它线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改、重试抢锁等等\r\n\r\n- 判断规则\r\n\r\n  - 1 版本号机制Version\r\n\r\n  - 2<font color=\'red\'> 最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</font>\r\n\r\n- 适合**读操作多**的场景，不加锁的特点能够使其读操作的性能大幅提升。\r\n\r\n\r\n\r\n## synchronized\r\n\r\n### synchronized 8锁案例演示\r\n\r\n\r\n\r\n阿里开发手册：\r\n\r\n> 【强制】高并发时，同步调用应该去考量锁的性能损耗。**能用无锁数据结构，就不要用锁**；**能锁区块，就不要锁整个方法体**；**能用对象锁，就不要用类锁**。\r\n>\r\n> 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。\r\n\r\n\r\n\r\n先说结论：\r\n\r\n- 作用于<font color=\'cornflowerblue\'>实例方法</font>，当前实例加锁，进入同步代码前要获得当前实例的锁；\r\n- 作用于<font color=\'cornflowerblue\'>代码块</font>，对括号里配置的对象加锁。\r\n- 作用于<font color=\'cornflowerblue\'>静态方法</font>，当前类加锁，进去同步代码前要获得当前类对象的锁；\r\n\r\n\r\n\r\n**案例演示：**\r\n\r\n```java\r\n//资源类\r\nclass Phone {\r\n    public static synchronized void sendEmail() {\r\n        try {TimeUnit.SECONDS.sleep(3);} catch (InterruptedException e) {e.printStackTrace();}\r\n        System.out.println(\"-----sendEmail\");\r\n    }\r\n\r\n    public synchronized void sendSMS() {\r\n        System.out.println(\"-----sendSMS\");\r\n    }\r\n\r\n    public void hello() {\r\n        System.out.println(\"-------hello\");\r\n    }\r\n}\r\n\r\n/**\r\n * 题目：谈谈你对多线程锁的理解,8锁案例说明\r\n * 口诀：线程   操作  资源类\r\n * 8锁案例说明：\r\n * 1 标准访问有ab两个线程，请问先打印邮件还是短信\r\n * 2 sendEmail方法中加入暂停3秒钟，请问先打印邮件还是短信\r\n * 3 添加一个普通的hello方法，请问先打印邮件还是hello\r\n * 4 有两部手机，请问先打印邮件还是短信\r\n * 5 有两个静态同步方法，有1部手机，请问先打印邮件还是短信\r\n * 6 有两个静态同步方法，有2部手机，请问先打印邮件还是短信\r\n * 7 有1个静态同步方法，有1个普通同步方法,有1部手机，请问先打印邮件还是短信\r\n * 8 有1个静态同步方法，有1个普通同步方法,有2部手机，请问先打印邮件还是短信\r\n * <p>\r\n * 笔记总结：\r\n * 1-2\r\n * 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，\r\n * 其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法\r\n * 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法\r\n * 3-4\r\n * 加个普通方法后发现和同步锁无关\r\n * 换成两个对象后，不是同一把锁了，情况立刻变化。\r\n * <p>\r\n * 5-6 都换成静态同步方法后，情况又变化\r\n * 三种 synchronized 锁的内容有一些差别:\r\n * 对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——>实例对象本身，\r\n * 对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板\r\n * 对于同步方法块，锁的是 synchronized 括号内的对象\r\n * <p>\r\n * 7-8\r\n * 当一个线程试图访问同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁。\r\n * <p>\r\n * 所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this\r\n * 也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。\r\n * <p>\r\n * 所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class\r\n * 具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的\r\n * 但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。\r\n */\r\npublic class Lock8Demo {\r\n    //一切程序的入口\r\n    public static void main(String[] args) {\r\n        Phone phone = new Phone();\r\n        Phone phone2 = new Phone();\r\n\r\n        new Thread(() -> {\r\n            phone.sendEmail();\r\n        }, \"a\").start();\r\n\r\n        //暂停毫秒,保证a线程先启动\r\n        try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n\r\n        new Thread(() -> {\r\n            //phone.sendSMS();\r\n            //phone.hello();\r\n            phone2.sendSMS();\r\n        }, \"b\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### synchronized字节码分析\r\n\r\n\r\n\r\n编译后找到项目下out文件夹，从需要反编译的文件处打开终端，使用以下命令进行反编译 .class 文件：\r\n\r\n```\r\njavap -c ****.class\r\n\r\n//假如你需要更多信息\r\njavap -v ****.class\r\n```\r\n\r\n\r\n\r\n**1 synchronized同步代码块**\r\n\r\n- 实现使用的是**monitorenter**和**monitorexit**指令\r\n\r\n- 一般情况就是1个enter对应2个exit\r\n  - 当正常处理时会有一个monitorexit，考虑到当发生异常时，也应该有一个monitorexit\r\n- 极端情况下：m1方法里面自己添加一个异常，只会有一个exit\r\n\r\n\r\n\r\n**一般情况下：**\r\n\r\n![image-20230714154848428](http://47.115.207.49/image/JUC02.assets/image-20230714154848428.png)\r\n\r\n\r\n\r\n**自己添加异常**\r\n\r\n![image-20230714154932879](http://47.115.207.49/image/JUC02.assets/image-20230714154932879.png)\r\n\r\n\r\n\r\n**2 synchronized普通同步方法**\r\n\r\n- 调用指令将会检查方法的**ACC_SYNCHRONIZED**访问标志是否被设置如果设置了，执行线程会将先持有monitor锁，然后再执行方法，**最后在方法完成（无论是正常完成还是非正常完成）时释放monitor**\r\n\r\n\r\n\r\n![image-20230714155624251](http://47.115.207.49/image/JUC02.assets/image-20230714155624251.png)\r\n\r\n\r\n\r\n**3 synchronized静态同步方法**\r\n\r\n- 调用指令将会检查方法的**ACC_STATIC**和**ACC_SYNCHRONIZED**访问标志是否被设置如果设置了\r\n\r\n\r\n\r\n![image-20230714155833992](http://47.115.207.49/image/JUC02.assets/image-20230714155833992.png)\r\n\r\n\r\n\r\n### 为什么任何一个对象都可以成为一个锁？\r\n\r\n\r\n\r\n![image-20230714165537334](http://47.115.207.49/image/JUC02.assets/image-20230714165537334.png)\r\n\r\n![image-20230714161122065](http://47.115.207.49/image/JUC02.assets/image-20230714161122065.png)\r\n\r\n\r\n\r\n## 公平锁和非公平锁\r\n\r\n\r\n\r\n- 公平锁\r\n\r\n  - 是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买后来的人在队尾排着，这是公平的\r\n\r\n  - Lock lock=new ReentrantLock(true);//true<font color=\'red\'>表示公平锁，先来先得</font>\r\n\r\n- 非公平锁\r\n  - 多个线程抢占锁，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，**有可能造成优先级翻转或者饥饿的状态**（某个线程一直得不到锁）\r\n  - Lock lock=new ReentrantLock(false);//false<font color=\'red\'>表示非公平锁，后来的也可能先获得锁</font>\r\n  - Lock lock=new ReentrantLock();//默认非公平锁\r\n\r\n\r\n\r\n#### 为什么会有公平锁/非公平锁的设计？为什么默认非公平？\r\n\r\n恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。\r\n\r\n所以<font color=\'red\'>非公平锁能更充分的利用CPU的时间片，尽量**减少CPU空闲状态时间**</font>。\r\n\r\n使用多线程很重要的考量点是**线程切换的开销**，当采用非公平锁时，<font color=\'red\'>当1个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就**减少了线程的开销**。</font>\r\n\r\n\r\n\r\n## 可重入锁（递归锁）\r\n\r\n\r\n\r\n**可重入锁又名递归锁**\r\n\r\n- 是指在<font color=\'cornflowerblue\'>同一个线程</font>在外层方法获取锁的时候，再进入该线程的内层方法会<font color=\'cornflowerblue\'>自动获取锁</font>（**前提，锁对象得是同一个对象**），不会因为之前已经获取过还没释放而阻塞。\r\n- 如果是1个有synchronized修饰的递归调用方法，<font color=\'cornflowerblue\'>程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。</font>\r\n- 所以<font color=\'red\'>Java中ReentrantLock和synchronized都是可重入锁</font>，可重入锁的一个优点是可一定程度避免死锁。\r\n\r\n\r\n\r\n**隐式锁：即synchronized使用的锁**\r\n\r\n- 指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。\r\n- 简单的来说就是：<font color=\'red\'>在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</font>\r\n\r\n\r\n\r\n**显式锁：即ReentrantLock**\r\n\r\n- 需要显示指定\r\n\r\n- lock几次，就需要unlock几次，否则会让其他线程无法获得锁造成卡死\r\n\r\n\r\n\r\n**Synchronized的重入的实现机理**\r\n\r\n- <font color=\'red\'>每个锁对象拥有一个**锁计数器（_count 和 _recursions）**和一个指向持有该锁的线程的**指针（_owner）**。</font>（记录在对象的对象头中）\r\n- 当执行monitorenterl时，如果目标锁对象的_count 为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。\r\n- 在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。\r\n- 当执行monitorexit指令时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。\r\n\r\n具体全部过程可在小总结中查看\r\n\r\n\r\n\r\n**可重入锁案例演示**\r\n\r\n```java\r\npublic class SyncLockDemo {\r\n\r\n    public synchronized void add() {\r\n        add();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        /**\r\n         * 可重入锁（递归锁）：多层锁机制只需要同一把锁即可自由出入\r\n         * synchronized(隐式)    lock(显式)\r\n         */\r\n        //synchronized可重入锁演示1：\r\n        Object o = new Object();\r\n        new Thread(() -> {\r\n            synchronized (o){\r\n                System.out.println(Thread.currentThread().getName() + \"外层\");\r\n\r\n                synchronized (o){\r\n                    System.out.println(Thread.currentThread().getName() + \"中层\");\r\n\r\n                    synchronized (o){\r\n                        System.out.println(Thread.currentThread().getName() + \"内层\");\r\n                    }\r\n                }\r\n            }\r\n        },\"t1\").start();\r\n\r\n\r\n        //synchronized可重入锁演示2：\r\n        new SyncLockDemo().add();   //将会报栈内存溢出，证明可以递归调用add方法自己，是可重入锁\r\n    }\r\n\r\n    /**\r\n     * lock演示可重入锁       递归使用锁必须一上锁对应一解锁，加入内部锁上锁了不解锁，自己线程使用会没问题，但是会影响其它线程\r\n     */\r\n    @Test\r\n    public void testLock() {\r\n        Lock lock = new ReentrantLock();\r\n        new Thread(() -> {\r\n            try {\r\n                lock.lock();\r\n                System.out.println(Thread.currentThread().getName() + \" 外层\");\r\n\r\n                try {\r\n                    //上锁\r\n                    lock.lock();\r\n                    System.out.println(Thread.currentThread().getName() + \" 内层\");\r\n                } finally {\r\n                    //释放锁\r\n                    lock.unlock();\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }, \"t1\").start();\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 死锁\r\n\r\n\r\n\r\n死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种<font color=\'red\'>互相等待的现象</font>，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。\r\n\r\n\r\n\r\n**排查死锁**\r\n\r\n- ```\r\n  jps -l\r\n  jstack 进程id\r\n  ```\r\n\r\n- 使用jconsole -> 线程 -> 检测死锁\r\n\r\n\r\n\r\n![image-20230711160927379](http://47.115.207.49/image/JUC02.assets/image-20230714161122066.png)\r\n\r\n\r\n\r\n**手写一个死锁案例**\r\n\r\n```java\r\n/**\r\n * 死锁：两个或者两个以上进程在执行过程中，因为争夺资源而造成一种互相等待的现象，如果设有外力干涉，他们无法再执行下去\r\n * \r\n * 死锁的验证方式：第一步：jps  第二步：jstack 进程号\r\n */\r\npublic class DeadLockDemo {\r\n    \r\n    //先创建两个对象充当两把锁\r\n    static Object a = new Object();\r\n    static Object b = new Object();\r\n\r\n    public static void main(String[] args) {\r\n        new Thread(() -> {\r\n            synchronized (a){\r\n                System.out.println(Thread.currentThread().getName() + \"持有锁a，试图获取锁b\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (b){\r\n                    System.out.println(Thread.currentThread().getName() + \"获取锁b\");\r\n                }\r\n            }\r\n        },\"A\").start();\r\n\r\n        new Thread(() -> {\r\n            synchronized (b){\r\n                System.out.println(Thread.currentThread().getName() + \"持有锁b，试图获取锁a\");\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                synchronized (a){\r\n                    System.out.println(Thread.currentThread().getName() + \"获取锁a\");\r\n                }\r\n            }\r\n        },\"B\").start();\r\n    }    \r\n```\r\n\r\n\r\n\r\n## ==小总结：获得锁的全流程（重要）==\r\n\r\n\r\n\r\n指针指向**monitor对象**（也称为**管程或监视器锁**）的起始地址。**每个对象都存在着一个monitor与之关联**，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由**ObjectMonitor**实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）\r\n\r\nObjectMonitor.hpp在目录 `为什么任何一个对象都可以成为一个锁？` 中提到过\r\n\r\n\r\n\r\n![image-20230714170452735](http://47.115.207.49/image/JUC02.assets/image-20230714170452735.png)\r\n\r\n\r\n\r\n## 后续锁的知识\r\n\r\nsynchronized锁升级将在《JUC06》中讲解\r\n\r\nlock QAS将在《JUC07》中讲解\r\n\r\nlock锁的发展过程将在《JUC08》中讲解\r\n\r\n\r\n\r\n# LockSupport与线程中断\r\n\r\n\r\n\r\n## 中断机制\r\n\r\n\r\n\r\n**什么是中断机制？**\r\n\r\n首先\r\n\r\n一个线程不应该由其他线程来强制中断或停止，而是<font color=\'red\'>应该由线程自己自行停止</font>，自己来决定自己的命运。\r\n\r\n所以，**Thread.stop,Thread.suspend,Thread.resume**都己经被废弃了。\r\n\r\n\r\n\r\n其次\r\n\r\n在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。\r\n\r\n因此，Java提供了一种用于停止线程的<font color=\'cornflowerblue\'>协商机制</font>——中断，也即**中断标识协商机制**。\r\n\r\n\r\n\r\n<font color=\'red\'>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</font>\r\n\r\n若要中断一个线程，你需要手动调用该线程的interrupt方法，<font color=\'red\'>该方法也仅仅是将线程对象的**中断标识设成true**;</font>\r\n\r\n接着你需要自己写代码不断地检测当前线程的标识位，如果为tue,表示别的线程请求这条线程中断，\r\n\r\n此时究竞该做什么需要你自己写代码实现。\r\n\r\n\r\n\r\n每个线程对象中都有一个中断标识位，用于表示线程是否被中断；该标识位为tue表示中断，为false表示未中断：\r\n\r\n<font color=\'red\'>**通过调用线程对象的interrupt方法将该线程的标识位设为true;可以在别的线程中调用，也可以在自己的线程中调用**</font>。\r\n\r\n\r\n\r\n## 中断机制API 的三大方法 \r\n\r\n\r\n\r\n### 总述\r\n\r\n\r\n\r\n| public void interrupt()             | <font color=\'cornflowerblue\'>实例方法</font>，Just to set the interrupt <br />实例方法interrupt()仅仅是<font color=\'red\'>设置线程的中断状态为true，发起一个协商而不会立刻停止线程</font> |\r\n| ----------------------------------- | ------------------------------------------------------------ |\r\n| public static boolean interrupted() | <font color=\'cornflowerblue\'>静态方法</font>，Thread.interrupted();<br /><font color=\'red\'>判断线程是否被中断并清除当前中断状态。</font><br />这个方法做了两件事：<br /><font color=\'red\'>1返回当前线程的中断状态，测试当前线程是否已被中断</font><br/><font color=\'red\'>2将当前线程的中断状态清零并重新设为false,清除线程的中断状态</font><br /><br /><font color=\'red\'>如果连续两次调用此方法，则第二次调用将返回false,因为连续调用两次的结果可能不一样</font> |\r\n| public boolean isInterrupted()      | <font color=\'cornflowerblue\'>实例方法</font>，<br/>判断当前线程是否被中断（通过检查中断标志位） |\r\n\r\n\r\n\r\n### interrupt()详解与演示\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>具体来说，当对一个线程，调用interrupt()时：</font>\r\n\r\n- ①如果线程处于<font color=\'red\'>**正常活动状态**</font>，那么会将该线程的中断标志设置为tue,<font color=\'red\'>仅此而已</font>。\r\n\r\n​		<font color=\'red\'>被设置中断标志的线程将继续正常运行，不受影响。</font>\r\n\r\n​		所以，interrupt)(并不能真正的中断线程，需要被调用的线程自己进行配合才行。\r\n\r\n​		<font color=\'red\'>若**线程结束**，中断标志会被重置，即false</font>\r\n\r\n​		中断只是一种协商机制，修改中断标识位仅此而己，不是立刻stop打断\r\n\r\n- ②如果线程处于<font color=\'red\'>**被阻塞状态**</font>（例如处于sleep,wait,join等状态），在别的线程中调用当前线程对象的interrupt方法，\r\n\r\n​		那么线程将<font color=\'red\'>立即退出被阻塞状态，中断标志被清空为false，并抛出一个InterruptedException异常，导致无限循环</font>。\r\n\r\n​		需要在异常处理catch中再次调用interrupt()\r\n\r\n\r\n\r\n**正常活动状态案例演示**\r\n\r\n```java\r\n/**\r\n * 正常活动状态案例演示\r\n */\r\npublic class InterruptDemo2 {\r\n    public static void main(String[] args) {\r\n        //实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程\r\n        Thread t1 = new Thread(() -> {\r\n            for (int i = 1; i <= 300; i++) {\r\n                System.out.println(\"-----: \" + i);\r\n            }\r\n            System.out.println(\"t1线程调用interrupt()后的的中断标识02：\" + Thread.currentThread().isInterrupted());\r\n        }, \"t1\");\r\n        t1.start();\r\n\r\n        System.out.println(\"t1线程默认的中断标识：\" + t1.isInterrupted());//false\r\n\r\n        //暂停毫秒\r\n        try {\r\n            TimeUnit.MILLISECONDS.sleep(2);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        t1.interrupt();//true\r\n        System.out.println(\"t1线程调用interrupt()后的的中断标识01：\" + t1.isInterrupted());//true\r\n        \r\n        try {TimeUnit.MILLISECONDS.sleep(2000);} catch (InterruptedException e) {e.printStackTrace();}\r\n        System.out.println(\"t1线程调用interrupt()后的的中断标识03：\" + t1.isInterrupted());//????---false中断不活动的线程不会产生任何影响。\r\n    }\r\n}\r\n```\r\n\r\n```\r\n...\r\nt1线程调用interrupt()后的的中断标识01：true\r\n...\r\nt1线程调用interrupt()后的的中断标识02：true\r\nt1线程调用interrupt()后的的中断标识03：false\r\n```\r\n\r\n\r\n\r\n**被阻塞状态案例演示**\r\n\r\n```java\r\n/**\r\n * 1 中断标志位，默认false\r\n * 2 t2 ----> t1发出了中断协商，t2调用t1.interrupt()，中断标志位true\r\n * 3 中断标志位true，正常情况，程序停止，^_^\r\n * 4 中断标志位true，异常情况，InterruptedException，将会把中断状态将被清除，并且将收到InterruptedException 。中断标志位false\r\n *    导致无限循环\r\n *\r\n * 5 在catch块中，需要再次给中断标志位设置为true，2次调用停止程序才OK\r\n */\r\npublic class InterruptDemo3 {\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(() -> {\r\n            while (true) {\r\n                if (Thread.currentThread().isInterrupted()) {\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t \" +\r\n                            \"中断标志位：\" + Thread.currentThread().isInterrupted() + \" 程序停止\");\r\n                    break;\r\n                }\r\n                //设置线程为阻塞状态，即上述第4点\r\n                try {\r\n                    Thread.sleep(200);\r\n                } catch (InterruptedException e) {\r\n                    Thread.currentThread().interrupt();//需要再次自己在catch中调用interrupt()，否则无限循环\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"----------hello InterruptDemo3\");\r\n            }\r\n        }, \"t1\");\r\n        \r\n        t1.start();\r\n        \r\n        try {TimeUnit.SECONDS.sleep(1);} catch (InterruptedException e) {e.printStackTrace();}\r\n        \r\n        new Thread(() -> t1.interrupt(),\"t2\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### interrupted()相较于isInterrupted()\r\n\r\n\r\n\r\n![image-20230714211323669](http://47.115.207.49/image/JUC02.assets/image-20230714211323669.png)\r\n\r\n可以看到两个方法底层都是调用同一份native方法，“中断状态将会根据传入的**Clearlnterrupted**参数值确定是否重置”。\r\n\r\n- 所以，静态方法interrupted将会清除中断状态（传入的参数Clearlnterrupted为true),\r\n- 实例方法isInterrupted则不会（传入的参数Clearlnterrupted.为false)。\r\n\r\n\r\n\r\n**案例演示**\r\n\r\n```java\r\npublic class InterruptDemo4 {\r\n    public static void main(String[] args) {\r\n        //测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，\r\n        // 第二次再调用时中断状态已经被清除，将返回一个false。\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());\r\n        System.out.println(\"----1\");\r\n        Thread.currentThread().interrupt();// 中断标志位设置为true\r\n        System.out.println(\"----2\");\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());\r\n    }\r\n}\r\n```\r\n\r\n```\r\nfalse\r\nfalse\r\ntrue\r\nfalse\r\n```\r\n\r\n\r\n\r\n## 中断或停止运行中的线程的方法\r\n\r\n\r\n\r\n### 通过volatile或AtomicBoolean实现停止\r\n\r\n```java\r\n/**\r\n * 通过volatile或AtomicBoolean实现中断停止线程\r\n */\r\npublic class InterruptDemo {\r\n    static volatile boolean isStop = false;\r\n    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);\r\n    \r\n    public static void main(String[] args) {\r\n        new Thread(() -> {\r\n            while (true) {\r\n                if (atomicBoolean.get()){\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t atomicBoolean 被修改未true，程序停止\");\r\n                    break;\r\n                }\r\n                System.out.println(\"t1---------hello atomicBoolean\");\r\n            }\r\n        },\"t1\").start();\r\n\r\n        try {TimeUnit.MILLISECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n\r\n        new Thread(() -> {\r\n            atomicBoolean.set(true);\r\n        },\"t2\").start();\r\n    }\r\n\r\n    private static void m1_volatile() {\r\n        new Thread(() -> {\r\n            while (true) {\r\n                if (isStop){\r\n                    System.out.println(Thread.currentThread().getName() + \"\\t isStop 被修改未true，程序停止\");\r\n                    break;\r\n                }\r\n                System.out.println(\"t1---------hello volatile\");\r\n            }\r\n        },\"t1\").start();\r\n\r\n        try {TimeUnit.MILLISECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n\r\n        new Thread(() -> {\r\n            isStop = true;\r\n        },\"t2\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 通过interrupt实现中断\r\n\r\n```java\r\nThread t1 = new Thread(() -> {\r\n    while (true) {\r\n        if (Thread.currentThread().isInterrupted()) {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t isInterrupted() 被修改为true，程序停止\");\r\n            break;\r\n        }\r\n        System.out.println(\"t1---------hello isInterrupted()\");\r\n    }\r\n}, \"t1\");\r\nt1.start();\r\n\r\ntry {TimeUnit.MILLISECONDS.sleep(20);} catch (InterruptedException e) {e.printStackTrace();}\r\n\r\nnew Thread(() -> {\r\n    t1.interrupt();\r\n},\"t2\").start();\r\n```\r\n\r\n\r\n\r\n## ==如何中断或停止一个运行中的线程？==\r\n\r\n![image-20230714171511553](http://47.115.207.49/image/JUC02.assets/image-20230714171511553.png)\r\n\r\n**停止：**\r\n\r\n- 使用volatile或AtomicBoolean时，将他们的变量或实例设置为true，让线程中断\r\n- 线程自己自行停止是否停止线程，自己来决定自己的命运。所以，**Thread.stop,Thread.suspend,Thread.resume**都己经被废弃了。\r\n\r\n**中断：**\r\n\r\n- 使用interrupt()方法设置中断标志为true，并由线程自己配合进行中断停止\r\n\r\n\r\n\r\n## LockSupport\r\n\r\n\r\n\r\nLockSupport中的park()和unpark()的作用分别是阻塞线程和解除阻塞线程\r\n\r\n\r\n\r\n### 让线程等待和唤醒的方法\r\n\r\n即实现线程间通信的方法\r\n\r\n- <font color=\'cornflowerblue\'>方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</font>\r\n  - wait方法和notify方法，两个都必须放在同步代码块内，否则抛出异常\r\n  - 先执行notify，再执行wait方法时，程序无法继续执行，wait线程无法被唤醒\r\n- <font color=\'cornflowerblue\'>方式2：使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</font>\r\n  - await方法和signal方法，两个都必须放在同步代码块内，否则抛出异常\r\n  - 先执行signal，再执行await方法时，程序无法继续执行，wait线程无法被唤醒\r\n- <font color=\'red\'>方式3：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</font>\r\n  - 解决上面两种方法的问题\r\n  - 凭证最多只能有1个，累加无效，只能调用一对park()和unpark()\r\n  - 在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的\r\n\r\n\r\n\r\n### 使用Object和Condition的限制条件\r\n\r\n- 线程先要获得并持有锁，必须在锁块（synchronized或Iock）中\r\n- 必须要先等待后唤醒，线程才能够被唤醒\r\n\r\n\r\n\r\n**案例演示：**\r\n\r\n```java\r\n/**\r\n * Object的wait()演示：\r\n * 1 在同步代码块中先wait再notify：下程序正常运行\r\n * 2 没有同步代码块：报异常\r\n * 3 在同步代码块中先notify再wait：wait线程不能被唤醒\r\n */\r\nprivate static void syncWaitNotify() {\r\n    Object objectLock = new Object();\r\n\r\n    new Thread(() -> {\r\n        //try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        synchronized (objectLock){\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----come in\");\r\n            try {\r\n                objectLock.wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----被唤醒\");\r\n        }\r\n    },\"t1\").start();\r\n\r\n    //暂停几秒钟线程\r\n    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n    new Thread(() -> {\r\n        synchronized (objectLock){\r\n            objectLock.notify();\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----发出通知\");\r\n        }\r\n    },\"t2\").start();\r\n}\r\n```\r\n\r\n```java\r\n/**\r\n * Condition的await()演示：\r\n * 1 在同步代码块中先await再signal：下程序正常运行\r\n * 2 没有同步代码块：报异常\r\n * 3 在同步代码块中先ignal再await：await线程不能被唤醒\r\n */\r\nprivate static void lockAwaitSignal() {\r\n    Lock lock = new ReentrantLock();\r\n    Condition condition = lock.newCondition();\r\n\r\n    new Thread(() -> {\r\n        //try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        lock.lock();\r\n        try {\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----come in\");\r\n            condition.await();\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----被唤醒\");\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    },\"t1\").start();\r\n\r\n    //暂停几秒钟线程\r\n    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n    new Thread(() -> {\r\n        lock.lock();\r\n        try\r\n        {\r\n            condition.signal();\r\n            System.out.println(Thread.currentThread().getName()+\"\\t ----发出通知\");\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    },\"t2\").start();\r\n}\r\n```\r\n\r\n\r\n\r\n### ==使用LockSupport==\r\n\r\n\r\n\r\nLockSupport是基于**Unsafe**类，由JDK提供的线程操作工具类，主要作用就是挂起线程，唤醒线程。\r\n\r\n\r\n\r\n**park()方法源码**\r\n\r\n```java\r\npublic static void park() {\r\n    UNSAFE.park(false, 0L);\r\n}\r\n```\r\n\r\npermiti许可证默认没有不能放行，所以一开始调park()方法当前线程就会阻塞，直到别的线程给当前线程的发放permit,park方法才会被唤醒。\r\n\r\n**unpark()方法源码**\r\n\r\n```java\r\npublic static void unpark(Thread thread) {\r\n    if (thread != null)\r\n        UNSAFE.unpark(thread);\r\n}\r\n```\r\n\r\n调用unpark(thread)方法后，就会将thread线程的许可证permit发放，会自动唤醒park线程，即之前阻塞中的LockSupport.park()方法会立即返回。\r\n\r\n\r\n\r\n<font color=\'red\'>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</font>\r\n\r\nLockSupport是一个线程阻塞工具类，**所有的方法都是静态方法**，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupporti调用的Unsafe中的native代码。\r\n\r\n<font color=\'cornflowerblue\'>LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程</font>\r\n\r\nLockSupport和每个使用它的线程都有一个许可(permit)关联：\r\n\r\n每个线程都有一个相关的permit，<font color=\'cornflowerblue\'>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。permiti最多只有一个，重复调用unpark也不会积累凭证</font>。\r\n\r\n<font color=\'cornflowerblue\'>当调用park()方法时</font>\r\n\r\n- 如果有凭证，则会直接消耗掉这个凭证然后正常退出：\r\n- 如果无凭证，就必须阻塞等待凭证可用：\r\n\r\n<font color=\'cornflowerblue\'>而unpark()则相反</font>，它会增加一个凭证，但<font color=\'red\'>凭证最多只能有1个，累加无效。</font>\r\n\r\n\r\n\r\n**优缺点总结：**\r\n\r\n- 解决上面两种方法的问题\r\n- 凭证最多只能有1个，累加无效，只能调用一对park()和unpark()\r\n- <font color=\'red\'>在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的</font>\r\n\r\n\r\n\r\n**为什么可以突破wait/notify的原有调用顺序？**\r\n\r\n因为unpark获得了一个凭证，之后再调用pak方法，就可以名正言顺的凭证消费，故不会阻塞。\r\n\r\n先发放了凭证后续可以畅通无阻。\r\n\r\n**为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？**\r\n\r\n因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证；\r\n\r\n而调用两次park却需要消费两个凭证，证不够，不能放行。\r\n\r\n\r\n\r\n**案例演示**\r\n\r\n```java\r\n/**\r\n * LockSupport的park()演示：\r\n * 解决其它两个办法的问题\r\n * 但是：\r\n *  凭证最多只能有1个，累加无效，只能调用一对park()和unpark()\r\n *  在同步方法中时，park()不会释放锁，而上面方法的wait()是会释放锁的\r\n */\r\npublic static void main(String[] args) {\r\n    Thread t1 = new Thread(() -> {\r\n        try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----come in\"+System.currentTimeMillis());\r\n        LockSupport.park();\r\n        System.out.println(Thread.currentThread().getName() + \"\\t ----被唤醒\"+System.currentTimeMillis());\r\n    }, \"t1\");\r\n    t1.start();\r\n\r\n    //暂停几秒钟线程\r\n    //try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n    new Thread(() -> {\r\n        LockSupport.unpark(t1);\r\n        System.out.println(Thread.currentThread().getName()+\"\\t ----发出通知\");\r\n    },\"t2\").start();\r\n}\r\n```\r\n\r\n\r\n\r\n','image/JUC02.assets/image-20230714170452735.png','原创',0,_binary '',_binary '',_binary '\0','2023-07-22 22:06:12','2023-07-22 22:06:22',2022576839,'JUC02-多线程锁、线程中断机制、LockSupport线程间通信',NULL,NULL,'0'),(1682754138464612354,'JUC03-JMM、volatile','[TOC]\r\n\r\n\r\n\r\n# JUC03\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- JMM（Java内存模型）\r\n  - <font color=\'red\'>happendss-before先行发生原则</font>\r\n- volatile关键字\r\n  - <font color=\'red\'>内存屏障</font>\r\n\r\n\r\n\r\n\r\n\r\n# JMM(Java Memory Model)\r\n\r\n\r\n\r\n## JMM定义和作用\r\n\r\n\r\n\r\n**定义**\r\n\r\nJMM(Java内存模型Java Memory Model,简称JMM)本身是一种<font color=\'orange\'>抽象的</font>概念<font color=\'red\'>并不真实存在</font><font color=\'cornflowerblue\'>它仅仅描述的是一组约定或规范</font>，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的<font color=\'red\'>原子性、可见性和有序性</font>展开的。\r\n\r\n原则：\r\n\r\nJMM的关键技术点都是围绕多线程的<font color=\'red\'>原子性、可见性和有序性展开的</font>\r\n\r\n\r\n\r\n**作用**\r\n\r\n<font color=\'red\'>能干嘛？</font>\r\n\r\n1通过JMM来实现<font color=\'red\'>线程和主内存之间的抽象关系。</font>\r\n\r\n2<font color=\'red\'>屏蔽各个<font color=\'cornflowerblue\'>硬件平台</font>和<font color=\'cornflowerblue\'>操作系统</font>的内存访问差异</font>以实现让Java程序在各种平台下都能达到一致的内存访问效果。\r\n\r\n\r\n\r\n**通俗解释**\r\n\r\n电脑读写速度：\r\n\r\nCPU寄存器 > CPU缓存 > 主存 > 硬盘 > 网络\r\n\r\n因为有这么多级的缓存（cpu和物理主内存的速度不一致的），\r\n\r\nCPU的运行并<font color=\'red\'>不是直接操作内存而是先把内存里边的数据读到缓存</font>，而内存的读和写操作的时候就会造成不一致的问题\r\n\r\nJVM规范中试图定义一种Java内存模型(java Memory Model,简称JMM)来<font color=\'red\'>屏蔽掉各种硬件和操作系统的内存访问差异</font>，以实现让Java程序在各种平台下都能达到一致的内存访问效果。\r\n\r\n所以，推导出我们需要知道JMM\r\n\r\n\r\n\r\n## JMM三大特性\r\n\r\n\r\n\r\n### 可见性\r\n\r\n<font color=\'red\'>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更</font>，JMM规定了所有的变量都存储在<font color=\'red\'>主内存</font>。\r\n\r\n\r\n\r\n![image-20230715144410262](image/JUC03.assets/image-20230715144410262.png)\r\n\r\n\r\n\r\n系统主内存<font color=\'red\'>共享变量</font>数据修改被写入的时机是不确定的，<font color=\'cornflowerblue\'>多线程并发下很可能出现\"脏读\"</font>，所以每个线程都有自己的<font color=\'red\'>工作内存</font>，线程自己的工作内存中保存了该线程使用到的变量的<font color=\'red\'>主内存副本拷贝</font>，线程对变量的所有操作（读取，赋值等）都必需**在线程自己的工作内存中进行，而不能够直接读写主内存中的变量**。不同线程之间也无法直接访问对方工作内存中的变量，<font color=\'red\'>线程间变量值的传递均需要通过主内存来完成</font>\r\n\r\n\r\n\r\n### 原子性\r\n\r\n指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰\r\n\r\n\r\n\r\n### 有序性\r\n\r\n即是否指令重排\r\n\r\n**是什么**\r\n\r\n重排序是指编译器和处理器为了**优化程序性能**而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序\r\n\r\n- 不存在数据依赖关系，可以重排序；\r\n- <font color=\'red\'>存在数据依赖关系，禁止重排序</font>\r\n\r\n但重排后的指令绝对不能改变原有的串行语义！<font color=\'red\'>这点在并发设计中必须要重点考虑！</font>\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>数据依赖性：</font>若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。\r\n\r\n案例：\r\n\r\n<font color=\'red\'>不存在</font>数据依赖关系，可以重排序===><font color=\'cornflowerblue\'>重排序OK。</font>\r\n\r\n\r\n\r\n**优缺点**\r\n\r\nJVM能根据处理器特性(CPU多级缓存系统、多核处理器等)适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，\r\n\r\n指令重排可以<font color=\'red\'>保证串行语义一致</font>，但<font color=\'red\'>没有义务保证多线程间的语义也一致</font>（即可能产生\"脏读\"），简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，<font color=\'cornflowerblue\'>不见得是从上到下顺序执行，执行顺序</font><font color=\'red\'>会被优化。</font>\r\n\r\n**从源码到最终执行示例图：**\r\n\r\n![image-20230715150401023](image/JUC03.assets/image-20230715150401023.png)\r\n\r\n<font color=\'cornflowerblue\'>**单线程**环境里面确保程序最终执行结果和代码顺序执行的**结果一致**。</font>\r\n\r\n处理器在进行重排序时<font color=\'red\'>必须要考虑</font>指令之间的<font color=\'red\'>**数据依赖性**</font>\r\n\r\n<font color=\'cornflowerblue\'>**多线程**环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，**结果无法预测**。</font>\r\n\r\n\r\n\r\n总结：\r\n\r\n- 单线程指令重排后和代码顺序执行的结果一致\r\n- 多线程不确定\r\n\r\n\r\n\r\n## 多线程对变量的读写过程\r\n\r\n由于JVM运行程序的实体是线程，而每个线程创建时JMM都会为其创建一个工作内存（有些地方称为栈空闻），工作内存是每个线程的和有数据区域，而Jva内存模型中规定所有变量都存储在<font color=\'red\'>主内存</font>，主内存是共享内存区域，所有线程都可以访问，<font color=\'red\'>但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存考贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</font>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<font color=\'cornflowerblue\'>变量副本拷贝</font>，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：\r\n\r\n![image-20230715150900855](image/JUC03.assets/image-20230715150900855.png)\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>JMM定义了线程和主内存之间的抽象关系</font>\r\n\r\n1. 线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）\r\n2. 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本（从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等）\r\n\r\n**小总结**\r\n\r\n- 我们定义的所有共享变量都储存在<font color=\'red\'>物理主内存</font>中\r\n- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）\r\n- 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）\r\n- 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）\r\n- （自己加的？）<font color=\'red\'>操作volatile关键字修饰的变量可以违背这个规则，修改后直接刷新到主内存中，读取可直接从主内存读取</font>\r\n\r\n\r\n\r\n## 多线程先行发生原则happens-before\r\n\r\n\r\n\r\n在JMM中，如果一个操作<font color=\'red\'>执行的结果</font>需要对另一个操作拥有<font color=\'cornflowerblue\'>可见性</font>，或者<font color=\'cornflowerblue\'>代码重排序(有序性)</font>，那么这两个操作之间必须存在happens-before(先行发生)原则。拥有逻辑上的先后关系\r\n\r\n\r\n\r\n**先行发生原则说明**\r\n\r\n如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。\r\n\r\n<font color=\'red\'>我们没有<font color=\'cornflowerblue\'>时时、处处、次次</font>，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩，给你立好了规矩！</font>\r\n\r\n<font color=\'red\'>这个原则非常重要：</font>\r\n\r\n它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子<font color=\'cornflowerblue\'>解决并发环境下两个操作之间是否可能存在冲突的所有问题</font>，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。\r\n\r\n\r\n\r\n### ==happends-before总原则==\r\n\r\n\r\n\r\n- 如果一个操作happens-before另一个操作，**那么第一个操作的执行结果将对第二个操作可见**，而且第一个操作的执行顺序排在第二个操作之前。\r\n  - 即满足hapens-before前提下，操作满足可见性和有序性\r\n- 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的<font color=\'red\'>结果一致</font>，那么这种重排序<font color=\'red\'>并不非法</font>。\r\n  - 若发生了指令重排，只要结果一致，就合法，不一致就会被阻止\r\n\r\n\r\n\r\n### happends-befre细分8条原则\r\n\r\n\r\n\r\n掌握总原则即可，8条尽你所能\r\n\r\n\r\n\r\n<font color=\'red\'>**理所当然的语法顺序，就是happend-before**</font>\r\n\r\n1. 次序规则：\r\n   - <font color=\'red\'>一个线程内</font>，按照代码顺序，写在前面的操作先行发生于写在后面的操作；\r\n   - 前一个操作的结果可以被后续的操作获取。深说明讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经娈成了1。\r\n2. 锁定规则：\r\n   - 一个unLock操作<font color=\'red\'>先行发生于</font>后面(（这里的“后面”是指时间上的先后）)对同一个锁的Iock操作；\r\n3. volatile变量规则：\r\n   - 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，<font color=\'red\'>前面的写对后面的读是可见的</font>，这里的“后面”同样是指时间上的先后。\r\n4. 传递规则：\r\n   - 如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先行发生于操作C\r\n5. 线程启动规则(Thread Start Rule):\r\n   - Thread对象的start)方法先行发生于此线程的每一个动作，先start才能执行线程内的内容\r\n6. 线程中断规则(Thread Interruption Rule):\r\n   - 对线程interrupt)方法的调用先行发生于被中断线程的代码检测到中断事件的发生\r\n   - 可以通过Thread.interrupted()检测到是发生中断\r\n   - 也就是说你要先调用interrupt(()方法设置过中断标志位，我才能检测到中断发送\r\n7. 线程终止规则(Thread Termination Rule):\r\n   - 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive等手段检测线程是否已经终止执行。\r\n8. 对象终结规则(Finalizer Rule):\r\n   - 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始\r\n\r\n\r\n\r\n### happens-before-小总结\r\n\r\n在Java语言里面，Happens-Before的语义本质上是一种<font color=\'cornflowerblue\'>可见性</font>\r\n\r\nA Happens-Before B意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里。\r\n\r\n<font color=\'red\'>可见性以及在结果相同的情况下允许重排</font>\r\n\r\n\r\n\r\nJMM的设计分为两部分：\r\n\r\n- 一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了。\r\n- 另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。我们只需要关注前者就好了，也就是理解happens-before规则即可，其它繁杂的内容有JMM规范结合操作系统给我们搞定，我们只写好代码即可。\r\n\r\n\r\n\r\n## happens-before案例引出volatile\r\n\r\n\r\n\r\n**案例：**\r\n\r\n```java\r\npublic int value = 0;\r\npublic int getValue(){\r\n    return value;\r\n}\r\npublic int setValue(){\r\n    return ++value;\r\n}\r\n```\r\n\r\n假设存在线程A和B，线程A先（时间上的先后）调用了setValue()，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值\r\n是什么？\r\n\r\n\r\n\r\n**分析过程：**\r\n\r\n我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8可以忽略，因为他们和这段代码毫无关系）：\r\n\r\n- 1由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则：\r\n- 2两个方法都没有使用锁，所以不满足锁定规则：\r\n- 3变量不是用volatile修饰的，所以volatile变量规则不满足；\r\n- 4传递规则肯定不满足；\r\n\r\n所以我们**无法通过happens-before原则推导出线程A happens-before线程B**，虽然可以确认在时间上线程A优先于线程B指定，但就是无法确认线程B获得的结果是什么，所以**这段代码不是线程安全的**。那么怎么修复这段代码呢？\r\n\r\n\r\n\r\n**解决办法：**\r\n\r\n- 把getter和setter方法都定义为synchronized方法\r\n  - 但是锁太重，虽然保证了程序的安全性，但是极大的影响了并发量\r\n  - 把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景\r\n\r\n\r\n\r\n```java\r\n/**\r\n * 使用：把value定义为volatile变量，由于setter方法对value的修政不依赖value的原值，满足volatile关健字使用场景\r\n * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性结合使用锁和volatile变量来减少同步的开销\r\n */\r\npublic volatile int value = 0;\r\npublic int getValue(){\r\n    return value;	//利用volatile保证读取操作的可见性\r\n}\r\npublic synchronized int setValue(){\r\n    return ++value;	//利用synchronized保证复合操作的原子性\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 一些面试题\r\n\r\n都是自己的回答\r\n\r\n- 你知道什么是Java内存模型JMM吗？\r\n  - java内存模型JMM是一组抽象的概念，是并不真实存在的一组约定或规范，通过这组规范定义了各个变量的读写访问方式以及一个线程对共享变量的修改以及何时对另一个线程可见\r\n- JMM与volatile它们两个之间的关系？（下一章详细讲解）\r\n  - volatile底层是借助JMM插入内存屏障实现可见性和有序性的，但是volatile并不满足原子性\r\n- JMM有哪些特性？它的三大特性是什么？\r\n  - 可见性、原子性、有序性\r\n- 为什么要有JMM,它为什么出现？作用和功能是什么？\r\n  - 因为CPU和主内存的访问速度不一致，所以通过JMM实现线程和主内存之间的抽象模型，并且屏蔽掉各硬件平台和操作系统的内存访问差异，让Java程序能够在各平台上达到一致的内存访问效果\r\n- happens-before先行发生原则你有了解过吗？\r\n  - 如果一个操作先行发生于另一个操作，那么先发生的这个操作的执行结果对另一个操作是可见的，并且它的执行顺序在另一个操作的前面\r\n  - 但是执行顺序也不是一定的，若是重排序后的执行结果和遵循线性发生原则制定的执行顺序的执行结果一致的话，那么这个重排序并不非法\r\n\r\n\r\n\r\n# volatile与JMM\r\n\r\n\r\n\r\n## volatile只满足两大特性\r\n\r\n\r\n\r\n### 可见性\r\n\r\n- **当写一个volatile变量时**，JMM会把该线程对应的本地内存中的共享变量值<font color=\'red\'>立即刷新回主内存</font>中。\r\n  - 实现：写完后，加上写屏障，强制刷新到主内存中\r\n- **当读一个volatile变量时**，JMM会把该线程对应的<font color=\'red\'>本地内存设置为无效，重新回到主内存中读取最新共享变量</font>\r\n  - 实现：读前，加上读屏障，保证屏障后的读取能读到最新值\r\n- <font color=\'cornflowerblue\'>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</font>\r\n\r\n\r\n\r\n### 有序性（禁重排）\r\n\r\n- <font color=\'red\'>即volatile禁止重排</font>\r\n\r\n\r\n\r\n可见性和有序性的定义看前面的JMM部分中的详细说明\r\n\r\n\r\n\r\n### 字节码分析volatile为什么可以保证可见性和有序性？\r\n\r\n\r\n\r\n![image-20230716162542528](image/JUC03.assets/image-20230716162542528.png)\r\n\r\n\r\n\r\n底层使用<font color=\'red\'>内存屏障Memory Barrier</font>指令实现，内存屏障部分细讲\r\n\r\n\r\n\r\n\r\n\r\n## ==内存屏障==\r\n\r\n\r\n\r\n写完后立即刷新回主内存并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见\r\n\r\n有序（禁重排）\r\n重排序\r\n重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序\r\n不存在数据依赖关系，可以重排序；\r\n<font color=\'red\'>存在数据依赖关系，禁止重排序</font>\r\n但重排后的指令绝对不能改变原有的串行语义！<font color=\'red\'>这点在并发设计中必须要重点考虑！</font>\r\n\r\n\r\n\r\n### 内存屏障是什么？\r\n\r\n内存屏障：是**一种屏障指令**，它使得CPU或编译器对**屏障指令的前** 和 **后**所发出的内存操作执行一个排序的约束。也叫内存栅栏或栅栏指令，避免了代码重排序。\r\n\r\n内存屏障其实就是一种JVM指令，Java内存模型的重排规则会<font color=\'red\'>要求Java编译器在生成JVM指令时插入特定的内存屏障指令</font>，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），<font color=\'red\'>但volatile无法保证原子性。</font>\r\n\r\n\r\n\r\n### 写屏障与读屏障\r\n\r\n\r\n\r\n**粗分读写两种：**\r\n\r\n- <font color=\'cornflowerblue\'>读屏障(Load Barrier)</font>\r\n  - 在**读指令之前**插入读屏障，**让工作内存或CPU高速缓存当中的缓存数据失效**，重新回到主内存中获取最新数据\r\n- <font color=\'cornflowerblue\'>写屏障(Store Barrier）</font>\r\n  - 在**写指令之后**插入写屏障，**强制把写缓冲区的数据刷回到主内存中**\r\n\r\n\r\n\r\n**细分四种：**\r\n\r\n| LoadLoad   | Load1;LoadLoad;Load2     | 保证load1的读取操作在load2及后续读取操作之前执行             |\r\n| ---------- | ------------------------ | ------------------------------------------------------------ |\r\n| StoreStore | Store1;StoreStore;Store2 | 在store.2及其后的写操作执行前，保证store1的写操作已刷新到主内存 |\r\n| LoadStore  | Load1;LoadStore;Store2   | 在stroe2及其后的写操作执行前，保证load1的读操作已读取结束    |\r\n| StoreLoad  | Store1;StoreLoad;Load2   | 保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行 |\r\n\r\n底层又追溯到UnSafe.cpp和汇编语言，不多赘述\r\n\r\n\r\n\r\n### 为什么能保证可见性？\r\n\r\n**内存屏障包括写屏障和读屏障**\r\n\r\n<font color=\'cornflowerblue\'>内存屏障之**前**</font>的所有<font color=\'red\'>***写操作***</font>都要<font color=\'red\'>回写到主内存，</font>\r\n\r\n<font color=\'cornflowerblue\'>内存屏障之**后**</font>的所有<font color=\'red\'>***读操作***</font>都能<font color=\'red\'>获得</font>内存屏障之前的所有写操作的<font color=\'red\'>最新结果</font>（实现了可见性）。\r\n\r\n\r\n\r\n- <font color=\'cornflowerblue\'>读屏障(Load Barrier)</font>\r\n  - 在**读指令之前**插入读屏障，**让工作内存或CPU高速缓存当中的缓存数据失效**，重新回到主内存中获取最新数据\r\n- <font color=\'cornflowerblue\'>写屏障(Store Barrier）</font>\r\n  - 在**写指令之后**插入写屏障，**强制把写缓冲区的数据刷回到主内存中**\r\n\r\n\r\n\r\n**看下图，内存屏障将写操作和读操作分隔开了**，因此重排序时，<font color=\'cornflowerblue\'>不允许把内存屏障之后的指令重排序到内存屏障之前</font>。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。\r\n\r\n\r\n\r\n**图示：**\r\n\r\n![image-20230715233142140](image/JUC03.assets/image-20230715233142140.png)\r\n\r\n\r\n\r\n**volatile变量读写过程图示：**\r\n\r\n**![image-20230716001532715](image/JUC03.assets/image-20230716001532715.png)**\r\n\r\n\r\n\r\n> 可见，写屏障前，强制刷新内存时，因为不能保证原子性所以<font color=\'red\'>对变量的写操作必须加锁</font>，而**加锁会清空工作线程中副本变量的值**，导致需要重新加载，这就是为什么读屏障后本地缓存失效的原因，因此才能读到最新值\r\n\r\n\r\n\r\n### 为什么能保证有序性？\r\n\r\n\r\n\r\n- <font color=\'red\'>当第一个操作为volatile读</font>时，不论第二个操作是什么，都<font color=\'red\'>不能重排序</font>。<font color=\'cornflowerblue\'>volatile读之后的操作，都禁止重排序到volatile之前</font>\r\n  - 在每个volatile读操作的后面插入一个**LoadLoad**屏障，禁止处理器把上面的volatile读与下面的普通读重排序。\r\n  - 在每个volatile读操作的后面再插入一个**LoadStore**屏障，禁止处理器把上面的volatile读与下面的普通写重排序。\r\n- <font color=\'red\'>当第二个操作为volatile写</font>时，不论第一个操作是什么，都<font color=\'red\'>不能重排序</font>。<font color=\'cornflowerblue\'>volatile写之前的操作，都禁止重排序到volatile之后</font>\r\n- 在每个volatile写操作的前面插入一个**StoreStore**屏障，保证在volatile写之前其前面的所有普通写操作都已经刷新到主内存中。\r\n  - 在每个volatile写操作的后面插入一个**StoreLoad**屏障，避免volatile写与后面可能有的volatile读/写操作重排序\r\n\r\n\r\n\r\n![image-20230716151531907](image/JUC03.assets/image-20230716151531907.png)\r\n\r\n\r\n\r\n- <font color=\'red\'>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</font>\r\n  - 已在 	为什么能保证可见性	 部分中的 第一张图示 前说到、\r\n- 除上面三种情况外，即除第一个操作是volatile读、第二个操作是volatile写、volatile写读这三种情况外，其他情况都允许重排\r\n\r\n\r\n\r\n### 为什么不能保证原子性？\r\n\r\n\r\n\r\n**代码案例：**\r\n\r\n```java\r\nclass MyNumber {\r\n    //共享数据，是存储在共享主内存中的\r\n    volatile int number = 0;\r\n\r\n    public void addNumber(){\r\n        number++;\r\n    }\r\n}\r\npublic class VolatileDemo {\r\n    public static void main(String[] args) {\r\n        MyNumber myNumber = new MyNumber();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            new Thread(() -> {\r\n                for (int j = 0; j < 1000; j++) {\r\n                    myNumber.addNumber();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n        \r\n        try TimeUnit.SECONDS.sleep(2);} catch (InterruptedException e) {e.printStackTrace();}\r\n        System.out.println(myNumber.number);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n![image-20230716140721781](image/JUC03.assets/image-20230716140721781.png)\r\n\r\n\r\n\r\n对于volatile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，<font color=\'red\'>也仅是数据加载时是最新的</font>。但是多线程环境下，\"数据计算\"和\"数据赋值\"操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存中的操作将会作废去读主内存最新值，操作出现写丢失问题。即<font color=\'red\'>**各线程私有内存和主内存公共内存中变量不同步**</font>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，<font color=\'red\'>但无法保证原子性，对于多线程修改主内存共享变量的场景必须使用加锁同步。</font>\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- number++操作反编译出的指令中**一共有三条指令**来完成这个操作\r\n- 而volatile因为满足可见性，所以这三条指令中的第一条指令拿到的值一定是最新的\r\n- 可是因为有多条指令，本线程执行到第二条或者第三条指令的时候，其他线程已经提交了一次修改到共享主内存中\r\n- 所以有序性使得本线程的工作内存中的正在执行的数据失效，造成本次循环失效\r\n- 本线程重新从共享主内存加载新的数据，开始下一次循环操作，造成写丢失\r\n\r\n可见性只是读取的时候从主内存中读最新的，已经读到后进行后续操作的过程中主内存可能有更新了，造成一次循环失效\r\n\r\n\r\n\r\n**number++字节码：**\r\n\r\n```java\r\n2: getfield      #2                  // Field number:I		//拿到原始值\r\n5: iconst_1\r\n6: iadd														//+1\r\n7: putfield      #2                  // Field number:I		//写回\r\n```\r\n\r\n\r\n\r\n**volatile变量不适合参与到依赖当前值的运算**，如：i=i+1；i++;之类的\r\n\r\n\r\n\r\n**那么依靠可见性的特点volatile可以用在哪些地方呢？**\r\n\r\n<font color=\'red\'>通常volatile用做保存某个状态的boolean值or int值。</font>\r\n\r\n\r\n\r\n> 《深入理解Java虚拟机》提到：\r\n>\r\n> 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized、java.util.concurrent中的锁或原子类)来保证原子性：\r\n>\r\n> - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\r\n> - 变量不需要与其他的状态变量共同参与不变约束。\r\n\r\n\r\n\r\n\r\n\r\n## volatile使用场景\r\n\r\n- 单一赋值可以，but含复合运算赋值不可以(i++之类)\r\n\r\n  - volatile int a = 10;	或		volatile boolean flag = false;\r\n\r\n- 状态标志判断业务是否结束\r\n\r\n  - 作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束\r\n  - 类似于JUC02中使用volatile实现线程中断停止\r\n\r\n- 开销较低的读，写锁策略\r\n\r\n  - 当读远多于写，结合使用内部锁和volatile变量来减少同步的开销\r\n  - 用volatile保证读取操作的可见性；利用synchronized或lock保证复合操作的原子性\r\n  - 即前面的	happens-before案例引出volatile 	中的案例\r\n\r\n- AtomicReferenceFieldUpdater属性修改原子类中要更新的属性必须是public volatile修饰的（JUC04中原子类中讲解）\r\n\r\n- 单例模式双端锁\r\n\r\n  - 对象的创建过程有多个步骤，详情看我的JVM笔记-《对象的创建和执行引擎》，多个步骤之间可能被重排\r\n\r\n  - ```java\r\n    /**\r\n     * 单例模式双端锁需要使用volatile\r\n     */\r\n    public class SafeDoubleCheckSingleton {\r\n        //通过volatile声明，实现线程安全的延迟初始化。\r\n        private volatile static SafeDoubleCheckSingleton singleton;\r\n        //私有化构造方法\r\n        private SafeDoubleCheckSingleton(){}\r\n        /**\r\n         * 其中实例化Singleton分多步执行（分配内存空间、初始化对象、将对象指向分配\r\n         * 的内存空间)，某些编译器为了性能原因，会将第二步和第三步进行重排序（分配内存空\r\n         * 间、将对象指向分配的内存空间、初始化对象)。这样，某个线程可能会获得一个未完全\r\n         * 初始化的实例。\r\n         */\r\n        //双重锁设计\r\n        public static SafeDoubleCheckSingleton getInstance(){\r\n            if (singleton == null){\r\n                //1.多线程并发剑建对象时，会通过加锁保证只有一个线程能创建对象\r\n                synchronized (SafeDoubleCheckSingleton.class){\r\n                    if (singleton == null){\r\n                        //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取\r\n                        //解决隐患原理：利用volatile，禁止\"初始化对象\"和\"设置singleton:指向内存空间\"的重排序\r\n                        singleton = new SafeDoubleCheckSingleton();\r\n                    }\r\n                }\r\n            }\r\n            //2.对象刻建完毕，执行getInstance()将不需要茨取锁，直接返回创建对象\r\n            return singleton;\r\n        }\r\n    }\r\n    ```\r\n\r\n\r\n\r\n## volatile使用内存屏障实现小总结\r\n\r\nvolatile底层使用内存屏障实现可见性和有序性，当字节码生成机器码时，发现ACC_VOLATILE时，会根据JMM规范，在相应位置插入内存屏障：\r\n\r\n- volatile读之后的操作，都禁止重排序到volatile之前\r\n- volatile写之前的操作，都禁止重排序到volatile之后\r\n- volatile写之后volatile读，禁止重排序\r\n\r\n\r\n\r\n','image/JUC03.assets/image-20230715144410262.png','原创',5,_binary '',_binary '',_binary '\0','2023-07-22 22:07:05',NULL,2022576839,'JUC03-JMM、volatile',NULL,NULL,'0'),(1682754418308575233,'JUC04-- CAS自旋 、CAS自旋锁、ABA问题及解决办法、18大原子类','[TOC]\r\n\r\n\r\n\r\n# JUC04\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- CAS自旋\r\n  - <font color=\'red\'>CAS自旋锁</font>\r\n  - <font color=\'red\'>ABA问题及解决办法</font>\r\n- 18大原子类\r\n  - <font color=\'red\'>原子增强类以及它为什么快</font>\r\n\r\n\r\n\r\n\r\n\r\n\r\n# CAS\r\n\r\n\r\n\r\n## CAS原理简介\r\n\r\n\r\n\r\n### CAS发展：\r\n\r\njava.util.concurrent.atomic包下的类是使用CAS+自旋实现的\r\n\r\n- 没有CAS之前：多线程环境不使用原子类保证线程安全++（基本数据类型）\r\n  - 使用synchronized或lock（都是悲观锁）\r\n- 使用CAS之后：多线程环境    使用原子类保证线程安全++（基本数据类型）\r\n  - 类似于<font color=\'red\'>乐观锁</font>，比较后不对再次尝试\r\n\r\n```java\r\npublic volatile int value = 0;\r\npublic int getValue(){\r\n    return value;	//利用volatile保证读取操作的可见性\r\n}\r\npublic synchronized void setValue(){\r\n    value++;	//利用synchronized保证复合操作的原子性\r\n}\r\n//--------------CAS----------------------\r\nAtomicInteger atomicInteger = new AtomicInteger();//默认0开始\r\npublic int getValue(){\r\n    return atomicInteger.get();\r\n}\r\npublic void setValue(){\r\n    atomicInteger.getAndIncrement();\r\n}\r\n//需要使用辅助类CountDownLatch来保证线程计算完毕才获取计算结果\r\n//完整案例查看原子类部分的基本类型原子类中的使用案例\r\n```\r\n\r\n\r\n\r\n### CAS是什么？\r\n\r\ncompare and swap的缩写，中文翻译成<font color=\'red\'>比较并交换</font>，实现并发算法时常用到的一种技术\r\n\r\n它包含三个操作数一一位置内存值、预期原值及更新值。\r\n\r\n执行CAS操作的时候，将内存位置的值与预期原值比较：\r\n\r\n- 如果<font color=\'red\'>相匹配</font>，那么处理器会自动将该位置值更新为新值，\r\n- 如果<font color=\'red\'>不匹配</font>，处理器不做任何操作，多个线程同时执行CAS操作<font color=\'red\'>只有一个会成功</font>。\r\n\r\n\r\n\r\n### CAS原理：\r\n\r\nCAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。\r\n\r\n<font color=\'cornflowerblue\'>当且仅当旧的预期值A和内存值V相同时</font>，将内存值V修改为B,否则什么都不做或重来\r\n\r\n<font color=\'red\'>当它重来重试的这种行为称为-自旋！！</font>\r\n\r\n![image-20230716172303473](image/JUC04.assets/image-20230716172303473.png)\r\n\r\n**代码举例：**\r\n\r\n```java\r\nAtomicInteger atomicInteger = new AtomicInteger(5);\r\n\r\nSystem.out.println(atomicInteger.compareAndSet(5,2023) + \"\\t\" + atomicInteger.get());\r\nSystem.out.println(atomicInteger.compareAndSet(5,2023) + \"\\t\" + atomicInteger.get());\r\n```\r\n\r\n```\r\ntrue	2023\r\nfalse	2023\r\n```\r\n\r\n\r\n\r\n### CAS优点：\r\n\r\nCAS是JDK提供的<font color=\'cornflowerblue\'>非阻塞</font>原子性操作，它通过<font color=\'cornflowerblue\'>硬件保证</font>了比较-更新的原子性。\r\n\r\n它是非阻塞的且自身具有原子性，也就是说这玩意**效率更高且通过硬件保证，说明这玩意更可靠**。\r\n\r\nCAS是一条CPU的原子指令<font color=\'red\'>(cmpxchg指令</font>)，不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX)底层实现即为CPU指令cmpxchg。\r\n\r\n执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，<font color=\'red\'>也就是说CAS的原子性实际上是**CPU实现独占的**</font>，比起用synchronized重量级锁，这里的<font color=\'cornflowerblue\'>排他时间要短很多</font>，所以在多线程情况下**性能会比较好**。\r\n\r\n\r\n\r\n## **CAS底层实现-引出Unsafe类**\r\n\r\n\r\n\r\n**compareAndSet()方法底层源码：**\r\n\r\n![image-20230716194303644](image/JUC04.assets/image-20230716194303644.png)\r\n\r\n\r\n\r\n- **1 Unsafe：**\r\n  - 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<font color=\'red\'>Unsafe类存在于sun.misc</font>包中，其内部方法操作可以像C的<font color=\'red\'>指针</font>一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。\r\n  - <font color=\'red\'>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接湖用操作系统底层资源执行相应任务</font>\r\n- **2 变量valueOffset：**\r\n  - 表示该变量值在内存中的**偏移地址**，因为Unsafe就是根据内存偏移地址获取数据的。\r\n\r\n- 3 **变量value**用volatile修饰，保证了多线程之间的内存可见性。\r\n\r\n\r\n\r\n\r\n\r\n**我们知道i++线程不安全的，那atomiclnteger.getAndIncrement()是如何实现的？**\r\n\r\n\r\n\r\nAtomicInteger类主要利用**CAS**(compare and swap)+**volatile**和**native**方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。\r\n\r\n![image-20230716200611011](image/JUC04.assets/image-20230716200611011.png)\r\n\r\nCAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出<font color=\'cornflowerblue\'>CAS汇编指令</font>。这是一种完全依赖于<font color=\'red\'>硬件</font>的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，<font color=\'red\'>并且原语的执行必须**是连续的**，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</font>\r\n\r\n\r\n\r\n## ==CAS自旋实现个人总结==\r\n\r\n即上面所有内容的简洁版（面试版）\r\n\r\n- CAS是从**硬件**提升效率，最底层是交给硬件和volatile来保证原子性（CPU独占）和可见性（volatile）\r\n- 底层是**Unsafe**类，实现方式是基于硬件平台的汇编指令，在intel的CPU中（X86机器上），使用的汇编指令是**cmpxchg**指令\r\n- 核心思想就是：比较要更新变量的值V和预期值E(compare)，相等才会将V的值设为新值N(swap)，如果不相等自旋再来。\r\n- **原子性是一个CPU独占的实现的**，但多个CPU的多个线程依旧会发生线程安全问题\r\n\r\n\r\n\r\n\r\n\r\n## AtomicReference原子引用\r\n\r\n\r\n\r\njava.util.concurrent.atomic包下抓门用来处理**自写类**的一个原子类\r\n\r\n**案例演示：**\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\nclass User{\r\n    String name;\r\n    Integer age;\r\n}\r\n\r\npublic class AtomicReferenceDemo {\r\n    public static void main(String[] args) {\r\n        AtomicReference<User> atomicReference = new AtomicReference<>();\r\n        User z3 = new User(\"z3\",22);\r\n        User li4 = new User(\"li4\",28);\r\n        \r\n        atomicReference.set(z3);\r\n        System.out.println(atomicReference.compareAndSet(z3,li4) + \"\\t\" + atomicReference.get().toString());\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## ==CAS自旋锁（手写）==\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>自旋锁(spinlock)</font>\r\n\r\nCAS是实现自旋锁的基础，CAS利用CPU指令保证了操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转。是指尝试获取锁的线程不会立即阻塞，而是<font color=\'red\'>采用**循环的方式**去尝试获取锁</font>，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的<font color=\'cornflowerblue\'>**好处**是减少线程上下文切换的消耗，**缺点**是循环会消耗CPU</font>\r\n\r\n**所以CAS类似于乐观锁，适用于读取多的场景，悲观锁适用于写多的场景**\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>OpenJDK源码里面查看下Unsafe.java</font>\r\n\r\nCAS是实现自旋锁的基础，自旋翻译成人话就是循环，一般是用一个无限循环实现。这样一来，一个无限循环中，执行一个CAS操作，\r\n\r\n- 当操作成功返回true时，循环结束；\r\n- 当返回false时，接着执行循环，继续尝试CAS操作，直到返回true。\r\n\r\n**底层getAndAddInt方法自旋实现源码：**\r\n\r\n```java\r\npublic final int getAndAddInt(Object var1, long var2, int var4) {\r\n    int var5;\r\n    do {\r\n        var5 = this.getIntVolatile(var1, var2);\r\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\r\n\r\n    return var5;\r\n}\r\n```\r\n\r\n\r\n\r\n==**自写自旋锁**==\r\n\r\n```java\r\n/**\r\n * 自写一个自旋锁\r\n */\r\npublic class SpinLockDemo {\r\n    AtomicReference<Thread> atomicReference = new AtomicReference<>();\r\n    \r\n    public void lock(){\r\n        Thread thread = Thread.currentThread();\r\n        System.out.println(Thread.currentThread().getName() + \"------come in\");\r\n        while (!atomicReference.compareAndSet(null,thread)){\r\n            \r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"-------lock\");\r\n    }\r\n    \r\n    public void unlock(){\r\n        Thread thread = Thread.currentThread();\r\n        while (!atomicReference.compareAndSet(thread,null)){\r\n            \r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"---------task over  ,unlock\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        SpinLockDemo lockDemo = new SpinLockDemo();\r\n        \r\n        new Thread(() -> {\r\n            lockDemo.lock();\r\n            //暂停几秒钟线程\r\n            try {TimeUnit.SECONDS.sleep(5);} catch (InterruptedException e) {e.printStackTrace();}\r\n            lockDemo.unlock();\r\n        },\"A\").start();\r\n        \r\n        //暂停500ms，让线程A先启动\r\n        try {TimeUnit.MILLISECONDS.sleep(500);} catch (InterruptedException e) {e.printStackTrace();}\r\n        \r\n        new Thread(() -> {\r\n            lockDemo.lock();\r\n            \r\n            lockDemo.unlock();\r\n        },\"B\").start();\r\n    }\r\n}\r\n```\r\n\r\n```\r\nA------come in\r\nA-------lock\r\nB------come in\r\nA---------task over  ,unlock\r\nB-------lock\r\nB---------task over  ,unlock\r\n```\r\n\r\n\r\n\r\n## CAS两大缺点：\r\n\r\n\r\n\r\n- 循环时间开销很大\r\n\r\n- CAS会导致\"ABA问题\"\r\n\r\n  - CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<font color=\'red\'>时间差</font>类会导致数据的变化。\r\n\r\n  - 比如说一个线程1从内存位置V中取出A,这时候另一个线程2也从内存中取出A,并且线程2进行了一些操作将值变成了B,然后线程2又将V位置的数据变成A,这时候线程1进行CAS操作发现内存中仍然是A,预期OK,然后线程1操作成功。\r\n\r\n  - <font color=\'red\'>尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的。</font>\r\n\r\nABA 问题的案例以及解决方法：看AtomicStampedReference\r\n\r\n\r\n\r\n## AtomicStampedReference\r\n\r\n\r\n\r\n在普通自旋的基础上再加上一个版本号的判断\r\n\r\n- 若版本号也一致，修改成功\r\n- 若版本号不一致，修改失败，继续自旋\r\n\r\n\r\n\r\n### 单线程普通使用案例\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\nclass Book{\r\n    Integer id;\r\n    String bookName;\r\n}\r\npublic class AtomicStampedReferenceDemo {\r\n    public static void main(String[] args) {\r\n        Book javaBook = new Book(1,\"javaBook\");\r\n        AtomicStampedReference<Book> stampedReference = new AtomicStampedReference<>(javaBook,1);\r\n        System.out.println(stampedReference.getReference() + \"\\t\" + stampedReference.getStamp());\r\n        \r\n        Book mysqlBook = new Book(2,\"mysqlBook\");\r\n        boolean b;\r\n        b = stampedReference.compareAndSet(javaBook,mysqlBook,stampedReference.getStamp(),stampedReference.getStamp()+1);\r\n\r\n        System.out.println(b + \"\\t\" + stampedReference.getReference() + \"\\t\" + stampedReference.getStamp());\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### ==多线程ABA问题演示及解决案例==\r\n\r\n\r\n\r\n**ABA问题案例：**\r\n\r\n```java\r\n/**\r\n * ABA问题的发生\r\n */\r\nstatic AtomicInteger atomicInteger = new AtomicInteger(100);\r\nprivate static void abaHappen() {\r\n    new Thread(() -> {\r\n        atomicInteger.compareAndSet(100,101);\r\n        try {TimeUnit.MILLISECONDS.sleep(10);} catch (InterruptedException e) {e.printStackTrace();}\r\n        atomicInteger.compareAndSet(101,100);\r\n    },\"t1\").start();\r\n\r\n    new Thread(() -> {\r\n        //等待ABA问题的发生\r\n        try {TimeUnit.MILLISECONDS.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}\r\n        System.out.println(atomicInteger.compareAndSet(100, 2022)+\"\\t\"+atomicInteger.get());\r\n    },\"t2\").start();\r\n}\r\n```\r\n\r\n\r\n\r\n**解决ABA问题演示：**\r\n\r\n```java\r\n/**\r\n * 使用AtomicStampedReference可以避免ABA问题\r\n */\r\nstatic AtomicStampedReference<Integer> stampedReference = new AtomicStampedReference<>(100,1);\r\n\r\npublic static void main(String[] args) {\r\n    new Thread(() -> {\r\n        int stamp = stampedReference.getStamp();\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"首次版本号：\"+stamp);\r\n\r\n        //暂停500毫秒,保证后面的t4线程初始化拿到的版本号和我一样\r\n        try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp() + 1);\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"2次流水号：\"+stampedReference.getStamp());\r\n\r\n        stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp() + 1);\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"3次流水号：\"+stampedReference.getStamp());\r\n    },\"t1\").start();\r\n    \r\n    new Thread(() -> {\r\n        int stamp = stampedReference.getStamp();\r\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + stamp);\r\n\r\n        //暂停1秒钟线程,等待上面的t3线程，发生了ABA问题\r\n        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        boolean b = stampedReference.compareAndSet(100,2023,stamp,stamp + 1);\r\n        System.out.println(b+\"\\t\"+stampedReference.getReference()+\"\\t\"+stampedReference.getStamp());\r\n    },\"t2\").start();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 18大原子类\r\n\r\n\r\n\r\n介绍位于java.util.concurrent.atomic包下的所有类\r\n\r\n原子类使用的原理是CAS自旋\r\n\r\n\r\n\r\n## 基本类型原子类\r\n\r\n\r\n\r\n**包含**\r\n\r\n- AtomicInteger\r\n- AtomicBoolean\r\n- AtomicLong\r\n\r\n\r\n\r\n**常用API**\r\n\r\n- public final int get()//获取当前的值\r\n- public final int getAndSet(int newValue)//获取当前的值，并设置新的值\r\n- public final int getAndIncrement()//获取当前的值，并自增\r\n- public final int getAndDecrement()//获取当前的值，并自减\r\n- public final int getAndAdd(int delta)//获取当前的值，并加上预期的值\r\n- boolean compareAndSet(int expect,int update)//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）\r\n\r\n\r\n\r\n**案例：**\r\n\r\n注意：不能直接在主线程中获取计算结果，否则可能前面线程还没计算完成就打印出结果了\r\n\r\n<font color=\'red\'>需要使用辅助类CountDownLatch来阻塞线程</font>\r\n\r\n开发中不能使用等待几秒的方式，因为等待时间不准确\r\n\r\n```java\r\nclass MyNumber {\r\n    AtomicInteger atomicInteger = new AtomicInteger();\r\n    public void setPlusPlus(){\r\n        atomicInteger.getAndIncrement();\r\n    }\r\n}\r\npublic class AtomicIntegerDemo {\r\n    public static final int SIZE = 50;\r\n    public static void main(String[] args) throws InterruptedException {\r\n        MyNumber myNumber = new MyNumber();\r\n        CountDownLatch countDownLatch = new CountDownLatch(SIZE);\r\n\r\n        for (int i = 0; i < SIZE; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 0; j < 1000; j++) {\r\n                        myNumber.setPlusPlus();\r\n                    }\r\n                } finally {\r\n                    countDownLatch.countDown();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n        //阻塞2秒等待计算完成，可是并不知道具体等待时间\r\n//        try {TimeUnit.SECONDS.sleep(2);} catch (InterruptedException e) {e.printStackTrace();}\r\n        \r\n        //阻塞等待前面线程已经计算完成\r\n        countDownLatch.await();\r\n        System.out.println(Thread.currentThread().getName() + \"\\t result : \" + myNumber.atomicInteger.get());\r\n        \r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 数组类型原子类\r\n\r\n\r\n\r\n**包含**\r\n\r\n- AtomicIntegetArray\r\n- AtomicBooleanArray\r\n- AtomicReferenceArray\r\n\r\n\r\n\r\n**常用API**\r\n\r\n- public final int get(int offset)//获取当前的值\r\n- public final int getAndSet(int offset, int newValue)//获取当前的值，并设置新的值\r\n- public final int getAndIncrement(int offset)//获取当前的值，并自增\r\n- public final int getAndDecrement(int offset)//获取当前的值，并自减\r\n- public final int getAndAdd(int offset, int delta)//获取当前的值，并加上预期的值\r\n- boolean compareAndSet(int offset, int expect,int update)//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）\r\n\r\n\r\n\r\n## 引用类型原子类\r\n\r\n\r\n\r\n- AtomicReference\r\n- AtomicStampedReference\r\n  - 前面CAS解决ABA问题使用过\r\n  - 加上的是版本号version\r\n  - 解决修改过几次\r\n- AtomicMarkableReference\r\n  - 加上的是标记为mark\r\n  - 一次性使用，若被修改过，则版本号不对，修改失败\r\n  - 解决是否被修改过\r\n\r\n\r\n\r\n**AtomicMarkableReference使用案例**\r\n\r\n```java\r\npublic class AtomicMarkableReferenceDemo {\r\n    public static void main(String[] args) {\r\n        AtomicMarkableReference<Integer> markableReference = new AtomicMarkableReference<>(100,false);\r\n        \r\n        new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + markableReference.isMarked());\r\n            //保证t2线程也拿到和我相同的mark值\r\n            try {TimeUnit.SECONDS.sleep(1);} catch (InterruptedException e) {e.printStackTrace();}\r\n            markableReference.compareAndSet(100,1000,markableReference.isMarked(),!markableReference.isMarked());\r\n        },\"t1\").start();\r\n        \r\n        new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + markableReference.isMarked());\r\n            //保证t1先修改\r\n            try {TimeUnit.SECONDS.sleep(2);} catch (InterruptedException e) {e.printStackTrace();}\r\n            boolean b = markableReference.compareAndSet(100,2000,markableReference.isMarked(),!markableReference.isMarked());\r\n            System.out.println(Thread.currentThread().getName() + \"修改结果：\" + b);\r\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + markableReference.isMarked());\r\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + markableReference.getReference());\r\n        },\"t2\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 属性修改原子类\r\n\r\n\r\n\r\n- AtomicIntegerFieldUpdater\r\n  - 原子更新对象中int类型字段的值\r\n- AtomicLongFieldUpdater\r\n  - 原子更新对象中Long类型字段的值\r\n- AtomicReferenceFieldUpdater\r\n  - 原子更新引用类型字段的值\r\n\r\n\r\n\r\n<font color=\'red\'>使用目的：以一种线程安全的方式操作非线程安全对象内的某些字段</font>\r\n\r\n- 并不是整个对象都需要原子操作，可能只是其中的某一个字段需要保证线程安全\r\n- 所以采用更细粒度的方式，只对某个对象的需要线程安全的某些字段进行操作\r\n\r\n\r\n\r\n<font color=\'red\'>使用要求：</font>\r\n\r\n- 更新的对象属性必须使用public **volatile**修饰符。\r\n- 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类的字段\r\n\r\n\r\n\r\n> volatile使用场景：AtomicReferenceFieldUpdater、双端锁\r\n\r\n\r\n\r\n### AtomicIntegerFieldUpdater使用案例\r\n\r\ni++案例到目前一共有四种实现方式：（后面还有两种）\r\n\r\n按照学习先后顺序：\r\n\r\n- synchronized或lock重量级锁保证符合操作的原子性\r\n- volatile写锁策略，只有写操作才加锁（只能是一写），多写时需要用上面或下面两种\r\n- AtomicInteger原子类\r\n- AtomicIntegerFieldUpdater属性修改器\r\n\r\n这里演示第一种和第四种，第四种和第三种差不多\r\n\r\n```java\r\n/**\r\n * 需求：\r\n * 10个线程，\r\n * 每个线程转账1000，\r\n * 不使用synchronized,尝试使用AtomicIntegerFieldUpdater来实现。\r\n */\r\nclass BankAccount {\r\n    String bankName = \"CCB\";\r\n//    int money = 0;\r\n\r\n    //AtomicIntegerFieldUpdater更新的对象属性必须使用 public volatile 修饰符。\r\n    public volatile int money = 0;\r\n    \r\n    //普通synchronize方法\r\n    public synchronized void add(){\r\n        money++;\r\n    }\r\n\r\n    //因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。\r\n    AtomicIntegerFieldUpdater<BankAccount> fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,\"money\");\r\n    \r\n    //不加synchronized，保证高性能原子性，局部微创小手术\r\n    public void transMoney(){\r\n        fieldUpdater.getAndIncrement(this);\r\n    }\r\n    \r\n}\r\npublic class AtomicIntegerFieldUpdaterDemo {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        BankAccount bankAccount = new BankAccount();\r\n        CountDownLatch countDownLatch = new CountDownLatch(10);\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 0; j < 1000; j++) {\r\n                        //bankAccount.add();\r\n                        bankAccount.transMoney();      //使用属性修改器\r\n                    }\r\n                } finally {\r\n                    countDownLatch.countDown();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n        \r\n        countDownLatch.await();\r\n        System.out.println(Thread.currentThread().getName() + \"\\tresult: \" + bankAccount.money);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### AtomicReferenceFieldUpdater使用案例\r\n\r\n```java\r\n/**\r\n * 系统初始化案例\r\n */\r\nclass MyVar{\r\n    public volatile Boolean isInit = Boolean.FALSE;\r\n    \r\n    AtomicReferenceFieldUpdater<MyVar,Boolean> fieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,\"isInit\");\r\n    public void init(){\r\n        if (fieldUpdater.compareAndSet(this,Boolean.FALSE,Boolean.TRUE)){\r\n            System.out.println(Thread.currentThread().getName() + \"\\t------------start init,needs 2 seconds\");\r\n            try {TimeUnit.SECONDS.sleep(2);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName() + \"\\t------------init over\");\r\n        }else{\r\n            System.out.println(Thread.currentThread().getName() + \"\\t----------- already have other thread is initing\");\r\n        }\r\n    }\r\n}\r\npublic class AtomicReferenceFieldUpdaterDemo {\r\n    public sa i = 0; i < 5; i++) {\r\n            new Thread(myVar::init,String.valueOf(i)).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## ==原子操作增强类==\r\n\r\n\r\n\r\n**包含两种四个**\r\n\r\n- <font color=\'red\'>DoubleAccumulator</font>\r\n- <font color=\'cornflowerblue\'>DoubleAdder</font>\r\n- <font color=\'red\'>LongAccumulator</font>\r\n- <font color=\'cornflowerblue\'>LongAdder</font>\r\n\r\n\r\n\r\n**LongAdder常用API**\r\n\r\n- void add(long x)\r\n  - 将当前的value加x\r\n- void increment(\r\n  - 将当前的value加1\r\n- void decrement()\r\n  - 将当前的value减1\r\n- long sum()\r\n  - <font color=\'red\'>返回当前值。待别注意，在没有并发更新value的情况下，sum会返回一个精确值，在存在并发的情况下，sum不保证返回精确值</font>\r\n- void reset()\r\n  - 将value重置为0，可用于替代重新new一个LongAdder，但此方法只可以在没有并发更新的情况下使用。\r\n- long sumThenReset(\r\n  - 获取当前value,并将value重置为0\r\n\r\n\r\n\r\n**LongAccumulator常用API**\r\n\r\n- void accumulate(long x)\r\n  - 将当前值加上x\r\n- long get()\r\n  - 返回当前值\r\n\r\n​	\r\n\r\n当多个线程更新用于收集统计信息但不用于细粒度同步控制的目的的公共和时，**使用LongAdder通常优于AtomicLong**。在**低更新**争用下，这两个类具有相似的特征。但在**高争用**的情况下，这一类的预期吞吐量明显更高，但代价是**空间消耗更高**\r\n\r\n\r\n\r\n- LongAdder只能用来计算加法，且从零开始计算\r\n- LongAccumulator提供了**自定义的函数操作**\r\n\r\n\r\n\r\n>17.【参考】volatile解决多线程内存不可见问题对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。\r\n>\r\n>说明：如果是count++操作，使用如下类实现：\r\n>Atomiclnteger count new Atomiclnteger();\r\n>count.addAndGet(1);\r\n>\r\n><font color=\'red\'>如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）</font>\r\n>\r\n>​																																								——《阿里Java开发手册》\r\n\r\n阿里题目：（即后面讲到的i++点赞案例）\r\n\r\n1 热点商品点赞计算器，点赞数加加统计，不要求实时精确\r\n2 一个很大的list，里面都是int类型，如何实现加加，说说思路\r\n\r\n\r\n\r\n**使用案例：**\r\n\r\n```java\r\npublic class LongAdderDemo {\r\n    public static void main(String[] args) {\r\n        LongAdder longAdder = new LongAdder();\r\n        \r\n        longAdder.increment();\r\n        longAdder.increment();\r\n        longAdder.increment();\r\n\r\n        System.out.println(longAdder.sum());\r\n\r\n        System.out.println(\"-------------------------\");\r\n\r\n        LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x + y,0);\r\n        \r\n        longAccumulator.accumulate(1);//1\r\n        longAccumulator.accumulate(3);//4\r\n        System.out.println(longAccumulator.get());\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### i++点赞累加问题解决办法汇总对比\r\n\r\n阿里题目：\r\n\r\n1 热点商品点赞计算器，点赞数加加统计，不要求实时精确\r\n2 一个很大的list，里面都是int类型，如何实现加加，说说思路\r\n\r\n\r\n\r\n**解决思路：**\r\n\r\n- 1 synchronized或lock读写\r\n  - 写锁策略：volatile读，synchronized写（只适合一写多读场景）\r\n- 2 AtomicInteger / AtomicLong\r\n- 3 AtomicIntegerFieldUpdater / AtomicLongFieldUpdate\r\n- 4 <font color=\'red\'>LongAdder</font>\r\n- 5 <font color=\'red\'>LongAccumulator</font>\r\n\r\n**高争用**的情况下，LongAdder和LongAccumulator预期吞吐量明显更高，但代价是**空间消耗更高**\r\n\r\n\r\n\r\n**代码演示：**\r\n\r\n```java\r\n/**\r\n * i++点赞各实现方法比较\r\n */\r\nclass ClickNumber{\r\n    /**\r\n     * 1 使用synchronized\r\n     */\r\n    long number = 0;\r\n    public synchronized void clickBySynchronized(){number++;}\r\n    /**\r\n     * 2 使用AtomicLong\r\n     */\r\n    AtomicLong atomicLong = new AtomicLong(0);\r\n    public void clickByAtomicLong(){atomicLong.getAndIncrement();}\r\n    /**\r\n     * 3 使用AtomicLongFieldUpdater\r\n     */\r\n    public volatile long number2 = 0;\r\n    AtomicLongFieldUpdater<ClickNumber> fieldUpdater = AtomicLongFieldUpdater.newUpdater(ClickNumber.class,\"number2\");\r\n    public void clickByAtomicLongFieldUpdater(){ fieldUpdater.getAndIncrement(this); }\r\n    /**\r\n     * 4 使用LongAdder\r\n     */\r\n    LongAdder longAdder = new LongAdder();\r\n    public void clickByLongAdder(){longAdder.increment(); }\r\n    /**\r\n     * 5 使用LongAccumulator\r\n     */\r\n    LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x + y,0);\r\n    public void clickByLongAccumulator(){ longAccumulator.accumulate(1);}\r\n}\r\npublic class AccumulatorCompareDemo {\r\n    public static final int _1W = 10000;\r\n    public static final int threadNumber = 50;\r\n    public static void main(String[] args) throws InterruptedException {\r\n        ClickNumber clickNumber = new ClickNumber();\r\n        long startTime;\r\n        long endTime;\r\n\r\n        CountDownLatch countDownLatch1 = new CountDownLatch(threadNumber);\r\n        CountDownLatch countDownLatch2 = new CountDownLatch(threadNumber);\r\n        CountDownLatch countDownLatch3 = new CountDownLatch(threadNumber);\r\n        CountDownLatch countDownLatch4 = new CountDownLatch(threadNumber);\r\n        CountDownLatch countDownLatch5 = new CountDownLatch(threadNumber);\r\n\r\n        startTime = System.currentTimeMillis();\r\n        for (int i = 1; i <=threadNumber; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 1; j <=100 * _1W; j++) {\r\n                        clickNumber.clickBySynchronized();\r\n                    }\r\n                } finally {\r\n                    countDownLatch1.countDown();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n        countDownLatch1.await();\r\n        endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickBySynchronized: \"+clickNumber.number);\r\n\r\n        startTime = System.currentTimeMillis();\r\n        for (int i = 1; i <= threadNumber; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 1; j <= 100 * _1W; j++){\r\n                        clickNumber.clickByAtomicLong();\r\n                    }\r\n                } finally {\r\n                    countDownLatch2.countDown();\r\n                }\r\n            },String.valueOf(i)).start();;\r\n        }\r\n        countDownLatch2.await();\r\n        endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByAtomicLong: \"+clickNumber.atomicLong.get());\r\n\r\n        startTime = System.currentTimeMillis();\r\n        for (int i = 1; i <= threadNumber; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 1; j <= 100 * _1W; j++){\r\n                        clickNumber.clickByAtomicLongFieldUpdater();\r\n                    }\r\n                } finally {\r\n                    countDownLatch3.countDown();\r\n                }\r\n            },String.valueOf(i)).start();;\r\n        }\r\n        countDownLatch3.await();\r\n        endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByAtomicLongFieldUpdater: \"+clickNumber.number2);\r\n\r\n        startTime = System.currentTimeMillis();\r\n        for (int i = 1; i <= threadNumber; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 1; j <= 100 * _1W; j++){\r\n                        clickNumber.clickByLongAdder();\r\n                    }\r\n                } finally {\r\n                    countDownLatch4.countDown();\r\n                }\r\n            },String.valueOf(i)).start();;\r\n        }\r\n        countDownLatch4.await();\r\n        endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAdder: \"+clickNumber.longAdder.sum());\r\n\r\n        startTime = System.currentTimeMillis();\r\n        for (int i = 1; i <= threadNumber; i++) {\r\n            new Thread(() -> {\r\n                try {\r\n                    for (int j = 1; j <= 100 * _1W; j++){\r\n                        clickNumber.clickByLongAccumulator();\r\n                    }\r\n                } finally {\r\n                    countDownLatch5.countDown();\r\n                }\r\n            },String.valueOf(i)).start();;\r\n        }\r\n        countDownLatch5.await();\r\n        endTime = System.currentTimeMillis();\r\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAccumulator: \"+clickNumber.longAccumulator.get());\r\n    }\r\n}\r\n```\r\n\r\n```\r\n----costTime: 2956 毫秒	 clickBySynchronized: 50000000\r\n----costTime: 781 毫秒	 clickByAtomicLong: 50000000\r\n----costTime: 1253 毫秒	 clickByAtomicLongFieldUpdater: 50000000\r\n----costTime: 183 毫秒	 clickByLongAdder: 50000000\r\n----costTime: 88 毫秒	 	 clickByLongAccumulator: 50000000\r\n```\r\n\r\n\r\n\r\n### LongAdder为什么快？源码分析\r\n\r\n\r\n\r\n![image-20230717201713406](image/JUC04.assets/image-20230717201713406.png)\r\n\r\n\r\n\r\n18个原子类，上面一共介绍了16个，还有两个隐藏的就是，Number类和Striped64\r\n\r\nLongAdder是继承于Striped64的\r\n\r\n\r\n\r\n#### 思路\r\n\r\nLongAdder的基本思路就是<font color=\'red\'>分散热点</font>，将value值分散到一个<font color=\'red\'>Ce‖数组</font>中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的log值，只要将各个槽中的变量值累加返回。\r\n\r\nsum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。\r\n\r\n**如图：**\r\n\r\n![image-20230717203747234](image/JUC04.assets/image-20230717203747234.png)\r\n\r\n\r\n\r\n\r\n\r\n#### add()源码详解\r\n\r\n\r\n\r\n```java\r\nLongAdder.java\r\npublic void add(long x) {\r\n	//as是striped64中的cells数组属性\r\n	//b是striped64中的base属性\r\n	//v是当前线程hash到的cell中存储的值\r\n	//m是cells的长度减1,hash时作为掩码使用\r\n	//a时当前线程hash到的cell\r\n    Cell[] as; long b, v; int m; Cell a;\r\n	/**\r\n	首次首线程(as = cells) != null)一定是false,此时走casBase方法,以CAS的方式更新base值,\r\n	且只有当cas失败时,才会走到if中\r\n	条件1:cells不为空,说明出现过竞争,cell[]已创建\r\n	条件2:cas操作base失败,说明其他线程先一步修改了base正在出现竞争\r\n	*/\r\n    if ((as = cells) != null || !casBase(b = base, b + x)) {\r\n		//true无竞争 fasle表示竞争激烈,多个线程hash到同一个cell,可能要扩容\r\n        boolean uncontended = true;\r\n		/*\r\n		条件1:cells为空,说明正在出现竞争,上面是从条件2过来的,说明!casBase(b = base, b + x))=true\r\n			  会通过调用longAccumulate(x, null, uncontended)新建一个数组,默认长度是2\r\n		条件2:默认会新建一个数组长度为2的数组,m = as.length - 1) < 0 应该不会出现,\r\n		条件3:当前线程所在的cell为空,说明当前线程还没有更新过cell,应初始化一个cell。\r\n			  a = as[getProbe() & m]) == null,如果cell为空,进行一个初始化的处理\r\n		条件4:更新当前线程所在的cell失败,说明现在竞争很激烈,多个线程hash到同一个Cell,应扩容\r\n			  (如果是cell中有一个线程操作,这个时候,通过a.cas(v = a.value, v + x)可以进行处理,返回的结果是true)\r\n		**/\r\n        if (as == null || (m = as.length - 1) < 0 ||\r\n		    //getProbe( )方法返回的时线程中的threadLocalRandomProbe字段\r\n			//它是通过随机数生成的一个值,对于一个确定的线程这个值是固定的(除非刻意修改它)\r\n            (a = as[getProbe() & m]) == null ||\r\n            !(uncontended = a.cas(v = a.value, v + x)))\r\n			//调用Striped64中的方法处理\r\n            longAccumulate(x, null, uncontended);\r\n    }\r\n```\r\n\r\n\r\n\r\n**add()方法总结：**\r\n\r\n```java\r\npublic void add(long x) {\r\n    Cell[] as; long b, v; int m; Cell a;\r\n    if ((as = cells) != null || !casBase(b = base, b + x)) {\r\n        boolean uncontended = true;\r\n        if (as == null || (m = as.length - 1) < 0 ||\r\n            (a = as[getProbe() & m]) == null ||\r\n            !(uncontended = a.cas(v = a.value, v + x)))\r\n            longAccumulate(x, null, uncontended);\r\n    }\r\n}\r\n```\r\n\r\n- <font color=\'red\'>**1如果Cells表为空，尝试用CAS更新base字段，成功则退出**</font>\r\n- <font color=\'red\'>**2如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true，调用longAccumulate()**</font>\r\n- <font color=\'red\'>**3如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate()**</font>\r\n- <font color=\'red\'>**4如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，uncontended设为false，调用longAccumulate()**</font>\r\n\r\n\r\n\r\n\r\n\r\n#### longAccumulate()源码详解\r\n\r\n\r\n\r\n- Striped64中一些变量或方法的定义：\r\n\r\n![image-20230717223702312](image/JUC04.assets/image-20230717223702312.png)\r\n\r\n\r\n\r\n- 首先存储线程的probe（hash）值\r\n\r\n```java\r\nfinal void longAccumulate(long x, LongBinaryOperator fn,\r\n						  boolean wasUncontended) {\r\n	//存储线程的probe值\r\n	int h;\r\n	//如果getProbe()方法返回0,说明随机数未初始化\r\n	if ((h = getProbe()) == 0) { //这个if相当于给当前线程生成一个非0的hash值\r\n		//使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化\r\n		ThreadLocalRandom.current(); // force initialization\r\n		//重新获取probe值,hash值被重置就好比一个全新的线程一样,所以设置了wasUncontended竞争状态为true\r\n		h = getProbe();\r\n		//重新计算了当前线程的hash后认为此次不算是一次竞争,都未初始化,肯定还不存在竞争激烈\r\n		//wasUncontended竞争状态为true\r\n		wasUncontended = true;\r\n	}\r\n	...\r\n}\r\n```\r\n\r\n\r\n\r\n- for( ; ; )大循环一共分为三个部分\r\n\r\n![image-20230717223107206](image/JUC04.assets/image-20230717223107206.png)\r\n\r\n\r\n\r\n- CASE2：cells[]首次初始化时：\r\n\r\n```java\r\n	//CASE2:cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化cells数组\r\n	/*\r\n	cellsBusy:初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁\r\n	cells == as == null  是成立的\r\n	casCellsBusy:通过CAS操作修改cellsBusy的值,CAS成功代表获取锁,\r\n	返回true,第一次进来没人抢占cell单元格,肯定返回true\r\n	**/\r\n	else if (cellsBusy == 0 && cells == as && casCellsBusy()) { \r\n	    //是否初始化的标记\r\n		boolean init = false;\r\n		try {                           // Initialize table(新建cells)\r\n			// 前面else if中进行了判断,这里再次判断,采用双端检索的机制\r\n            //不double check，就会再次new一个cell数组，另一个先于本线程操作的线程中对应数组的值就会被篡改\r\n			if (cells == as) {\r\n				//如果上面条件都执行成功就会执行数组的初始化及赋值操作，Cell[] rs = new Cell[2]表示数组的长度为2，\r\n				Cell[] rs = new Cell[2];\r\n				//rs[h & 1] = new Cell(x)表示创建一个新的Cell元素，value是x值，默认为1\r\n				//h & 1类似于我们之前HashMap常用到的计算散列桶index的算法\r\n				//通常都是hash&(table.len-1)，同hashmap一个意思\r\n				//看这次的value是落在0还是1\r\n				rs[h & 1] = new Cell(x);\r\n				cells = rs;\r\n				init = true;\r\n			}\r\n		} finally {\r\n			cellsBusy = 0;\r\n		}\r\n		if (init)\r\n			break;\r\n	}\r\n```\r\n\r\n\r\n\r\n- CASE3：兜底操作，CASE1判断cells为空，CASE2判断时被其它线程抢先初始化cells时会尝试修改base值（多个线程尝试CAS修改失败的线程会走这个分支）（**其他线程正在进行初始化cells数组时，走这个CASE3**）\r\n\r\n```java\r\n	//CASE3:cells正在被其它线程进行初始化,本线程则尝试直接在基数base上进行累加操作\r\n	//这种情况是cell中都CAS失败了,有一个兜底的方法\r\n	//该分支实现直接操作base基数,将值累加到base上,\r\n	//也即其他线程正在初始化,多个线程正在更新base的值\r\n	else if (casBase(v = base, ((fn == null) ? v + x :\r\n								fn.applyAsLong(v, x))))\r\n		break;     \r\n\r\n```\r\n\r\n\r\n\r\n- CASE1.1：\r\n\r\n```java\r\nif ((as = cells) != null && (n = as.length) > 0) { // CASE1:cells已经初始化了\r\n	    // 当前线程的hash值运算后映射得到的Cell单元为null,说明该Cell没有被使用\r\n		if ((a = as[(n - 1) & h]) == null) {\r\n			//Cell[]数组没有正在扩容\r\n			if (cellsBusy == 0) {       // Try to attach new Cell\r\n				//先创建一个Cell单元格\r\n				Cell r = new Cell(x);   // Optimistically create\r\n				//尝试加锁,加锁后cellsBusy=1\r\n				if (cellsBusy == 0 && casCellsBusy()) { \r\n					boolean created = false;\r\n					try {               // Recheck under lock\r\n						Cell[] rs; int m, j; \r\n						//在有锁的情况下再检测一遍之前的判断 \r\n						if ((rs = cells) != null && (m = rs.length) > 0 &&rs[j = (m - 1) & h] == null) {\r\n							rs[j] = r;//将cell单元附到Cell[]数组上\r\n							created = true;\r\n						}\r\n					} finally {\r\n						cellsBusy = 0;//释放锁\r\n					}\r\n					if (created)\r\n						break;\r\n					continue;           // Slot is now non-empty\r\n				}\r\n			}\r\n			collide = false;\r\n		}\r\n    //上面代码判断当前线程hash后指向的数据位置元素是否为空，\r\n	//如果为空则将Cell数据放入数组中，跳出循环。\r\n	//如果不空则继续循环。\r\n```\r\n\r\n\r\n\r\n- CASE1.2：\r\n\r\n```java\r\n		/**\r\n		wasUncontended表示cells初始化后,当前线程竞争修改失败\r\n		wasUncontended=false,表示竞争激烈,需要扩容,这里只是重新设置了这个值为true,\r\n		紧接着执行advanceProbe(h)重置当前线程的hash,重新循环\r\n		*/\r\n		else if (!wasUncontended)       // CAS already known to fail\r\n			wasUncontended = true;      // Continue after rehash\r\n		...\r\n        h = advanceProbe(h);\r\n```\r\n\r\n\r\n\r\n- CASE1.3：\r\n\r\n```java\r\n		//说明当前线程对应的数组中有了数据,也重置过hash值\r\n		//这时通过CAS操作尝试对当前数中的value值进行累加x操作,x默认为1,如果CAS成功则直接跳出循环\r\n		else if (a.cas(v = a.value, ((fn == null) ? v + x :\r\n									 fn.applyAsLong(v, x))))\r\n			break;\r\n		...\r\n        h = advanceProbe(h);\r\n```\r\n\r\n\r\n\r\n- CASE1.4：\r\n\r\n```java\r\n		//如果n大于CPU最大数量,不可扩容,\r\n		//并通过下面的h=advanceProbe(h)方法修改线程的probe再重新尝试\r\n		//若线程数已经最大，那么将会一直for循环，一直执行上一步的a.cas而不会进入下面步骤\r\n		else if (n >= NCPU || cells != as)\r\n			collide = false;\r\n		...\r\n        h = advanceProbe(h);\r\n```\r\n\r\n\r\n\r\n- CASE1.5：\r\n\r\n```java\r\n		//如果扩容意向collide是false则修改它为true,然后重新计算当前线程的hash值继续循环\r\n		//如果下一次循环当前数组的长度已经大于了CPU的核数，就会再次设置扩容指向collide=false(在上一步截止)\r\n		else if (!collide) \r\n			collide = true;\r\n		...\r\n        h = advanceProbe(h);\r\n```\r\n\r\n\r\n\r\n- CASE1.6：\r\n\r\n```java\r\n		//锁状态为0并且将锁状态修改为1(持有锁) \r\n		else if (cellsBusy == 0 && casCellsBusy()) { \r\n			try {\r\n				if (cells == as) {      // Expand table unless stale\r\n					//按位左移1位来操作,扩容大小为之前容量的两倍\r\n					Cell[] rs = new Cell[n << 1];\r\n					for (int i = 0; i < n; ++i)\r\n						//扩容后将之前数组的元素拷贝到新数组中\r\n						rs[i] = as[i];\r\n					cells = rs; \r\n				}\r\n			} finally {\r\n				//释放锁设置cellsBusy=0,设置扩容状态,然后继续循环执行\r\n				cellsBusy = 0;\r\n			}\r\n			collide = false;\r\n			continue;                   // Retry with expanded table\r\n		}\r\n		h = advanceProbe(h);\r\n```\r\n\r\n\r\n\r\n- longAccumulate()方法图示：\r\n\r\n![image-20230717232607820](image/JUC04.assets/image-20230717232607820.png)\r\n\r\n**我的理解：**\r\n\r\n- 当cells==null时，执行CASE2\r\n- CASE1判断cells为空，到CASE2判断时被其它线程抢先初始化cells时，会执行兜底操作CASE3，对base进行CAS\r\n- cells!=null时，CASE1会从上到下进行判断，线程对应的hash值只能映射到仅有的槽位\r\n- CASE1.1：若是刚刚初始化的槽位还没有线程占用放过值，那么会进行CASE1.1，new一个cell存放值，之后的线程hash到该槽位时，CASE1.1将会判断失败，wasUncontended值为false，往下走\r\n- CASE1.2：如果是有竞争的，即wasUncontended值为false，将其修改为true，修改后即可往下走，否则若是没竞争，将无法继续往下走\r\n- CASE1.3：前面两步将会连续判断失败，此时会尝试在有竞争的槽位进行CAS自旋，若自旋成功，则跳出，若失败，则继续往下走\r\n- CASE1.4：第1、2步连续判断失败，第三步本次循环失败的话，会到第4步，判断槽位是否达到最大值（CPU个数），若达到最大个数后，设置collide为false，表示不可扩容，将会止步CASE1.4，导致永远不可能到达第6步进行扩容，只能一直无限循环在for循环内，无限进行第3步尝试CAS自旋直到成功\r\n- CASE1.5：扩容前的最后一步，修改扩容意向collide为false，下次循环将会不再进入CASE1.5，将会到达下一步进行扩容\r\n- CASE1.6：前面两步将会连续判断失败后，并且该次循环CAS失败，并且没达到最大槽位，执行扩容操作\r\n\r\n\r\n\r\n\r\n\r\n#### sum()源码详解\r\n\r\n```java\r\n//sum( )会将所有Cell数组中的value和base累加作为返回值\r\n//核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去,从而降级更新热点\r\npublic long sum() {\r\n    Cell[] as = cells; Cell a;\r\n    long sum = base;\r\n    if (as != null) {\r\n        for (int i = 0; i < as.length; ++i) {\r\n            if ((a = as[i]) != null)\r\n                sum += a.value;\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n为啥高并发下sum的值不精确？\r\n\r\n- sum执行时,并没有限制对base和cells的更新(一句要命的话)。<font color=\'red\'>所以LongAdder不是强一致性，它是最终一致性的</font>\r\n- 首先,最终返回的sum局部变量,初始被赋值为base,而最终返回时,很可能base已经被更新了,而此时局部变量sum不会更新,造成不一致\r\n- 其次,这里对cell的读取也**无法保证是最后一次写入的值**。所以,sum方法在没有并发的情况下,可以获得正确的结果\r\n\r\n<font color=\'red\'>一句话：调用sum方法时，累加操作还在进行，所以返回时累加值已经变了，不是强一致性，而是最终一致性的</font>\r\n\r\n\r\n\r\n#### LongAdder源码解析总结\r\n\r\n\r\n\r\n总结：LongAdder的基本思路就是<font color=\'red\'>分散热点</font>，内部有一个base变量，一个Cell数组。\r\n\r\n- <font color=\'red\'>base变量：低并发，直接累加到该变量上</font>\r\n- <font color=\'red\'>Cell[]数组：高并发，累加进各个线程自己的槽cell[i]中</font>\r\n- 最后：Value = Base + ∑(i=1~n) Cell[i]\r\n\r\n\r\n\r\nLongAdder在无竞争的情况，跟AtomicLong一样，对<font color=\'red\'>同一个base</font>进行操作，当出现竞争关系时则是采用<font color=\'red\'>化整为零分散热点</font>的做法，<font color=\'cornflowerblue\'>用空间换时间</font>，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，**可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标**，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和base都加起来作为最终结果\r\n\r\n\r\n\r\n\r\n\r\n### AtomicLong和LongAdder对比总结\r\n\r\n\r\n\r\n**AtomicLong**\r\n\r\n- 原理：\r\n  - CAS+自旋\r\n  - AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全问题\r\n  - AtomicLong是多个线程针对单个热点值value进行原子操作\r\n- 场景：\r\n  - 低并发下的全局计算\r\n  - 保证精度，性能代价\r\n  - 线程安全，可允许一些性能损耗，要求高精度时可使用\r\n- 缺陷：\r\n  - 高并发后性能急剧下降\r\n  - why？AtomicLong的自旋会成为瓶颈\r\n    - N个线程CAS操作修改线程的值，每次只有一个成功过，其它N-1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。\r\n\r\n**LongAdder**\r\n\r\n- 原理：\r\n  - CAS+Base+CeIl数组分散\r\n  - 空间换时间并分散了热点数据\r\n  - LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作\r\n  - 但最多只能存在CPU个数那么多个槽，因为需要CPU独占实现原子性\r\n- 场景：\r\n  - 高并发下的全局计算\r\n  - 保证性能，精度代价\r\n  - 当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用\r\n- 缺陷：\r\n  - sum求和后还有计算线程修改结果的话，最后结果不够准确\r\n\r\n\r\n\r\n###  \r\n\r\n###  \r\n\r\n###  \r\n\r\n### 附件：Striped64.java和LongAdder.java源码\r\n\r\n#### Striped64.java\r\n\r\n```java\r\nStriped64.java\r\n/**\r\n	1.LongAdder继承了Striped64类，来实现累加功能，它是实现高并发累加的工具类\r\n	2.Striped64的设计核心思路就是通过内部的分散计算来避免竞争\r\n	3.Striped64内部包含一个base和一个Cell[] cells数组,又叫hash表\r\n	4.没有竞争的情况下，要累加的数通过cas累加到base上；如果有竞争的话，\r\n	会将要累加的数累加到Cells数组中的某个cell元素里面\r\n*/\r\nabstract class Striped64 extends Number {\r\n	//CPU数量,即Cells数组的最大长度\r\n	static final int NCPU = Runtime.getRuntime().availableProcessors();\r\n	//存放Cell的hash表，大小为2的幂\r\n	transient volatile Cell[] cells;\r\n	/*\r\n	1.在开始没有竞争的情况下,将累加值累加到base；\r\n	2.在cells初始化的过程中，cells处于不可用的状态，这时候也会尝试将通过cas操作值累加到base\r\n	*/\r\n	transient volatile long base;\r\n	/*\r\n	cellsBusy,它有两个值0或1,它的作用是当要修改cells数组时加锁,\r\n	防止多线程同时修改cells数组(也称cells表)，0为无锁，1位加锁，加锁的状况有三种:\r\n	(1). cells数组初始化的时候；\r\n    (2). cells数组扩容的时候；\r\n    (3).如果cells数组中某个元素为null，给这个位置创建新的Cell对象的时候；\r\n\r\n	*/\r\n	transient volatile int cellsBusy;\r\n	\r\n	//低并发状态,还没有新建cell数组且写入进入base,刚好够用\r\n	//base罩得住,不用上cell数组\r\n	final boolean casBase(long cmp, long val) {\r\n		//当前对象,在base位置上,将base(类似于AtomicLong中全局的value值),将base=0(cmp)改为1(value)\r\n		return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);\r\n	}\r\n	\r\n	final void longAccumulate(long x, LongBinaryOperator fn,\r\n							  boolean wasUncontended) {\r\n		//存储线程的probe值\r\n		int h;\r\n		//如果getProbe()方法返回0,说明随机数未初始化\r\n		if ((h = getProbe()) == 0) { //这个if相当于给当前线程生成一个非0的hash值\r\n			//使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化\r\n			ThreadLocalRandom.current(); // force initialization\r\n			//重新获取probe值,hash值被重置就好比一个全新的线程一样,所以设置了wasUncontended竞争状态为true\r\n			h = getProbe();\r\n			//重新计算了当前线程的hash后认为此次不算是一次竞争,都未初始化,肯定还不存在竞争激烈,wasUncontended竞争状态为true\r\n			wasUncontended = true;\r\n		}\r\n		//如果hash取模映射得到的Cell单元不是null,则为true,此值也可以看作是扩容意向\r\n		boolean collide = false;                // True if last slot nonempty\r\n		for (;;) {\r\n			Cell[] as; Cell a; int n; long v;\r\n			if ((as = cells) != null && (n = as.length) > 0) { // CASE1:cells已经初始化了\r\n			    // 当前线程的hash值运算后映射得到的Cell单元为null,说明该Cell没有被使用\r\n				if ((a = as[(n - 1) & h]) == null) {\r\n					//Cell[]数组没有正在扩容\r\n					if (cellsBusy == 0) {       // Try to attach new Cell\r\n						//先创建一个Cell\r\n						Cell r = new Cell(x);   // Optimistically create\r\n						//尝试加锁,加锁后cellsBusy=1\r\n						if (cellsBusy == 0 && casCellsBusy()) { \r\n							boolean created = false;\r\n							try {               // Recheck under lock\r\n								Cell[] rs; int m, j; //将cell单元赋值到Cell[]数组上\r\n								//在有锁的情况下再检测一遍之前的判断 \r\n								if ((rs = cells) != null &&\r\n									(m = rs.length) > 0 &&\r\n									rs[j = (m - 1) & h] == null) {\r\n									rs[j] = r;\r\n									created = true;\r\n								}\r\n							} finally {\r\n								cellsBusy = 0;//释放锁\r\n							}\r\n							if (created)\r\n								break;\r\n							continue;           // Slot is now non-empty\r\n						}\r\n					}\r\n					collide = false;\r\n				}\r\n				/**\r\n				wasUncontended表示cells初始化后,当前线程竞争修改失败\r\n				wasUncontended=false,表示竞争激烈,需要扩容,这里只是重新设置了这个值为true,\r\n				紧接着执行advanceProbe(h)重置当前线程的hash,重新循环\r\n				*/\r\n				else if (!wasUncontended)       // CAS already known to fail\r\n					wasUncontended = true;      // Continue after rehash\r\n				//说明当前线程对应的数组中有了数据,也重置过hash值\r\n				//这时通过CAS操作尝试对当前数中的value值进行累加x操作,x默认为1,如果CAS成功则直接跳出循环\r\n				else if (a.cas(v = a.value, ((fn == null) ? v + x :\r\n											 fn.applyAsLong(v, x))))\r\n					break;\r\n				//如果n大于CPU最大数量,不可扩容,并通过下面的h=advanceProbe(h)方法修改线程的probe再重新尝试\r\n				else if (n >= NCPU || cells != as)\r\n					collide = false;    //扩容标识设置为false,标识永远不会再扩容\r\n				//如果扩容意向collide是false则修改它为true,然后重新计算当前线程的hash值继续循环\r\n				else if (!collide) \r\n					collide = true;\r\n				//锁状态为0并且将锁状态修改为1(持有锁) \r\n				else if (cellsBusy == 0 && casCellsBusy()) { \r\n					try {\r\n						if (cells == as) {      // Expand table unless stale\r\n							//按位左移1位来操作,扩容大小为之前容量的两倍\r\n							Cell[] rs = new Cell[n << 1];\r\n							for (int i = 0; i < n; ++i)\r\n								//扩容后将之前数组的元素拷贝到新数组中\r\n								rs[i] = as[i];\r\n							cells = rs; \r\n						}\r\n					} finally {\r\n						//释放锁设置cellsBusy=0,设置扩容状态,然后进行循环执行\r\n						cellsBusy = 0;\r\n					}\r\n					collide = false;\r\n					continue;                   // Retry with expanded table\r\n				}\r\n				h = advanceProbe(h);\r\n			}\r\n			//CASE2:cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化cells数组\r\n			/*\r\n			cellsBusy:初始化cells或者扩容cells需要获取锁,0表示无锁状态,1表示其他线程已经持有了锁\r\n			cells == as == null  是成立的\r\n			casCellsBusy:通过CAS操作修改cellsBusy的值,CAS成功代表获取锁,返回true,第一次进来没人抢占cell单元格,肯定返回true\r\n			**/\r\n			else if (cellsBusy == 0 && cells == as && casCellsBusy()) { \r\n			    //是否初始化的标记\r\n				boolean init = false;\r\n				try {                           // Initialize table(新建cells)\r\n					// 前面else if中进行了判断,这里再次判断,采用双端检索的机制\r\n					if (cells == as) {\r\n						//如果上面条件都执行成功就会执行数组的初始化及赋值操作,Cell[] rs = new Cell[2]标识数组的长度为2\r\n						Cell[] rs = new Cell[2];\r\n						//rs[h & 1] = new Cell(x)表示创建一个新的cell元素,value是x值,默认为1\r\n						//h & 1 类似于我们之前hashmap常用到的计算散列桶index的算法,通常都是hash&(table.len-1),同hashmap一个意思\r\n						rs[h & 1] = new Cell(x);\r\n						cells = rs;\r\n						init = true;\r\n					}\r\n				} finally {\r\n					cellsBusy = 0;\r\n				}\r\n				if (init)\r\n					break;\r\n			}\r\n			//CASE3:cells正在进行初始化,则尝试直接在基数base上进行累加操作\r\n			//这种情况是cell中都CAS失败了,有一个兜底的方法\r\n			//该分支实现直接操作base基数,将值累加到base上,也即其他线程正在初始化,多个线程正在更新base的值\r\n			else if (casBase(v = base, ((fn == null) ? v + x :\r\n										fn.applyAsLong(v, x))))\r\n				break;                          // Fall back on using base\r\n		}\r\n	}\r\n	\r\n	static final int getProbe() {\r\n        return UNSAFE.getInt(Thread.currentThread(), PROBE);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### LongAdder.java\r\n\r\n```java\r\n    LongAdder.java\r\n	(1).baseOK,直接通过casBase进行处理\r\n	(2).base不够用了,开始新建一个cell数组,初始值为2\r\n    (3).当多个线程竞争同一个Cell比较激烈时,可能就要对Cell[ ]扩容\r\n	public void add(long x) {\r\n		//as是striped64中的cells数组属性\r\n		//b是striped64中的base属性\r\n		//v是当前线程hash到的cell中存储的值\r\n		//m是cells的长度减1,hash时作为掩码使用\r\n		//a时当前线程hash到的cell\r\n        Cell[] as; long b, v; int m; Cell a;\r\n		/**\r\n		首次首线程(as = cells) != null)一定是false,此时走casBase方法,以CAS的方式更新base值,\r\n		且只有当cas失败时,才会走到if中\r\n		条件1:cells不为空,说明出现过竞争,cell[]已创建\r\n		条件2:cas操作base失败,说明其他线程先一步修改了base正在出现竞争\r\n		*/\r\n        if ((as = cells) != null || !casBase(b = base, b + x)) {\r\n			//true无竞争 fasle表示竞争激烈,多个线程hash到同一个cell,可能要扩容\r\n            boolean uncontended = true;\r\n			/*\r\n			条件1:cells为空,说明正在出现竞争,上面是从条件2过来的,说明!casBase(b = base, b + x))=true\r\n				  会通过调用longAccumulate(x, null, uncontended)新建一个数组,默认长度是2\r\n			条件2:默认会新建一个数组长度为2的数组,m = as.length - 1) < 0 应该不会出现,\r\n			条件3:当前线程所在的cell为空,说明当前线程还没有更新过cell,应初始化一个cell。\r\n				  a = as[getProbe() & m]) == null,如果cell为空,进行一个初始化的处理\r\n			条件4:更新当前线程所在的cell失败,说明现在竞争很激烈,多个线程hash到同一个Cell,应扩容\r\n				  (如果是cell中有一个线程操作,这个时候,通过a.cas(v = a.value, v + x)可以进行处理,返回的结果是true)\r\n			**/\r\n            if (as == null || (m = as.length - 1) < 0 ||\r\n			    //getProbe( )方法返回的时线程中的threadLocalRandomProbe字段\r\n				//它是通过随机数生成的一个值,对于一个确定的线程这个值是固定的(除非刻意修改它)\r\n                (a = as[getProbe() & m]) == null ||\r\n                !(uncontended = a.cas(v = a.value, v + x)))\r\n				//调用Striped64中的方法处理\r\n                longAccumulate(x, null, uncontended);\r\n        }\r\n    }\r\n	\r\n	Striped64.java\r\n	abstract class Striped64 extends Number {\r\n		static final int NCPU = Runtime.getRuntime().availableProcessors();\r\n		transient volatile Cell[] cells;\r\n		transient volatile long base;\r\n		transient volatile int cellsBusy;\r\n		//低并发状态,还没有新建cell数组且写入进入base,刚好够用\r\n		//base罩得住,不用上cell数组\r\n		final boolean casBase(long cmp, long val) {\r\n			//当前对象,在base位置上,将base(类似于AtomicLong中全局的value值),将base=0(cmp)改为1(value)\r\n			return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);\r\n		}\r\n	}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','image/JUC04.assets/image-20230716172303473.png','原创',0,_binary '',_binary '',_binary '\0','2023-07-22 22:08:12',NULL,2022576839,'JUC04-- CAS自旋 、CAS自旋锁、ABA问题及解决办法、18大原子类',NULL,NULL,'0'),(1682754705568067585,'JUC05-ThreadLocal、ThreadLocal底层与Thead、ThreadLocalMap之间的关系、Java对象内存布局','[TOC]\r\n\r\n\r\n\r\n# JUC05\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- ThreadLocal\r\n  - <font color=\'red\'>ThreadLocal底层与Thead、ThreadLocalMap之间的关系</font>\r\n\r\n- 内存布局\r\n\r\n\r\n\r\n\r\n\r\n# ThreadLocal\r\n\r\n\r\n\r\n## 定义和作用\r\n\r\n\r\n\r\n**是什么？**\r\n\r\nThreadLocal提供线程局部变量。这些变量<font color=\'red\'>与正常的变量不同</font>，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）<font color=\'red\'>都有自己的、独立初始化的变量副本</font>。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务D)与线程关联起来。\r\n\r\n\r\n\r\n**能干嘛？**\r\n\r\n实现<font color=\'red\'>**每一个线程都有自己专属的本地变量副本**</font>（自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份）：\r\n\r\n<font color=\'cornflowerblue\'>主要解决了让每个线程绑定自己的值</font>，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值<font color=\'red\'>从而避免了线程安全问题</font>，比如我们之前讲解的8锁案例，资源类是使用同一部手机，多个线程抢夺同一部手机使用，假如人手一份是不是天下太平？？\r\n\r\n\r\n\r\n我的理解：\r\n\r\n- 不是前面JMM中的本地内存，前面的本地内存是共享主内存中的拷贝，这里的是每个线程独有的一份不一致的变量，不是拷贝来的副本，是本来就是自己的\r\n\r\n\r\n\r\n**常用API**\r\n\r\n- protected T initialValue()\r\n\r\n  - 返回此线程局部变量的当前线程的“初始值”。\r\n\r\n  - 不推荐使用这个方法初始化，因为要使用匿名内部类的方式重写此方法\r\n\r\n  - ```java\r\n    ThreadLocal<Integer> saleVolume = new ThreadLocal<Integer>(){\r\n        @Override\r\n        protected Integer initialValue() {\r\n            return 0;\r\n        }\r\n    };\r\n    ```\r\n\r\n- static < S> ThreadLocal< S> withInitial(Supplier<? extends S> supplier)\r\n\r\n  - 创建一个线程局部变量。\r\n\r\n  - 推荐使用此方法初始化，jdk1.8新增的静态方法，可使用函数式接口\r\n\r\n  - ```java\r\n    ThreadLocal<Integer> saleVolume = ThreadLocal.withInitial(() -> 0);\r\n    ```\r\n\r\n- T get()\r\n\r\n  - 返回当前线程的此线程局部变量副本中的值。\r\n\r\n- void remove()\r\n\r\n  - 删除此线程局部变量的当前线程值。\r\n\r\n- void set(T value)\r\n\r\n  - 将此线程局部变量的当前线程副本设置为指定值。\r\n\r\n\r\n\r\n## ThreadLocal的使用\r\n\r\n\r\n\r\n> 6【强制】**必须回收自定义的ThreadLocal变量**，尤其在<font color=\'red\'>线程池场景下，线程经常会被复用</font>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和<font color=\'red\'>造成内存泄露等</font>问题。尽量在代理中使用try-finally块进行回收。\r\n>\r\n> 正例：\r\n>\r\n> ```java\r\n> objectThreadLocal.set(userlnfo);\r\n> try{\r\n> 	//...\r\n> }finally{\r\n> 	objectThreadLocal.remove();\r\n> }\r\n> ```\r\n\r\n\r\n\r\n<font color=\'red\'>按照阿里开发手册，我们要养成习惯，必须在finally中回收remove掉threadLocal变量</font>\r\n\r\n\r\n\r\n### 使用场景案例：\r\n\r\n```java\r\n/**\r\n * 需求1： 5个销售卖房子，集团高层只关心销售总量的准确统计数。\r\n * 需求2： 5个销售卖完随机数房子，各自独立销售额度，自己业绩按提成走，分灶吃饭，各个销售自己动手，丰衣足食\r\n */\r\nclass House {\r\n    int saleCount = 0;\r\n    \r\n    //需求1\r\n    public synchronized void saleHouse(){\r\n        ++saleCount;\r\n    }\r\n    \r\n    //需求2\r\n    //初始化方法1，非常不方便\r\n    /*ThreadLocal<Integer> saleVolume = new ThreadLocal<Integer>(){\r\n        @Override\r\n        protected Integer initialValue() {\r\n            return 0;\r\n        }\r\n    };*/\r\n    \r\n    //初始化方法2，推荐\r\n    ThreadLocal<Integer> saleVolume = ThreadLocal.withInitial(() -> 0);\r\n    \r\n    public void saleVolumeByThreadLocal(){\r\n        saleVolume.set(1 + saleVolume.get());\r\n    }\r\n}\r\npublic class ThreadLocalDemo1 {\r\n    public static void main(String[] args) {\r\n        House house = new House();\r\n        for (int i = 1; i <= 5; i++) {\r\n            new Thread(() -> {\r\n                int size = new Random().nextInt(5) + 1;\r\n                try {\r\n                    for (int j = 1; j <= size ; j++) {\r\n                        house.saleHouse();\r\n                        house.saleVolumeByThreadLocal();\r\n                    }\r\n                    System.out.println(Thread.currentThread().getName()+\"\\t\"+\"号销售卖出：\"+house.saleVolume.get());\r\n                } finally {\r\n                    house.saleVolume.remove();\r\n                }\r\n            },String.valueOf(i)).start();\r\n        }\r\n        //暂停毫秒\r\n        try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"共计卖出多少套： \"+house.saleCount);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 遵守阿里规范案例：\r\n\r\n\r\n\r\n使用线程池的时候，会复用线程池中的线程，于是第二次调用ThreadLocal变量的时候，将会从之前调用过的基础上进行相加，所以每次调用线程池后都应该remove掉该线程加上的值\r\n\r\n\r\n\r\n```java\r\n/**\r\n * 【强制】必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理\r\n * 自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用\r\n * try-finally 块进行回收。\r\n */\r\nclass MyData{\r\n    ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\r\n    public void add(){\r\n        threadLocal.set(1 + threadLocal.get());\r\n    }\r\n}\r\npublic class ThreadLocalDemo2 {\r\n    public static void main(String[] args) {\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n        MyData myData = new MyData();\r\n        try {\r\n            for (int i = 1; i <= 10 ; i++) {\r\n                threadPool.submit(() -> {\r\n                    try {\r\n                        Integer beforeInt = myData.threadLocal.get();\r\n                        myData.add();\r\n                        Integer afterInt = myData.threadLocal.get();\r\n                        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"beforeInt:\"+beforeInt+\"\\t afterInt: \"+afterInt);\r\n                    } finally {\r\n                        myData.threadLocal.remove();\r\n                    }\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            threadPool.shutdown();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n执行结果：\r\n\r\n- 加上remove\r\n\r\n- ```\r\n  pool-1-thread-3	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-1	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-2	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-3	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-2	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-1	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-1	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-3	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-2	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-1	beforeInt:0	 afterInt: 1\r\n  ```\r\n\r\n- 未加remove\r\n\r\n- ```\r\n  pool-1-thread-1	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-3	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-2	beforeInt:0	 afterInt: 1\r\n  pool-1-thread-1	beforeInt:1	 afterInt: 2\r\n  pool-1-thread-2	beforeInt:1	 afterInt: 2\r\n  pool-1-thread-3	beforeInt:1	 afterInt: 2\r\n  pool-1-thread-1	beforeInt:2	 afterInt: 3\r\n  pool-1-thread-1	beforeInt:3	 afterInt: 4\r\n  pool-1-thread-3	beforeInt:2	 afterInt: 3\r\n  pool-1-thread-2	beforeInt:2	 afterInt: 3\r\n  ```\r\n\r\n\r\n\r\n\r\n\r\n## ==ThreadLocal源码分析==\r\n\r\n\r\n\r\n### Thread、ThreadLocal、ThreadLocalMap这三个类之间的关系？\r\n\r\n\r\n\r\n- Thread类中包含一条属性是	ThreadLocal.ThreadLocalMap threadLocals = null;\r\n- 然后ThreadLocalMap是ThreadLocal中的一个静态内部类\r\n- threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。\r\n\r\n```java\r\nvoid createMap(Thread t,T firstvalue){\r\n	t.threadLocals new ThreadLocalMap(this, firstvalue);\r\n}\r\n```\r\n\r\n当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放\r\n\r\n\r\n\r\n**近似的可以理解为：**\r\n\r\nThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key),不过是经过了两层包装的ThreadLocal对象：\r\n\r\n![image-20230718162024396](image/JUC05.assets/image-20230718162024396.png)\r\n\r\n<font color=\'red\'>JVM内部维护了一个线程版的Map<ThreadLocal, Value></font>(<font color=\'cornflowerblue\'>通过ThreadLocalx对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中</font>)，每个线程要用到这个T的时候，用当前的线程去Map里面获取，<font color=\'red\'>通过这样让每个线程都拥有了自己独立的变量</font>，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。\r\n\r\n\r\n\r\n自己的理解：\r\n\r\n- 一个线程可能有多个线程局部变量，就放在entry中，key为当前threadLocal实例，value为值\r\n- 即同一个线程多个ThreadLocal 都是保存到同一个ThreadLocalMap里面\r\n\r\n\r\n\r\n\r\n\r\n### ThreadLocal为什么使用弱引用？为什么还会内存泄露？\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>**ThreadLocalMap与WeakReference**</font>\r\n\r\n```java\r\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\r\n    /** The value associated with this ThreadLocal. */\r\n    Object value;\r\n\r\n    Entry(ThreadLocal<?> k, Object v) {\r\n        super(k);\r\n        value = v;\r\n    }\r\n}\r\n```\r\n\r\nThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map（以ThreadLocal为Key），不过是经过了两层包装的ThreadLocal对象\r\n\r\n- (1)第一层包装是使用WeakReference<ThreadLocal<?>>将ThreadLocal对象变成一个弱引用的对象\r\n\r\n- (2)第二层包装是定义了一个专门的类Entry来扩展WeakReference<ThreadLocal<?>>\r\n\r\n\r\n\r\n\r\nThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap.这么个内部类，每个Thread对象维护着一个ThreadLocalMap的引用，ThreadLocalMap是ThreadLocalf的内部类，用Entry来进行存储。\r\n\r\n- 1)调用ThreadLocalf的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象\r\n- 2)调用ThreadLocalf的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象\r\n\r\nThreadLocal本身并不存储值(ThreadLocal是一个壳子)，它只是自己作为一个key来让线程从ThreadLocalMap获取vaue。\r\n\r\n正因为这个原理，所以ThreadLocali能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响\r\n\r\n\r\n\r\n![image-20230718171703585](image/JUC05.assets/image-20230718171703585.png)\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>为什么源代码用弱引用？</font>\r\n\r\n当functione01方法执行完毕后，栈帧销毁强引用t!也就没有了。但此时线程的ThreadLocalMap.里某个entry的key引用还指向这个对象\r\n\r\n- 若这个key引用是<font color=\'cornflowerblue\'>强引用</font>，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；\r\n- 若这个key引用是<font color=\'cornflowerblue\'>弱引用</font>，就<font color=\'red\'>大概率</font>会减少内存泄漏的问题（<font color=\'red\'>还有一个key为null的雷，第2个坑后面讲</font>）。\r\n\r\n使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的<font color=\'red\'>key引用指向为null</font>。\r\n\r\n当前栈帧出栈，当前栈帧对应的threadlocal对象也应当被销毁，如果是强引用，该threadlocal对象就不会被回收，从而发生内存泄漏\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>使用弱引用为什么还会内存泄露？</font>\r\n\r\n- 1当我们为threadLocal变量赋值，实际上就是当前的Entry（threadLocal实例为key，值为value）往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null（tl=null），那么系统GC的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收。这样一来，<font color=\'red\'>ThreadLocalMap中就会出现key为null的Entry，**就没有办法访问这些key为nul的Entry的value**。</font>\r\n  - <font color=\'red\'>如果当前线程再迟迟不结束的话（比如正好在使用**线程池**），这些key为null的Entry的value就会一直存在一条强引用链：   	Thread Ref->Thread->ThreaLocalMap->Entry->value永远无法回收，造成内存泄漏。</font>\r\n- 2当然，**如果当前thread运行结束**，threadLocal,threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。\r\n- 3但在实际使用中<font color=\'cornflowerblue\'>我们有时候会用线程池</font>去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心\r\n\r\n\r\n\r\n虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，<font color=\'red\'>因此弱引用不能100%保证内存不泄露</font>。<font color=\'red\'>**我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它**</font>，尤其是在线程池中，不仅仅是内存泄露的问题，<font color=\'cornflowerblue\'>因为线程池中的线程是重复使用的</font>，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug\r\n\r\n（对应阿里开发手册要求必须调用remove方法）\r\n\r\n线程池线程复用调用get、set方法可能复用key为null的entry对象，所以需要手动执行remove\r\n\r\n\r\n\r\n\r\n\r\n## ThreadLocal小总结\r\n\r\n\r\n\r\n- 记得初始化ThreadLocal，使用ThreadLocal.withInitial(() -> 0);\r\n\r\n- 建议把ThreadLocal设置为static，只是建议\r\n\r\n  - > 19.【参考】ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题。说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。\r\n    >\r\n    > ThreadLocali能实现了线程的数据隔离，不在于它自己本身，而在于Thread的ThreadLocalMap\r\n    > 所以，ThreadLocal可以只初始化一次，只分配一块存储空间就足以了，没必要作为成员变量多次被初始化。\r\n\r\n- <font color=\'red\'>用完记得手动remove</font>\r\n\r\n  - > 6【强制】**必须回收自定义的ThreadLocal变量**，尤其在<font color=\'red\'>线程池场景下，线程经常会被复用</font>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和<font color=\'red\'>造成内存泄露等</font>问题。尽量在代理中使用try-finally块进行回收。\r\n\r\n\r\n\r\n## 一些面试题\r\n\r\n- ThreadLocal中ThreadLocalMap的数据结构和关系？\r\n  - ThreadLocalMap是ThreadLocal的一个静态内部类，threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。不过是经过了两层包装的ThreadLocal对象\r\n    - (1)第一层包装是使用WeakReference<ThreadLocal<?>>将ThreadLocal对象变成一个弱引用的对象\r\n    - (2)第二层包装是定义了一个专门的类Entry来扩展WeakReference<ThreadLocal<?>>\r\n- ThreadLocal的key是弱引用，这是为什么？\r\n  - 准确的说应该是Entry对象的key为弱引用，因为如果Entry的key是强引用的话，当当前方法的栈帧出栈以后，栈帧对threadLocal实例的强引用解除了，但是仍然有Entry对象的key强引用ThreadLocal实例，导致threadLocal实例不能被回收\r\n  - 若是使用弱引用，就可以顺利回收掉threadLocal实例对象，但是还需要手动调用remove方法清除key为null的Entry对象和value对象，因为Entry对象的v也有一条强引用链指向value对象，否则线程池中容易线程复用value对象，造成内存溢出\r\n- ThreadLocal内存泄露问题你知道吗？\r\n  - Entry对象key为弱引用\r\n  - 需要手动remove\r\n- hreadLocal中最后为什么要加remove方法？\r\n  - 用弱引用，就可以顺利回收掉threadLocal实例对象，但是还需要手动调用remove方法清除key为null的Entry对象，因为Entry对象的v也有一条强引用链指向value对象，否则线程池中容易线程复用value对象，造成内存溢出\r\n\r\n\r\n\r\n\r\n\r\n# 对象内存布局与对象头\r\n\r\n\r\n\r\n## 对象内存布局\r\n\r\n\r\n\r\n![image-20230718221207307](image/JUC05.assets/image-20230718221207307.png)\r\n\r\n\r\n\r\n在HotSpot)虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。\r\n\r\n- 对象头（Header）\r\n  - 对象标记MarkWord（运行时元数据）\r\n    - 哈希值（HashCode）\r\n    - GC标志\r\n    - GC次数\r\n    - 同步锁标记\r\n    - 所偏向持有者\r\n    - ......\r\n  - 类元信息（类型指针）\r\n    - 指向方法区中类元数据InstanceKlass，确定该对象所属的类型\r\n    - ![image-20230718221608733](image/JUC05.assets/image-20230718221608733.png)\r\n- 实例数据（Instance Data）\r\n  - 存放类的属性(Field)数据信息，包括父类的属性信息\r\n- 对齐填充\r\n  - 不是必须的，虚拟机要求对象起始地址必须是**8字节的整数倍**。填充数据不是必须存在的：仅仅是为了字节对齐这部分内存按8字节补充对齐\r\n\r\n\r\n\r\n## 64位虚拟机MarkWord都存储什么\r\n\r\n\r\n\r\n![image-20230718221805743](image/JUC05.assets/image-20230718221805743.png)\r\n\r\n![image-20230718222055954](image/JUC05.assets/image-20230718222055954.png)\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>可以看到，在64位系统中，Mark Word占了8个字节，类型指针占了8个字节（忽略压缩指针），那么整个对象头就占了16个字节</font>\r\n\r\n\r\n\r\n**markOop.hpp**\r\n\r\nhash: 保存对象的哈希码\r\nage: 保存对象的分代年龄\r\nbiased_lock: 偏向锁标识位\r\nlock: 锁状态标识位\r\nJavaThread* :保存持有偏向锁的线程ID\r\nepoch: 保存偏向时间戳\r\n\r\n![image-20230718222331258](image/JUC05.assets/image-20230718222331258.png)\r\n\r\n\r\n\r\n## 对象头以及对象大小计算\r\n\r\n\r\n\r\n虚拟机要求对象起始地址必须是**8字节的整数倍**\r\n\r\n在上面图中可以找到：<font color=\'cornflowerblue\'>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节（忽略压缩指针），那么整个对象头就占了16个字节</font>\r\n\r\n\r\n\r\n我们先简单估算一下下面这个类的对象大小：\r\n\r\n![image-20230718222531441](image/JUC05.assets/image-20230718222531441.png)\r\n\r\n应该是有24个字节的\r\n\r\n- 对象头为 8+8=16字节\r\n- int类型32位4个字节，boolean类型8位1个字节\r\n- 对齐填充为8的倍数，3个字节\r\n\r\n\r\n\r\n**代码演示**\r\n\r\n我们要用到一个工具JOL：\r\n\r\n```xml\r\n    <!--\r\n    JAVA object layout\r\n    官网:http://openjdk.java.net/projects/code-tools/jol/\r\n    定位:分析对象在JVM的大小和分布\r\n    -->\r\n    <dependency>\r\n        <groupId>org.openjdk.jol</groupId>\r\n        <artifactId>jol-core</artifactId>\r\n        <version>0.9</version>\r\n    </dependency>\r\n```\r\n\r\n\r\n\r\n简单演示JOL的使用：\r\n\r\n![image-20230718222857403](image/JUC05.assets/image-20230718222857403.png)\r\n\r\n\r\n\r\n测试中打印数据可参数的解释：\r\n\r\n| OFFSET      | 偏移量，也就是到这个字段位置所占用的byte数 |\r\n| ----------- | ------------------------------------------ |\r\n| SIZE        | 后面类型的字节大小                         |\r\n| TYPE        | 是Class中定义的类型                        |\r\n| DESCRIPTION | DESCRIPTION是类型的描述                    |\r\n| VALUE       | VALUE是TYPE在内存中的值                    |\r\n\r\n\r\n\r\n测试new一个Object类：\r\n\r\n可以看到最终大小是 8字节MarkWord + 4字节类型指针（因为指针压缩）+ 2字节对齐填充 = 16字节（8的倍数）\r\n\r\n![image-20230718223059912](image/JUC05.assets/image-20230718223059912.png)\r\n\r\n\r\n\r\n测试一个自己写的Customer类：\r\n\r\n可以看到最终大小是 8字节MarkWord + 4字节类型指针（因为指针压缩）+ 4字节int + 1字节boolean + 7字节对齐填充 = 24字节（8的倍数）\r\n\r\n![image-20230718223326681](image/JUC05.assets/image-20230718223326681.png)\r\n\r\n\r\n\r\n## GC分代年龄测试和指针压缩\r\n\r\n\r\n\r\n在64位虚拟机MarkWord存储表中可以看到：<font color=\'red\'>GC年龄采用4位bit存储，最大为15</font>，例如MaxTenuringThreshold参数默认值就是15\r\n\r\n如果设置参数-XX:MaxTenuringThreshold=16的话，将会报异常\r\n\r\n\r\n\r\n**指针压缩**\r\n\r\n- 虚拟机默认开启了指针压缩，将类型指针的大小从8字节压缩为4字节，对应虚拟机参数：-XX:+UseCmopressedClassPointers\r\n- 可使用参数：-XX:+PrintCommandLineFlags打印虚拟机使用到的所有参数，查看对应压缩指针的参数是否被使用\r\n- 若手动关闭指针压缩：-XX:-UseCmopressedClassPointers\r\n- 那么再次使用JOL测试将会发现类型指针为8个字节\r\n\r\n\r\n\r\n\r\n\r\n## 一些面试题\r\n\r\n12、你觉得目前面试，你还有那些方面理解的比较好，我没问到的，我说了juc和jvm以及同步锁机制\r\n13、那先说juc吧，说下aqs的大致流程\r\n14、cas自旋锁，是获取不到锁就一直自旋吗？cas和synchronized区别在哪里，为什么cas好，具体优势在哪里，我说cas避免cpu切换线程的开销，又问我在自旋的这个线程能保证一直占用cpu吗？假如cpu放弃这个线程，不是还要带来线程再次抢占cpu的开销？\r\n15、synchronized底层如何实现的，实现同步的时候用到cas了吗？具体哪里用到了\r\n16、我说上个问题的时候说到了对象头，问我对象头存储哪些信息，长度是多少位存储\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','image/JUC05.assets/image-20230718162024396.png','原创',0,_binary '',_binary '',_binary '\0','2023-07-22 22:09:20',NULL,2022576839,'JUC05-ThreadLocal、ThreadLocal底层与Thead、ThreadLocalMap之间的关系、Java对象内存布局',NULL,NULL,'0'),(1682755018022744066,'JUC06-无锁、偏向锁、轻量级锁、重量级锁，synchronized锁升级','[TOC]\r\n\r\n\r\n\r\n\r\n\r\n# JUC06\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- <font color=\'red\'>synchronized锁升级</font>\r\n\r\n\r\n\r\n# ==Synchronized锁升级==\r\n\r\n本章学习建议：从上往下看，发现看不懂时，找到下面最近的一个	`我的理解`	，然后根据我的理解中我概括的内容，再去看上面的东西\r\n\r\n小结和本章最后最后都会有我的理解汇总\r\n\r\n## 本章路线总纲\r\n\r\nsynchronized相关基础知识点和字节码分析请看	《JUC02》的多线程锁目录\r\n\r\n\r\n\r\n> 【强制】高并发时，同步调用应该去考量锁的性能损耗。**能用无锁数据结构，就不要用锁**；**能锁区块，就不要锁整个方法体**；**能用对象锁，就不要用类锁**。\r\n>\r\n> 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。\r\n>\r\n> ​																																				——《阿里开发手册》\r\n\r\n\r\n\r\n**synchronized锁优化的背景**\r\n\r\n用锁能够实现数据的<font color=\'red\'>安全性</font>，但是会带来<font color=\'red\'>性能下降。</font>\r\n\r\n无锁能够基于线程并行提升程序性能，但是会带来<font color=\'red\'>安全性下降。</font>\r\n\r\n所以我们要找一个平衡：\r\n\r\n\r\n\r\n锁的升级过程：\r\n\r\n无锁		-->		偏向锁		-->		轻量级锁		-->		重量级锁\r\n\r\n\r\n\r\nsynchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略\r\n\r\n![image-20230719144812388](image/JUC06.assets/image-20230719144812388.png)\r\n\r\n\r\n\r\n\r\n\r\n## 锁的发展\r\n\r\n\r\n\r\n### JDK5前只有重量级锁\r\n\r\n\r\n\r\n#### 重量级锁的实现\r\n\r\n![image-20230719145432020](image/JUC06.assets/image-20230719145432020.png)\r\n\r\nJava的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要<font color=\'cornflowerblue\'>操作系统介入</font>，<font color=\'red\'>需要在用户态与核心态之间切换</font>，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。\r\n\r\n在Java早期版本中，<font color=\'red\'>synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依懒于底层的操作系统的**Mutex Lock(系统互斥量)**来实现的</font>，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。Java6之后，为了减少获得锁和释放锁所带来的性能消耗，<font color=\'red\'>引入了轻量级锁和偏向锁</font>\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- JDK5之前，只有重量级锁\r\n- 假如锁的竞争比较激烈的话，会导致性能下降\r\n- 重量级锁是用户态和内核态之间切换，容易导致阻塞\r\n- <font color=\'red\'>**所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞**</font>\r\n\r\n\r\n\r\n\r\n\r\n#### markOop.hpp和Monitor\r\n\r\n\r\n\r\n![image-20230719150129397](image/JUC06.assets/image-20230719150129397.png)\r\n\r\nMonitor（监视器锁、管程，也就是锁）可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。<font color=\'red\'>Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做**内部锁或者Monitor锁**。</font>\r\n\r\n<font color=\'cornflowerblue\'>Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font>\r\n\r\n\r\n\r\nJVM中的同步就是基于进入和退出管程(Monitor)对象实现的。每个对象实例都会有一个Monitor，Monitor可以和对象一起创建、销毁。\r\nMonitor是由ObjectMonitor实现，而ObjectMonitor是由C++的ObjectMonitor.hpp文件实现，如下所示：\r\n\r\n![image-20230719150607967](image/JUC06.assets/image-20230719150607967.png)\r\n\r\n\r\n\r\n#### java对象和Monitor的关联方式\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>**Mutex Lock**</font>（系统互斥量）\r\n\r\n<font color=\'cornflowerblue\'>Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。</font><font color=\'red\'>所以synchronized是Java语言中的一个重量级操作。</font>\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>**Monitor与java对象以及线程是如何关联？**</font>\r\n\r\n1.如果一个java对象被某个线程锁住，则该java对象的<font color=\'red\'>**Mark Word**</font>字段中LockWord指向monitor的起始地址\r\n\r\n2.Monitor的Owner字段会存放拥有相关联对象锁的线程id\r\n\r\n**Mutex Lock的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。**\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- <font color=\'red\'>即通过对象头中的对象标记MarkWord来标记锁的信息</font>\r\n- 每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁\r\n- <font color=\'red\'>Monitor的本质是**依赖于底层操作系统的Mutex Lock（系统互斥量）实现**，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font>\r\n- Monitor是由ObjectMonitor实现的，<font color=\'cornflowerblue\'>ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font>\r\n- Monitor即重量级锁，即synchronized                  <font color=\'red\'> Monitor       <= =>       重量级锁        <= =>      synchronized</font>\r\n\r\n\r\n\r\n#### 一张图搞定重量级锁和对象头的说明和总结\r\n\r\n\r\n\r\n统计一下前面的我的理解：\r\n\r\n- JDK5之前，只有重量级锁\r\n- 假如锁的竞争比较激烈的话，会导致性能下降\r\n- 重量级锁是用户态和内核态之间切换，容易导致阻塞\r\n- <font color=\'red\'>**所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞**</font>\r\n- \r\n- <font color=\'red\'>即通过对象头中的对象标记MarkWord来标记锁的信息</font>\r\n- 每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁\r\n- <font color=\'red\'>Monitor的本质是**依赖于底层操作系统的Mutex Lock（系统互斥量）**实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font>\r\n- Monitor是由ObjectMonitor实现的，<font color=\'cornflowerblue\'>ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font>\r\n- Monitor即重量级锁，即synchronized                  <font color=\'red\'> Monitor       <= =>       重量级锁        <= => 重量级synchronized</font>\r\n\r\n\r\n\r\n![image-20230719151528990](image/JUC06.assets/image-20230719151528990.png)\r\n\r\n\r\n\r\n\r\n\r\n### JDK6开始优化synchronized\r\n\r\n\r\n\r\nJava6之后，为了减少获得锁和释放锁所带来的性能消耗，<font color=\'red\'>引入了轻量级锁和偏向锁</font>\r\n\r\n\r\n\r\n\r\n\r\n## synchronized锁种类和升级步骤\r\n\r\n\r\n\r\n### 3种多线程访问情况\r\n\r\n- 只有一个线程来访问，有且唯一Only One\r\n- 有多个线程(2线程A、B来交替访问)\r\n- 竞争激烈，更多个线程来访问\r\n\r\n\r\n\r\n后面讲解这三种情况分别对应什么锁以及什么时候升级\r\n\r\n\r\n\r\n**64位标记图再看：**\r\n\r\n![image-20230719144812388](image/JUC06.assets/image-20230719144812388.png)\r\n\r\n\r\n\r\n### 3种MarkWord锁指向\r\n\r\n\r\n\r\nsynchronized用的锁是存在Java对象头里的Mark Word中\r\n\r\n锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位	\r\n\r\n- 偏向锁：MarkWord存储的是偏向的线程ID;\r\n- 轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针；\r\n- 重量锁：MarkWord存储的是指向堆中的monitor对象的指针：\r\n\r\n\r\n\r\n\r\n\r\n### 无锁状态\r\n\r\n《JUC05》中说过的需要使用工具 JOL 进行测试：\r\n\r\n```xml\r\n    <!--\r\n    JAVA object layout\r\n    官网:http://openjdk.java.net/projects/code-tools/jol/\r\n    定位:分析对象在JVM的大小和分布\r\n    -->\r\n    <dependency>\r\n        <groupId>org.openjdk.jol</groupId>\r\n        <artifactId>jol-core</artifactId>\r\n        <version>0.9</version>\r\n    </dependency>\r\n```\r\n\r\n\r\n\r\n无锁：初始状态（new），一个对象被实例化后，如果还没有被任何线程竞争锁，那么它就为<font color=\'red\'>无锁状态（001）</font>\r\n\r\n\r\n\r\n![image-20230719161133433](image/JUC06.assets/image-20230719161133433.png)\r\n\r\n\r\n\r\n查看顺序：整体从右下往左上，8位从左往右\r\n\r\n对应64位标记图：\r\n\r\n- 前25位为unused，使用棕色框起来的\r\n- 之后31位为hashCode（如果调用了），为蓝色框起来的（上图打印的2进制结果最前面补一个0，因为最前面是0被省略了）\r\n- 最后3位为001，代表无锁状态，红色框起来的\r\n\r\n\r\n\r\n\r\n\r\n### 偏向锁\r\n\r\nJDK6-JDK14默认开启，JDK15开始逐渐废弃\r\n\r\n#### 定义和作用\r\n\r\n\r\n\r\n**是什么？**\r\n\r\n<font color=\'cornflowerblue\'>偏向锁：单线程竞争，一个时间点只会有一个线程使用锁或另一个线程第一次竞争锁就成功</font>\r\n\r\n当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。\r\n\r\n如果不存在其他线程竞争，那么持有偏向锁的线程<font color=\'red\'>将永远不需要进行同步。</font>\r\n\r\n\r\n\r\n**主要作用：**\r\n\r\n<font color=\'red\'>当一段同步代码一直被同一个线程多次访问，由于只有一个线程访问锁，那么该线程在后续访问时便会自动获得锁</font>（加锁了但是只有一个线程访问或者只有一个线程抢到锁）\r\n\r\n同一个老顾客来访，直接老规矩行方便\r\n\r\n\r\n\r\n看看多线程卖票，一个线程获得体会一下：几乎所有的票都是由卖出第一张票的线程卖出的\r\n\r\n\r\n\r\n**小结论：**\r\n\r\nHotspot的作者经过研究发现，大多数情况下：\r\n\r\n多线程的情况下，锁不仅不存在多线程竞争，还存在<font color=\'cornflowerblue\'>锁由同一个线程多次获得的情况，</font>\r\n\r\n偏向锁就是在这种情况下出现的，它的出现是为了解决<font color=\'red\'>只有在一个线程执行同步时提高性能。</font>\r\n\r\n<font color=\'cornflowerblue\'>备注：</font>\r\n\r\n偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即<font color=\'red\'>偏向锁在资源没有竞争情况下消除了同步语句</font>，懒的连CAS操作都不做了，直接提高程序性能\r\n\r\n<font color=\'cornflowerblue\'>所以最后64位标记**前54位存储偏向线程ID**，最后三位从无锁的**001改为了**</font><font color=\'red\'>**101**</font>\r\n\r\n\r\n\r\n#### 偏向锁的竞争\r\n\r\n\r\n\r\n**<font color=\'cornflowerblue\'>理论落地：</font>**\r\n\r\n​		在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说<font color=\'red\'>锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</font>\r\n\r\n​		那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同步锁的代码块时，<font color=\'red\'>不需要再次加锁和释放锁</font>。而是直接会去检查锁的MarkWord里面是不是放的自己的线程ID)。\r\n\r\n- <font color=\'red\'>如果相等</font>，表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。<font color=\'red\'>**如果自始至终使用锁的线程只有一个**</font>，<font color=\'red\'>很明显偏向锁几乎没有额外开销，性能极高。</font>\r\n- <font color=\'red\'>如果不等</font>，表示发生了竞争，锁己经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线\r\n  程的ID,\r\n  - <font color=\'red\'>竞争成功</font>，表示之前的线程不存在了，MarkWord，里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；\r\n  - <font color=\'red\'>竞争失败</font>，**这时候会发生偏向锁的撤销，可能需要升级变为轻量级锁**，才能保证线程间公平竞争锁。\r\n\r\n<font color=\'cornflowerblue\'>注意，偏向锁只有遇到其他线程尝试**竞争偏向锁时，持有偏向锁的线程才会释放锁**，线程是不会主动释放偏向锁的</font>\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- 偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（<font color=\'red\'>**偏向锁中竞争一次失败后要么无锁，要么轻量锁**</font>）\r\n  - 偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁\r\n\r\n\r\n\r\n#### 偏向锁实现\r\n\r\n\r\n\r\n**<font color=\'cornflowerblue\'>技术实现：</font>**\r\n\r\n一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用**<font color=\'cornflowerblue\'>前54位来存储线程指针作为标识</font>**。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。\r\n\r\n![image-20230719170223538](image/JUC06.assets/image-20230719170223538.png)\r\n\r\n\r\n\r\n​		偏向锁的操作<font color=\'red\'>**不用直接捅到操作系统，不涉及用户到内核转换**</font>，不必要直接升级为最高级\r\n\r\n​		这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程D也在对象头里)，JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。<font color=\'red\'>由于之前没有释放锁，这里也就不需要重新加锁。**如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高**。</font>\r\n\r\n<font color=\'cornflowerblue\'>结论：</font>**JVM不用和操作系统协商设置Mutex(争取内核**)，它只需要记录下线程ID就标示自己获得了当前锁，不用操作系统接入。\r\n\r\n<font color=\'orange\'>上述就是偏向锁</font>：在没有其他线程竞争的时候，一直偏同编心当前线程，当前线程可以一直执行。\r\n\r\n\r\n\r\n#### 开启关闭偏向锁\r\n\r\n\r\n\r\n使用命令	java -XX:+PrintFlagsInitial | grep BiasedLock*   在控制台查看偏向锁的开启情况\r\n\r\n```shell\r\njava -XX:+PrintFlagsInitial |grep BiasedLock*\r\n     intx BiasedLockingBulkRebiasThreshold          = 20                                  {product}\r\n     intx BiasedLockingBulkRevokeThreshold          = 40                                  {product}\r\n     intx BiasedLockingDecayTime                    = 25000                               {product}\r\n     intx BiasedLockingStartupDelay                 = 4000                                {product}\r\n     bool TraceBiasedLocking                        = false                               {product}\r\n     bool UseBiasedLocking                          = true                                {product}\r\n```\r\n\r\n\r\n\r\n实际上病向锁在JDK1.6之后是激认开启的，但是启动时间有延迟，延迟默认是4s，程序启动前sleep 4秒就可以\r\n\r\n所以需要添加参数-XX:BiasedLockingStartupDelay=0，让其在程序启动时立刻启动。\r\n\r\n- 开启偏向锁：\r\n  - -XX:+UseBiasedLocking（JDK6后默认）		 -XX:BiasedLockingStartupDelay=0\r\n- 关闭偏向锁：\r\n  - <font color=\'red\'>关闭之后程序默认会直接进入-------------------------------------->>>>>>>	经量级锁状态。</font>\r\n  - -XX:-UseBiasedLocking\r\n\r\n\r\n\r\n演示时，若未指定		-XX:BiasedLockingStartupDelay=0		，那么将看不到101标志位的效果，需要设置该参数后才可以\r\n\r\n特殊情况：若没有加同步代码块状态下也为101是因为此时锁是可偏向的状态（线程睡了5秒），**但是记录线程id的位数全都为0000000**\r\n\r\n![image-20230719174657636](image/JUC06.assets/image-20230719174657636.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 偏向锁的撤销\r\n\r\n\r\n\r\n**偏向锁的撤销：**\r\n\r\n偏向锁使用一种等到<font color=\'red\'>竞争出现才释放锁</font>的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。\r\n\r\n<font color=\'cornflowerblue\'>竞争线程尝试CAS更新对象头失败时，</font><font color=\'red\'>原持有锁的线程会到达全局安全点，发生STW（该时间点上没有代码正在执行，即会暂停原持有锁的线程）</font>，检查持有偏向锁的线程是否还在执行：\r\n\r\n- ①第一个线程正在执行synchronized方法（<font color=\'red\'>处于同步块</font>），它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现<font color=\'red\'>锁升级</font>。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。\r\n- ②第一个线程执行完成synchronized方法（<font color=\'red\'>退出同步块</font>），则将对象头设置成无锁状态并撤销偏向锁，重新偏向。\r\n\r\n![image-20230719201605132](image/JUC06.assets/image-20230719201605132.png)\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- 偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（<font color=\'red\'>**偏向锁中竞争一次失败后要么无锁，要么轻量锁**</font>）\r\n  - 偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁\r\n\r\n\r\n\r\n### 轻量级锁\r\n\r\n\r\n\r\n#### 定义\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>轻量级锁：多线程竞争，但是任意时刻最多只有一个线程竞争</font>，即不存在锁竞争太过激烈的情况，也就没有线程阻塞。\r\n\r\n\r\n\r\n- 有线程来参与锁的竞争，但是获取锁的冲突时间极短\r\n- 本质就是自旋锁CAS\r\n\r\n\r\n\r\n#### 升级为轻量级锁\r\n\r\n\r\n\r\n轻量级锁是为了在线程<font color=\'red\'>近乎交替（很小的重叠）</font>执行同步块时提高性能。\r\n\r\n主要目的：在没有多线程竞争的前提下，<font color=\'red\'>通过CAS减少</font>重量级锁使用操作系统互斥量产生的性能消耗，说白了<font color=\'red\'>先自旋，不行才升级阻塞。</font>\r\n\r\n升级时机：\r\n\r\n- **1 关闭偏向锁功能**\r\n- **2 多线程竞争偏向锁**\r\n- **特殊情况：无锁状态下调用过hashCode，加锁时将会直接升级到轻量级锁**\r\n\r\n\r\n\r\n假如线程A己经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁己经被线程A拿到，当前该锁己是**偏向锁**了。\r\n\r\n而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。\r\n\r\n**<font color=\'red\'>此时线程B操作中有两种情况：</font>**\r\n\r\n- <font color=\'cornflowerblue\'>**如果锁获取成功**</font>，直接替换Mark Word中的线程ID为B自己的ID(A→B),重新偏向于其他线程（即将偏向锁交给其他线程，相当于当前线程\"被\"释了锁)，该锁会继续保持偏向锁状态，A线程Over，B线程上位；\r\n- <font color=\'cornflowerblue\'>**如果锁获取失败**</font>，**成功经过偏向锁的撤销后，偏向锁升级为轻量级锁**（设置偏向锁标识为0并设置锁标志位为00），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。\r\n\r\n![image-20230719212517502](image/JUC06.assets/image-20230719212517502.png)\r\n\r\n\r\n\r\n有人跟持有轻量级锁的线程竞争时，若是竞争失败，<font color=\'red\'>CAS自旋达到一定次数还未获得锁的话</font>，将会再次进行锁升级为重量级锁\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- 偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color=\'red\'>偏向锁中竞争一次失败后要么无锁，要么轻量锁</font>**）\r\n  - 偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁\r\n- 如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁\r\n\r\n\r\n\r\n#### 轻量级锁升级为重量级锁的自旋次数\r\n\r\n\r\n\r\n有人跟持有轻量级锁的线程竞争时，若是竞争失败，<font color=\'red\'>CAS自旋达到一定次数还未获得锁的话</font>，将会再次进行锁升级为重量级锁\r\n\r\n- JDK6之前\r\n  - 默认启用，默认情况下自旋的**次数**是10次，或者自旋**线程数**超过CPU核数一半\r\n  - -XX:PreBlockSpin=10\r\n- **JDK6之后**\r\n  - 自适应自旋锁\r\n  - 线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。\r\n    反之，如果很少会自旋成功，那么下次会减少自旋的次数其至不自旋，避免CPU空转。\r\n  - **自适应意味着自旋的次数不是固定不变的**，而是根据：同一个锁上一次自旋的时间。拥有锁线程的状态来决定。\r\n\r\n\r\n\r\n**和偏向锁的区别：**\r\n\r\n争夺轻量级锁失败时，自旋尝试抢占锁\r\n\r\n轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁\r\n\r\n\r\n\r\n\r\n\r\n#### 轻量级锁的加锁和释放\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>轻量级锁的加锁</font>\r\n\r\nJVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，官方成为Displaced Mark Word。若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。自旋CAS:不断尝试去获取锁，能不升级就不往上捅，尽量不要阻塞\r\n\r\n<font color=\'cornflowerblue\'>轻量级锁的释放</font>\r\n\r\n在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程\r\n\r\n\r\n\r\n总结：<font color=\'cornflowerblue\'>升级为轻量级锁时</font>，JVM会<font color=\'red\'>在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝</font>，该拷贝中可以包含identity hash code，所以<font color=\'red\'>轻量级锁可以和identity hash code共存</font>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。\r\n\r\n\r\n\r\n\r\n\r\n### 重量级锁\r\n\r\n\r\n\r\n#### 重量级锁原理\r\n\r\nJava中synchronized的重量级锁，是<font color=\'red\'>基于进入和退出Monitor对象实现的</font>。在编译时会将同步块的开始位置插入**monitor enter**指令，在结束位置插入**monitor exit**指令。\r\n\r\n当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即<font color=\'red\'>获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor</font>。\r\n\r\n![image-20230719223233660](image/JUC06.assets/image-20230719223233660.png)\r\n\r\n\r\n\r\n> 重量级锁的详细实现查看前面	锁的发展中的JDK5之前部分\r\n>\r\n> 字节码层面的monitor enter看JUC02中的多线程锁部分\r\n\r\n\r\n\r\n\r\n\r\n### 锁升级后没有存放hash值的标志位怎么办？\r\n\r\n\r\n\r\n锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢？\r\n\r\n​                                                                                                                                                                                                                  \r\n\r\n用书中的一段话来描述锁和hashcode之前的关系\r\n\r\n> 在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode0方法按自己的意愿返回哈希码)，否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object:hashCode)方法，返回的是对象的一致性哈希码(Identity Hash Code),这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<font color=\'red\'>当一个对象**已经计算过一致性哈希码后，它就再也无法进入偏向锁状态**了；而当一个对象当前**正处于偏向锁状态**，又收到需要计算其一致性哈希码请求时，它的**偏向状态会被立即撤销，并且锁会膨胀为重量级锁**。在重量级锁的实现中，对象头指向了重量级锁的位置，代表**重量级锁的Object Monitor类里有字段可以记录非加锁状态（标志位为“0I”)下的Mark Word**，其中自然可以存储原来的哈希码</font>\r\n\r\n\r\n\r\n- <font color=\'cornflowerblue\'>在无锁状态下</font>，Mark Word中可以存储对象的identity hash code值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。\r\n- <font color=\'cornflowerblue\'>对于偏向锁</font>，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。<font color=\'red\'>如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁，将直接升级为轻量级锁</font>。因为如果可以的话，那Mark Word中的identity hash code必然会被偏向线程ld给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。<font color=\'red\'>已经是偏向锁后计算哈希值，那么会直接升级为重量级锁</font>，因为hash的标志位已经被覆盖，轻量级锁是复制原MarkWord，但是此时原MarkWord已经没有hash标志位了\r\n\r\n- <font color=\'cornflowerblue\'>升级为轻量级锁时</font>，JVM会<font color=\'red\'>在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝</font>，该拷贝中可以包含identity hash code，所以<font color=\'red\'>轻量级锁可以和identity hash code共存</font>，哈希码和GC年龄自然保存在此，**释放锁后会将这些信息写回到对象头。**\r\n\r\n- <font color=\'cornflowerblue\'>升级为重量级锁后</font>，Mark Word保存的重量级锁指针，代表<font color=\'red\'>重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word</font>，**锁释放后也会将信息写回到对象头**\r\n\r\n\r\n\r\n**代码测试：**\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    /*//先睡眠5秒，保证开启偏向锁\r\n    try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n    Object o = new Object();\r\n    System.out.println(\"本应是偏向锁\");\r\n    System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n\r\n    o.hashCode();//没有重写，一致性哈希，重写后无效,当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；\r\n\r\n    synchronized (o){\r\n        System.out.println(\"本应是偏向锁，但是由于计算过一致性哈希，会直接升级为轻量级锁\");\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }*/\r\n\r\n    //先睡眠5秒，保证开启偏向锁\r\n    try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\r\n    Object o = new Object();\r\n\r\n    synchronized (o){\r\n        o.hashCode();//没有重写，一致性哈希，重写后无效\r\n        System.out.println(\"偏向锁过程中遇到一致性哈希计算请求，立马撤销偏向模式，膨胀为重量级锁\");\r\n        System.out.println(ClassLayout.parseInstance(o).toPrintable());\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 3种锁小总结\r\n\r\n\r\n\r\n![image-20230719230958459](image/JUC06.assets/image-20230719230958459.png)\r\n\r\n\r\n\r\nsynchronized锁升级过程总结：<font color=\'red\'>一句话，就是先自旋，不行再阻塞。</font>\r\n\r\n实际上是把之前的悲观锁（重量级锁）变成在一定条件下使用偏向锁以及使用轻量级（自旋锁CAS)的形式\r\n\r\n\r\n\r\nsynchronized.在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。\r\n\r\nJDK1.6之前synchronized使用的是重量级锁，<font color=\'red\'>JDK1.6之后进行了优化，拥有了无锁->偏向锁->轻量级锁->重量级锁的升级过程，而不是无论什么情况都使用重量级锁。</font>\r\n\r\n<font color=\'cornflowerblue\'>偏向锁</font>：适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法代码块则使用偏向锁。\r\n\r\n<font color=\'cornflowerblue\'>轻量级锁</font>：适用于竞争较不激烈的情况（这和乐观锁的使用范围类似），存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法/代码块执行时间很短的话，采用轻量级锁虽然会占用cu资源但是相对比使用重量级锁还是更高效。\r\n\r\n<font color=\'cornflowerblue\'>重量级锁</font>：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁\r\n\r\n\r\n\r\n**我的理解：**\r\n\r\n- 偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color=\'red\'>偏向锁中竞争一次失败后要么无锁，要么轻量锁</font>**）\r\n  - 偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁\r\n\r\n- 如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁\r\n\r\n\r\n\r\n\r\n\r\n### 锁升级总流程图\r\n\r\n<img src=\"image/JUC06.assets/image-20230719230958460.jpeg\" alt=\"img\" style=\"zoom:150%;\" />\r\n\r\n\r\n\r\n\r\n\r\n## 锁消除和锁粗化\r\n\r\n\r\n\r\n**缩消除（即逃逸分析里的同步省略）**\r\n\r\n如下面这段代码：锁加了与没加的作用是一样的，没有任何作用，所以JIT编译器就会替我们无视这把锁\r\n\r\n```java\r\nprivate static void m1(){\r\n    Object o = new Object();\r\n    synchronized (o){\r\n        System.out.println(\"come in synchronized + \\t\" + o.hashCode());\r\n    }\r\n}\r\npublic static void main(String[] args) {\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        new Thread(Main::m1,String.valueOf(i)).start();\r\n    }\r\n}\r\n```\r\n\r\n经过JIT编译器优化后的m1：\r\n\r\n```java\r\nprivate static void m1(){\r\n    Object o = new Object();\r\n    System.out.println(\"come in synchronized + \\t\" + o.hashCode());\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**锁粗化**\r\n\r\n假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能\r\n\r\n代码演示：\r\n\r\n```java\r\nstatic Object objectLock = new Object();\r\npublic static void main(String[] args) {\r\n    new Thread(() -> {\r\n        synchronized (objectLock) {\r\n            System.out.println(\"111111\");\r\n        }\r\n        synchronized (objectLock) {\r\n            System.out.println(\"222222\");\r\n        }\r\n        synchronized (objectLock) {\r\n            System.out.println(\"333333\");\r\n        }\r\n        synchronized (objectLock) {\r\n            System.out.println(\"444444\");\r\n        }\r\n    }, \"t1\").start();\r\n}\r\n```\r\n\r\n优化为：\r\n\r\n```java\r\nstatic Object objectLock = new Object();\r\npublic static void main(String[] args) {\r\n    new Thread(() -> {\r\n        synchronized (objectLock) {\r\n            System.out.println(\"111111\");\r\n            System.out.println(\"222222\");\r\n            System.out.println(\"333333\");\r\n            System.out.println(\"444444\");\r\n        }\r\n    }, \"t1\").start();\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 本章我的所有理解汇总\r\n\r\n\r\n\r\n- JDK5之前，只有重量级锁\r\n- 假如锁的竞争比较激烈的话，会导致性能下降\r\n- 重量级锁是用户态和内核态之间切换，容易导致阻塞\r\n- <font color=\'red\'>**所以我们就是为了尽量的减少内核态和用户态之间的切换，减少阻塞**</font>\r\n- \r\n- <font color=\'red\'>即通过对象头中的对象标记MarkWord来标记锁的信息</font>\r\n  - 偏行锁MarkWord指向的是偏向线程ID\r\n  - 轻量级锁MarkWord指向的是原MarkWord的拷贝LocalRecord\r\n  - 重量级锁MarkWord指向的是ObjectMonitor对象的地址\r\n- 每个Java对象都可以成为一把锁，天生自带内部锁或者叫Monitor锁\r\n- <font color=\'red\'>Monitor的本质是**依赖于底层操作系统的Mutex Lock（系统互斥量）**实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</font>\r\n- Monitor是由ObjectMonitor实现的，<font color=\'cornflowerblue\'>ObjectMonitor中的属性对应着对象头MarkWord中的部分信息</font>\r\n- Monitor即重量级锁，即synchronized                  <font color=\'red\'> Monitor       <= =>       重量级锁        <= => 重量级synchronized</font>\r\n- \r\n- 偏向锁出现竞争时，若竞争成功，则修改偏向线程ID，若竞争失败，会经过偏向锁的撤销，若原持有锁线程执行完毕，则设置为无锁状态重新偏向，若还在执行中，则升级为轻量锁（**<font color=\'red\'>偏向锁中竞争一次失败后要么无锁，要么轻量级锁</font>**）\r\n  - 偏向锁至多竞争失败一次，就进行锁撤销判断，锁撤销判断后要么无锁要么轻量级锁\r\n- 如果轻量锁还出现竞争，且自旋达到一定次数后仍然未得到锁，则升级为重量级锁\r\n- \r\n- <font color=\'cornflowerblue\'>已求过hashCode</font>，直接升级为轻量级锁\r\n- <font color=\'cornflowerblue\'>偏行锁时求hashCode</font>，直接升级为重量级锁\r\n- \r\n- 只有偏向锁是出现竞争才释放锁，<font color=\'red\'>轻量级锁和重量级锁都是用完锁就释放，释放锁时会将MarkWord信息写回对象头</font>\r\n\r\n\r\n\r\n<font color=\'red\'>**所有理解只是概念性总结，详细还得去上面看**</font>\r\n\r\n\r\n\r\n','image/JUC06.assets/image-20230719144812388.png','原创',0,_binary '',_binary '',_binary '\0','2023-07-22 22:10:35',NULL,2022576839,'JUC06-无锁、偏向锁、轻量级锁、重量级锁，synchronized锁升级',NULL,NULL,'0'),(1682755170179510273,'JUC07-AQS（AbstractQueuedSynchronizer）及源码解读','[TOC]\r\n\r\n\r\n\r\n\r\n\r\n# JUC07\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- <font color=\'red\'>AQS</font>\r\n\r\n\r\n\r\n\r\n\r\n# ==AQS（AbstractQueuedSynchronizer）==\r\n\r\n\r\n\r\n## AQS理论知识\r\n\r\n\r\n\r\n### AQS是什么？\r\n\r\nsince jdk1.5\r\n\r\n字面意思：抽象的队列同步器\r\n\r\n\r\n\r\n### 锁和同步器的关系\r\n\r\n\r\n\r\n- 锁，面向锁的使用者\r\n  - 定义了程序员和锁交互的依层APL，隐藏了实现细节，你调用即可。\r\n- 同步器，面向锁的实现者\r\n  - Java并发大神DougLee，提出统一规范并简化了锁的实现，<font color=\'red\'>将其抽象出来</font>屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的---<font color=\'red\'>公共基础部分</font>\r\n\r\n\r\n\r\n### 技术解释\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>**volatile+cas机制实现的锁模板，保证了代码的同步性和可见性，而AQS封装了线程阻塞等待挂起，解锁唤醒其他线程的逻辑。AQS子类只需根据状态变量，判断是否可获取锁，是否释放锁，使用LockSupport挂起、唤醒线程即可**</font>\r\n\r\n\r\n\r\n**是用来实现锁或者其它同步器组件的公共基础部分的抽象实现**，<font color=\'red\'>是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给\"谁\"的问题</font>\r\n\r\n​		<font color=\'red\'>通过内置的**CLH**（FIFO）队列的变体来完成资源获取线程的排队工作，将每条将要去抢占资源的线程封装成一个**Node**节点来实现锁的分配，有一个**int类变量表示持有锁的状态**(private volatile int state)，通过CAS完成对status值的修改(0表示没有，>=1表示阻塞)</font>\r\n\r\n\r\n\r\n​		抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种<font color=\'red\'>排队等候机制</font>。抢占资源失败的线程继续去等待（类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去<font color=\'red\'>候客区排队等候</font>)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。\r\n\r\n既然说到了<font color=\'red\'>排队等候机制</font>，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\r\n\r\n如果共享资源被占用，<font color=\'cornflowerblue\'>就需要一定的阻塞等待唤醒机制来保证锁分配</font>。这个机制主要用的是**CLH队列的变体实现**的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象(<font color=\'red\'>**Node**</font>)，<font color=\'cornflowerblue\'>通过CAS、自旋以及LockSupport.park()的方式</font>，维护state变量的状态，使并发达到同步的效果。\r\n\r\n\r\n\r\n![image-20230720150934258](image/JUC07.assets/image-20230720150934258.png)\r\n\r\n\r\n\r\n\r\n\r\n### 通过代码解释为什么JUC是最重要的基石\r\n\r\n- 和AQS有关的：\r\n\r\n![image-20230720151722007](image/JUC07.assets/image-20230720151722007.png)\r\n\r\n- 举例其中一个：ReentrantLock\r\n\r\n![image-20230720152330592](image/JUC07.assets/image-20230720152330592.png)\r\n\r\n\r\n\r\n\r\n\r\n## AQS体系架构\r\n\r\n\r\n\r\n### AQS内部架构图\r\n\r\n> **AQS内部架构图**\r\n>\r\n> ![image-20230720160803799](image/JUC07.assets/image-20230720155012947.png)\r\n>\r\n> 蓝色：继承线\r\n>\r\n> 红色：内部类\r\n>\r\n> 绿色：实现线\r\n>\r\n> ![image-20230720155012948](image/JUC07.assets/image-20230720155012948.png)\r\n\r\n\r\n\r\n\r\n\r\n### 详解AQS内部代码有什么？\r\n\r\n>![img](image/JUC07.assets/image-20230720155012949.png)\r\n>\r\n>\r\n>\r\n>\r\n\r\n\r\n\r\n\r\n\r\n### 双向CLH队列结构\r\n\r\n> ![image-20230720155642029](image/JUC07.assets/image-20230720155642029.png)\r\n>\r\n> \r\n>\r\n> AQS使用一个<font color=\'cornflowerblue\'>volatile的int类型</font>的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去枪占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。\r\n>\r\n> \r\n>\r\n> <font color=\'red\'>有阻塞就需要排队，实现排队必然需要队列</font>：state变量+CLH双端队列\r\n>\r\n> \r\n>\r\n> 双向链表中，<font color=\'red\'>**第一个节点为虚节点（也叫哨兵节点）**</font>，<font color=\'cornflowerblue\'>其实并不存储任何信息，只是占位。**首节点永远是虚拟节点**，第一个虚拟节点被回收后，队列中抢到锁的节点就会被修改为虚拟节点继续作为首节点head</font>\r\n> <font color=\'red\'>**真正的第一个有数据的节点，是从第二个节点开始的。**</font>\r\n\r\n\r\n\r\n\r\n\r\n### Node类内部结构\r\n\r\n>![img](image/JUC07.assets/image-20230720155642030.png)\r\n>\r\n>![image-20230720161923356](image/JUC07.assets/image-20230720161923356.png)\r\n\r\n\r\n\r\n\r\n\r\n## AQS源码解读\r\n\r\n\r\n\r\n### AQS ReentrantLock体系结构\r\n\r\n\r\n\r\nReentrantLock就是操作Sync这个继承于AQS的内部类，来对外展现两个分支：**FiarSync**和**NonfairSync**\r\n\r\n\r\n\r\n> 从ReentrantLock开始解读源码：\r\n>\r\n> ![image-20230720163310350](image/JUC07.assets/image-20230720163310350.png)\r\n>\r\n> \r\n>\r\n> 通过ReentrantLock的源码来讲解公平锁和非公平锁\r\n>\r\n> ![image-20230720164240591](image/JUC07.assets/image-20230720164240591.png)\r\n>\r\n> ![image-20230720165754761](image/JUC07.assets/image-20230720165754761.png)\r\n>\r\n> \r\n>\r\n> \r\n>\r\n> \r\n>\r\n> **公平锁与非公平锁的tryAcquire()方法的区别**\r\n>\r\n> <font color=\'red\'>可以明显看出公平锁与非公平锁的ock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：\r\n> hasQueuedPredecessors()</font>\r\n> <font color=\'cornflowerblue\'>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</font>\r\n>\r\n> ```java\r\n> public final boolean hasQueuedPredecessors() {\r\n> // The correctness of this depends on head being initialized\r\n> // before tail and on head.next being accurate if the current\r\n> // thread is first in queue.\r\n> Node t = tail; // Read fields in reverse initialization order\r\n> Node h = head;\r\n> Node s;\r\n> return h != t &&\r\n>   ((s = h.next) == null || s.thread != Thread.currentThread());\r\n> }\r\n> ```\r\n>\r\n> \r\n>\r\n> \r\n>\r\n> <font color=\'red\'>可以看出，ReentrantLock就是操作Sync这个继承于AQS的内部类，来对外展现两个分支：**FiarSync**和**NonfairSync**</font>\r\n\r\n\r\n\r\n### 非公平锁的lock()方法\r\n\r\n\r\n\r\n> ![image-20230720173114488](image/JUC07.assets/image-20230720173114488.png)\r\n>\r\n> <font color=\'cornflowerblue\'>无论是公平锁还是非公平锁</font>，<font color=\'red\'>调用lock()方法最终都会调用**acquire()**方法</font>\r\n>\r\n> \r\n>\r\n> **非公平锁的lock()方法源码：**\r\n>\r\n> ![image-20230720174949264](image/JUC07.assets/image-20230720174949264.png)\r\n\r\n\r\n\r\n### acquire()方法流程\r\n\r\n\r\n\r\n> **acquire()源码：** \r\n>\r\n> ```java\r\n> public final void acquire(int arg) {\r\n> if (!tryAcquire(arg) &&\r\n>   acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\r\n>   selfInterrupt();\r\n> }\r\n> ```\r\n>\r\n> \r\n>\r\n> \r\n>\r\n> ![image-20230720175825373](image/JUC07.assets/image-20230720175825373.png)\r\n>\r\n> \r\n>\r\n> <font color=\'cornflowerblue\'>**acquire()三条流程**</font>\r\n>\r\n> - 调用tryAcquire()\r\n>   - 尝试获得锁，或执行可重入操作\r\n>\r\n> - 调用addWaiter()           -->           enq入队操作\r\n>   - 队列内无节点则创建哨兵节点后入队，有节点则直接入队\r\n>\r\n> - 调用acquireQueued()           -->           调用cancelAcquire()\r\n>   - 再次尝试1 tryAcquire()，如果失败则修改它的前一个节点的waitState为SIGNAL（-1）后进入阻塞，等待被唤醒\r\n>\r\n> \r\n\r\n\r\n\r\n\r\n\r\n### 三个线程从lock()方法开始源码分析\r\n\r\n\r\n\r\n一共三个线程A、B、C，<font color=\'red\'>即ABC形成等待队列</font>\r\n\r\n```java\r\n//非公平锁的lock()方法\r\nfinal void lock() {\r\n    if  (compareAndSetState(0, 1))//第一条线程进来，进行if判断compareAndSetState，state是0，CAS修改state为1成功\r\n        setExclusiveOwnerThread(Thread.currentThread());//修改占有锁的线程为当前线程\r\n    else\r\n        acquire(1);//后来的线程执行acquire()方法\r\n}\r\n```\r\n\r\n- 第一条线程A进来，进行if判断compareAndSetState，state是0，CAS修改state为1成功，并且修改占有锁的线程为当前线程A\r\n\r\n- 后来的线程B和C执行acquire(1)方法\r\n\r\n```java\r\n//公平锁和非公平锁的acquire()方法是同一个\r\npublic final void acquire(int arg) {\r\n    if (!tryAcquire(arg) &&\r\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\r\n        selfInterrupt();\r\n}\r\n//acquire()方法有3个流程\r\n//1 调用tryAcquire()\r\n//2 调用addWaiter()           -->           enq入队操作\r\n//3 调用acquireQueued()           -->           调用cancelAcquire()\r\n```\r\n\r\n- **<font color=\'cornflowerblue\'>1 调用tryAcquire(1)</font>**\r\n\r\n```java\r\n//非公平锁的nonfairTryAcquire()方法\r\nfinal boolean nonfairTryAcquire(int acquires) {\r\n    final Thread current = Thread.currentThread();\r\n    int c = getState();\r\n    if (c == 0) {//如果state==0，则自选修改state为1，并修改占有锁的线程为当前线程\r\n        if (compareAndSetState(0, acquires)) {\r\n            setExclusiveOwnerThread(current);\r\n            return true;\r\n        }\r\n    }\r\n    else if (current == getExclusiveOwnerThread()) {//判度胺当前占有锁的线程是否为当前线程，如果是，则将state+1\r\n        int nextc = c + acquires;\r\n        if (nextc < 0) // overflow\r\n            throw new Error(\"Maximum lock count exceeded\");\r\n        setState(nextc);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n- 先获得当前状态state，如果state==0，则自选修改state为1，并修改占有锁的线程为当前线程，返回true，acquire()方法结束\r\n- else if 判度胺当前占有锁的线程是否为当前线程，如果是，则将state+1并返回true，acquire()方法结束\r\n- 前面两个条件都不满足，则tryAcquire()方法失败，返回false\r\n  - <font color=\'red\'>（一般第一个线程A正在执行业务中，后来的线程该方法都是直接返回false）</font>\r\n  - 在上一层acquire()方法中对tryAcquire()的返回值取反，得到true，继续执行下一流程调用addWaiter()       -->         enq入队操作\r\n\r\n- \r\n- **<font color=\'cornflowerblue\'>2 调用addWaiter(Node.EXCLUSIVE)     -->      enq入队操作</font>**\r\n\r\n```java\r\n//加入等待线程的方法\r\n//参数Node.EXCLUSIVE的意思是独占锁，另一种锁位Node.SHARED共享锁\r\nprivate Node addWaiter(Node mode) {\r\n    Node node = new Node(Thread.currentThread(), mode);//先new一个新的节点用来装当前线程，模式为独占模式\r\n    // Try the fast path of enq; backup to full enq on failure\r\n    Node pred = tail;//定义一个节点pred为当前队列的尾节点\r\n    if (pred != null) {//不为null，说明不是第一个要进入等待队列的线程，第一个线程为null直接跳过执行下面的enq(node)\r\n        node.prev = pred;\r\n        if (compareAndSetTail(pred, node)) {\r\n            pred.next = node;\r\n            return node;\r\n        }\r\n    }\r\n    enq(node);//队列中无节点才会执行enq()方法\r\n    return node;\r\n}\r\n\r\n	//内部方法：enq(node)\r\n	private Node enq(final Node node) {\r\n        for (;;) {\r\n            Node t = tail;\r\n            if (t == null) { // Must initialize//第一次入队时尾节点t为空\r\n                if (compareAndSetHead(new Node()))//双向链表中，第一个节点为虚节点（也叫哨兵节点）\r\n                    tail = head;\r\n            } else {//不是第一次入队，尾节点t不为空\r\n                node.prev = t;//将当前线程的节点的前置节点设为之前的尾节点\r\n                if (compareAndSetTail(t, node)) {//CAS将当前队列的尾节点设置为当前线程的节点node\r\n                    t.next = node;//设置之前的尾节点t的下一个节点为当前线程的节点node\r\n                    return t;\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n- 先new一个新的节点用来装当前线程，模式为独占模式\r\n\r\n- 定义一个节点pred为当前队列的尾节点\r\n\r\n- **<font color=\'cornflowerblue\'>第一次入队：</font>**我们先看pred即当前队列的尾节点为null的情况，即是第一个入队的线程B，直接跳到下面enq()方法\r\n\r\n- **<font color=\'cornflowerblue\'>第二次及后续入队：</font>**pred即当前队列的尾节点不为null，说明C不是第一个要进入等待队列的线程\r\n\r\n  - 设置当前入队线程C的节点node的前置节点prev为当前队列的尾节点pred，也就是B\r\n  - CAS更换队列的尾节点B为当前入队线程C的节点node\r\n  - 设置之前的尾节点pred的下一个节点为当前线程C的节点node\r\n  - 返回acquire()方法\r\n\r\n- \r\n\r\n- 于是到了enq(node)入队操作：<font color=\'cornflowerblue\'>**第一次入队**</font>，后续入队不会进入enq()方法了，已经返回了\r\n\r\n  - 在一个for死循环中，先定义一个t节点为队列的尾节点\r\n\r\n  - 如果t尾节点是空，现在B是第一次入队，所以就是null，于是进入if语句\r\n\r\n    - CAS将当前队列的头节点设置为一个空节点，即<font color=\'red\'>虚拟节点（也叫哨兵节点）</font>,并设置尾节点也为这个虚节点\r\n\r\n    - > 双向链表中，<font color=\'red\'>第一个节点为虚节点（也叫哨兵节点）</font>，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。\r\n\r\n  - 设置好队列头节点后，进入第二次for循环，第二次for循环将会进入else语句\r\n\r\n    - 进入else之前会重新设置当前尾节点t，也就是if语句中设置的虚拟节点\r\n    - 将当前线程B的节点node的前置节点设为之前的尾节点即虚拟节点\r\n    - CAS将当前队列的尾节点设置为当前线程B的节点node\r\n    - 设置之前的尾节点t的下一个节点为当前线程B的节点node\r\n\r\n\r\n- \r\n\r\n- >第一个等待线程B入队：\r\n  >\r\n  >![image-20230720210956445](image/JUC07.assets/image-20230720210956445.png)\r\n  >\r\n  >第二次及后续入队：\r\n  >\r\n  >![image-20230720210939243](image/JUC07.assets/image-20230720210956446.png)\r\n\r\n- \r\n\r\n- **<font color=\'cornflowerblue\'>3 调用acquireQueued() 	          --> 		          调用cancelAcquire()</font>**\r\n\r\n```java\r\n//acquireQueued(node, 1)\r\nfinal boolean acquireQueued(final Node node, int arg) {\r\n    boolean failed = true;\r\n    try {\r\n        boolean interrupted = false;\r\n        for (;;) {\r\n            final Node p = node.predecessor();//该方法为设置前置节点\r\n            if (p == head && tryAcquire(arg)) {\r\n                setHead(node);\r\n                p.next = null; // help GC\r\n                failed = false;\r\n                return interrupted;\r\n            }\r\n            if (shouldParkAfterFailedAcquire(p, node) &&\r\n                parkAndCheckInterrupt())	//该方法是调用pork()方法阻塞线程\r\n                interrupted = true;\r\n        }\r\n    } finally {\r\n        if (failed)\r\n            cancelAcquire(node);\r\n    }\r\n}\r\n	\r\n	//内部方法shouldParkAfterFailedAcquire()：设置当前节点的前置节点的waitState\r\n	private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\r\n        int ws = pred.waitStatus;\r\n        if (ws == Node.SIGNAL)     //等于-1才返回true      \r\n            return true;\r\n        if (ws > 0) {        //大于0的情况只有1，即CANCELED，撤销操作 \r\n            do {\r\n                node.prev = pred = pred.prev;\r\n            } while (pred.waitStatus > 0);\r\n            pred.next = node;\r\n        } else {           \r\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\r\n        }\r\n        return false;\r\n    }\r\n```\r\n\r\n- **<font color=\'cornflowerblue\'>当进入的node时B节点时：</font>**\r\n\r\n  - 先定义是否中断为false\r\n\r\n  - 第一次进入for死循环\r\n\r\n    - 设置节点p为当前节点node的前置节点，即B的前置节点，为虚拟节点\r\n    - if语句：p是否等于head，虚拟节点就是head节点，第二个判断是再次尝试tryAcquire()，一般也是false\r\n    - 第二个if：设置当前节点的前置节点的waitState，进入方法体：\r\n      - 此时第一次for循环前置节点也就是虚拟节点的waitStatus=0，此时会被设置为SIGNAL（-1），返回false\r\n\r\n  - 第二次for循环：\r\n\r\n    - 第一个if一般为false\r\n\r\n    - 第二个if：设置当前节点的前置节点的waitState，进入方法体：\r\n\r\n      - 此时第二次for循环前置节点也就是虚拟节点的waitStatus= -1，返回true\r\n\r\n    - 第二个if的第二个判断条件，进入方法体parkAndCheckInterrupt()，调用pork()方法阻塞线程\r\n\r\n      - **<font color=\'red\'>由后一个节点设置它的前置节点的waitState为 -1</font>**\r\n\r\n      - >```java\r\n        >//内部方法parkAndCheckInterrupt：阻塞线程\r\n        >private final boolean parkAndCheckInterrupt() {\r\n        >   //线程挂起，程序不会继续向下执行\r\n        >   LockSupport.park(this);\r\n        >   //根据park方法API猫述，程序在下述三种情沉会继续向下执行\r\n        >   //1.被unpark\r\n        >   //2.被中断(interrupt)\r\n        >   //3.其他术合逻每的返回才会继续向下行\r\n        >   //因上述三种清沉程序执行至此，返回当前线程的中断状态，并清空中断状态\r\n        >   //如果由于被中断，该方法会返回true\r\n        >   return Thread.interrupted();//一般被unpark返回false\r\n        >}\r\n        >```\r\n\r\n- \r\n\r\n- **<font color=\'cornflowerblue\'>当进入的node时C节点时：</font>**\r\n\r\n  - 和节点B时一致，只需将虚拟节点改为B，B节点改为C节点\r\n\r\n- \r\n\r\n- >B和C都被设置waitStatus为-1，且都被阻塞后：\r\n  >\r\n  >![image-20230720224343766](image/JUC07.assets/image-20230720224343766.png)\r\n\r\n\r\n\r\n\r\n\r\n### 第一个线程unlock()后第二个线程上位源码解析\r\n\r\n\r\n\r\n**A线程unlock()**\r\n\r\n```java\r\n//unlock()方法都一样\r\npublic void unlock() {\r\n    sync.release(1);\r\n}\r\n```\r\n\r\n-  unlock()只调用一个release(1)方法，参数为1\r\n\r\n```java\r\n//release(1)\r\npublic final boolean release(int arg) {\r\n    if (tryRelease(arg)) {\r\n        Node h = head;\r\n        if (h != null && h.waitStatus != 0)\r\n            unparkSuccessor(h);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n- if条件判断进入tryRelease(1)方法体：\r\n\r\n  - >```java\r\n    >//if中方法：tryRelease(1)\r\n    >protected final boolean tryRelease(int releases) {\r\n    >   int c = getState() - releases;//定义变量c为当前state - 1，也就是0\r\n    >   if (Thread.currentThread() != getExclusiveOwnerThread())//不是当前线程解锁则抛出异常\r\n    >       throw new IllegalMonitorStateException();\r\n    >   boolean free = false;\r\n    >   if (c == 0) {\r\n    >       free = true;\r\n    >       setExclusiveOwnerThread(null);\r\n    >   }\r\n    >   setState(c);\r\n    >   return free;\r\n    >}\r\n    >```\r\n\r\n  - 定义变量c为当前state - 1，也就是0\r\n\r\n  - 第一个if：不是当前线程解锁则抛出异常（一般不出现）\r\n\r\n  - 定义变量free=false\r\n\r\n  - 第二个if：c==0，进入if：\r\n\r\n    - 设置free=true\r\n\r\n  - 设置state=c=0，表示现在锁空闲，返回free=true\r\n\r\n- \r\n\r\n- 所以进入release(1)的if语句：\r\n\r\n  - 定义节点h为头节点，这里的头节点时虚拟节点\r\n\r\n  - if语句：有等待线程的话，头节点都不为空，且等待节点的前置节点的waitState已经被设置为 -1，这里是B的前置节点虚拟节点\r\n\r\n    - unparkSuccessor(h)：\r\n\r\n      - >```java\r\n        >//内部方法unparkSuccessor()\r\n        >private void unparkSuccessor(Node node) {\r\n        >   int ws = node.waitStatus;\r\n        >   if (ws < 0)\r\n        >       compareAndSetWaitStatus(node, ws, 0);\r\n        >   Node s = node.next;\r\n        >   if (s == null || s.waitStatus > 0) {\r\n        >       s = null;\r\n        >       for (Node t = tail; t != null && t != node; t = t.prev)\r\n        >           if (t.waitStatus <= 0)\r\n        >               s = t;\r\n        >   }\r\n        >   if (s != null)\r\n        >       LockSupport.unpark(s.thread);\r\n        >}\r\n        >```\r\n\r\n      - ws<0：设置头节点的waitState为0\r\n\r\n      - 定义一个节点s为头节点的下一个节点，即等待的第一个节点，这里是B\r\n\r\n      - s一般不为空，跳过一个if进入下一个if语句if (s != null)：\r\n\r\n        - 接触节点s的线程阻塞，这里是解除B\r\n\r\n- \r\n\r\n- **<font color=\'cornflowerblue\'>这里返回lock()步骤中的3 acquireQueued()</font>**\r\n\r\n- >```java\r\n  >//lock()中的acquire()中的3 acquireQueued(node, 1)\r\n  >final boolean acquireQueued(final Node node, int arg) {\r\n  >   boolean failed = true;\r\n  >   try {\r\n  >       boolean interrupted = false;\r\n  >       for (;;) {\r\n  >           final Node p = node.predecessor();//该方法为设置前置节点\r\n  >           if (p == head && tryAcquire(arg)) {\r\n  >               setHead(node);//设置队列头节点为当前节点\r\n  >               p.next = null; // help GC\r\n  >               failed = false;\r\n  >               return interrupted;\r\n  >           }\r\n  >           if (shouldParkAfterFailedAcquire(p, node) &&\r\n  >               parkAndCheckInterrupt())	//该方法是调用pork()方法阻塞线程\r\n  >               interrupted = true;\r\n  >       }\r\n  >   } finally {\r\n  >       if (failed)\r\n  >           cancelAcquire(node);\r\n  >   }\r\n  >}\r\n  >```\r\n\r\n- 这里的parkAndCheckInterrupt()会返回false，然后再次进入for循环\r\n\r\n- 此时，第一个if语句处：B的前置节点p就是为头节点并且这里尝试tryAcquire()将会成功\r\n\r\n  - 这里是进入**<font color=\'cornflowerblue\'>lock()步骤中的1 tryAcquire()</font>**，state已经是0，所以尝试成功，返回true\r\n\r\n- 进入这个if的判断体：\r\n\r\n  - setHead(node)：设置队列头节点为当前节点B，并将B的thread设置为null，B的前置节点为null，即将B设置为新的虚拟头节点\r\n\r\n    - >```java\r\n      >private void setHead(Node node) {\r\n      >   head = node;\r\n      >   node.thread = null;\r\n      >   node.prev = null;\r\n      >}\r\n      >```\r\n\r\n  - 前置节点p的下一个节点为null（p即虚拟节点，帮助GC），此时虚拟节点已经没有引用了\r\n\r\n  - failed = false;，返回interrupted=false，acquire()方法接收到false，无法进入if，方法结束，B成功上位\r\n\r\n- \r\n\r\n- >![image-20230721001309714](image/JUC07.assets/image-20230721001309714.png)\r\n\r\n\r\n\r\n\r\n\r\n### cancelAcquire()撤销节点\r\n\r\n\r\n\r\n```java\r\nprivate void cancelAcquire(Node node) {\r\n    // Ignore if node doesn\'t exist\r\n    if (node == null)\r\n        return;\r\n    node.thread = null;\r\n    // 跳过所有已经是被撤销的节点\r\n    Node pred = node.prev;\r\n    while (pred.waitStatus > 0)\r\n        node.prev = pred = pred.prev;\r\n	// 获取本被撤销节点  的前一个不是被撤销节点  的后一个节点\r\n    Node predNext = pred.next;\r\n    // 设置当前节点的waitState为CANCELLED（1）\r\n    node.waitStatus = Node.CANCELLED;\r\n	// 如果本被撤销节点刚好是尾节点的话，设置尾节点为它的前一个不是被撤销节点\r\n    if (node == tail && compareAndSetTail(node, pred)) {\r\n        compareAndSetNext(pred, predNext, null);\r\n    } else {// 被撤销节点不是尾节点\r\n        int ws;\r\n        //要求本被撤销节点  的前一个不是被撤销节点 不是首节点和虚拟节点，且waitStatus能小于0\r\n        if (pred != head &&\r\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\r\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\r\n            pred.thread != null) {\r\n            //开始队列的删除本节点和连接前后节点操作\r\n            Node next = node.next;\r\n            if (next != null && next.waitStatus <= 0)\r\n                //设置 的前一个不是被撤销节点  的后一个节点为本节点的后一个节点（去除了本节点之前的连续的被撤销节点）\r\n                compareAndSetNext(pred, predNext, next);\r\n        } else {\r\n            unparkSuccessor(node);\r\n        }\r\n        node.next = node; // help GC\r\n    }\r\n}\r\n```\r\n\r\n- 找到本被撤销节点  的前一个不是被撤销节点pred\r\n  - 如果本被撤销节点原本就是队列的tail，则设置pred为tail，cancel结束，队列等待唤醒\r\n  - 如果本被撤销节点 不是tail，则只要pred不是head且waitState能够 < 0，则连接pred和node.next，cancel结束，队列等待唤醒\r\n    - pred是head，则进入unparkSuccessor()，该方法会唤醒传入节点的后一个waitState < 0的节点，即唤醒node的后一个waitState < 0的节点\r\n\r\n\r\n\r\n\r\n\r\n## 源码解读小总结\r\n\r\n\r\n\r\n整个ReentrantLock的加锁过程，可以分为三个阶段：\r\n\r\n- 1、尝试加锁；\r\n- 2、加锁失败，线程入队烈\r\n- 3、线程入队列后，进入阻塞状态。\r\n\r\n对应下面①②③三部分。\r\n\r\n\r\n\r\n①\r\n\r\ntryAcquire方法，尝试获取锁。以下几种情况，会导致获取锁失败：\r\n\r\n- 1、锁已经被其它线程获取：\r\n- 2、锁没有被其他线程获取，但当前线程需要排队：\r\n- 3、cas失败（可过程中已经有其他线程拿到锁了）\r\n\r\n锁为自由状态(c==0)，并不能说明可以立刻执行cas获取锁，因为可能在当前线程获取锁之前，已经有其他线程在排队了\r\n\r\n如果是公平锁，必须道循先来后到原则获取锁。所以还要调用**hasQueuedPredecessors()**方法，查看自己是否需要排队。\r\n\r\n\r\n\r\n②\r\n\r\n将当前线程封装成Nod对，并入排队队列中。\r\n模据排队队列是否执行过初始化，执行1、2不同处理方式\r\n\r\n- 1：表示排队队列不为空，即之前己经初始化过了，此时只需将新的node加入排队队列床尾即阿。\r\n- 2：表示排队队列为空，需执行队列初始化。enq会初始化一个空的Node,作为排队队列的head,然后将需要排队的线程，作为head的next节点插入。\r\n  - 队列尚未初始化，调用这个eng()方法。该方法生成一个空的Node节点(new Node()，虚拟节点/哨兵节点)，描入到AQS队列头部，然后将参数node，作为其后继节点，插入队列，方法执行完华。\r\n\r\n\r\n\r\n③\r\n\r\n整个aqs的核心和难点之一\r\n注意这里使用了or()：\r\n首先判新node的前辈节点，<font color=\'red\'>是不是head</font>，如果是，说明它是下一个可以获得锁的线程，则调用一次tryAcquire，尝试获取锁，\r\n\r\n- 若获取到，则将差表关系重新谁护下(node设置为head,之前的head从差表移出)，然后返回如果node的前节点不是head,\r\n\r\n- 若获取锁失败，再判断复前辈节点的waitState，是不是SIGNAL,\r\n\r\n  - 如果是，则兰前浅程调用Park,进入阻塞状态\r\n\r\n  - 如不是：\r\n\r\n    - 1、==0,则设置为SIGNAL；\r\n\r\n    - 2、>0（==1），则素示前蜚节点已经被取消了，将取消的节点，从队列移出，重新淮护下排队羡关系：\r\n\r\n- 然后再次运入for循环，上面的操作重新执行一遍。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','image/JUC07.assets/image-20230720150934258.png','原创',8,_binary '',_binary '',_binary '\0','2023-07-22 22:11:11',NULL,2022576839,'JUC07-AQS（AbstractQueuedSynchronizer）及源码解读',NULL,NULL,'0');
INSERT INTO `t_blog` VALUES (1682755393240985602,'JUC08- 读写锁ReentrantReadWriteLock、邮戳锁StampedLock、JUC总结','[TOC]\r\n\r\n\r\n\r\n# JUC08\r\n\r\n## 课程任务概览\r\n\r\n**本部分包含：**\r\n\r\n- 读写锁ReentrantReadWriteLock\r\n- 邮戳锁StampedLock\r\n- JUC总结\r\n\r\n\r\n\r\n\r\n\r\n# 读写锁ReentrantReadWriteLock\r\n\r\n\r\n\r\n## 读写锁的意义和特点\r\n\r\n\r\n\r\n读写锁定义为：<font color=\'cornflowerblue\'>一个资源能够被<font color=\'red\'>多个读线程</font>访问，或者被<font color=\'red\'>一个写线程</font>访问，但是线程间不能同时存在读写线程。</font>\r\n\r\n\r\n\r\n<font color=\'red\'>**读写互斥，读读共享，读没有完成时候其它线程写锁无法获得**</font>\r\n\r\n\r\n\r\n<font color=\'red\'>它只允许读读共存，而读写和写写依然是互斥的</font>，大多实际场景是<font color=\'red\'>“读/读”线程间并不存在互斥关系，</font>\r\n\r\n只有\"读/写\"线程或\"写/写\"线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。\r\n\r\n一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁（<font color=\'cornflowerblue\'>切菜还是拍蒜选一个</font>）。\r\n\r\n也即<font color=\'cornflowerblue\'>一个资源可以被多个读操作访问          或           一个写操作访问，</font>但两者不能同时进行。\r\n\r\n<font color=\'red\'>只有在读多写少情景之下，读写锁才具有较高的性能体现。</font>\r\n\r\n\r\n\r\n## 读写锁缺点\r\n\r\n缺点：\r\n\r\n- 写锁饥饿问题\r\n  - 下面邮戳锁解决（StampedLock）\r\n- 注意锁降级\r\n\r\n\r\n\r\n## 读写锁锁降级\r\n\r\n\r\n\r\nReentrantReadWriteLock锁降级：将写入锁降级为读锁（类似Linux.文件读写权限理解，就像写权限要高于读权限一样），<font color=\'red\'>锁的严言程度变强叫做升级，反之叫做降级。</font>\r\n\r\n| 特性       | 特性说明                                                     |\r\n| ---------- | ------------------------------------------------------------ |\r\n| 公平性选择 | 支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平 |\r\n| 重进入     | 该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。<br/>而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁 |\r\n| 锁降级     | 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁 |\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>写锁的降级，降级成为了读锁</font>\r\n\r\n- 1如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。\r\n- 2规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序。\r\n- 3如果释放了写锁，那么就完全转换为读锁。\r\n\r\n\r\n\r\n锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。\r\n\r\n如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。\r\n\r\n![image-20230722160826863](image/JUC08.assets/image-20230722160826863.png)\r\n\r\n\r\n\r\n<font color=\'red\'>重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁，**但是，从读锁定升级到写锁是不可能**的。</font>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 锁降级的分析及好处\r\n\r\n\r\n\r\n以下面这段使用锁降级的代码为例：\r\n\r\n```java\r\nclass CachedData {\r\n    Object data;\r\n    volatile boolean cacheValid;\r\n    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\r\n\r\n    void processCachedData() {\r\n        rwl.readLock().lock();\r\n        if (!cacheValid) {\r\n            // Must release read lock before acquiring write lock\r\n            rwl.readLock().unlock();\r\n            rwl.writeLock().lock();\r\n            try {\r\n                // Recheck state because another thread might have\r\n                // acquired write lock and changed state before we did.\r\n                if (!cacheValid) {\r\n                    data = ...\r\n                    cacheValid = true;\r\n                }\r\n                // Downgrade by acquiring read lock before releasing write lock\r\n                rwl.readLock().lock();\r\n            } finally {\r\n                rwl.writeLock().unlock(); // Unlock write, still hold read\r\n            }\r\n        }\r\n\r\n        try {\r\n            use(data);\r\n        } finally {\r\n            rwl.readLock().unlock();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**<font color=\'cornflowerblue\'>锁降级的好处：</font>**\r\n\r\n1代码中声明了一个volatile类型的cacheValid变量，保证其可见性。\r\n\r\n2首先获取读锁，如果cache不可用，则释放读锁。获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在<font color=\'red\'>释放写锁前**立刻抢夺获取读锁**</font>；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，<font color=\'cornflowerblue\'>**目的是保证数据可见性。**</font>\r\n\r\n**总结：一句话，同一个线程自己特有写锁时再去拿读锁，其本质相当于<font color=\'red\'>重入</font>。**\r\n\r\n\r\n\r\n<font color=\'red\'>如果违背锁降级的步骤，如果违背锁降级的步骤，如果违背锁降级的步骤</font>\r\n\r\n如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。\r\n\r\n<font color=\'yellowgreen\'>如果遵循锁降级的步蹀</font>\r\n\r\n线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。\r\n\r\n\r\n\r\n## 写锁和读锁是互斥的\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>写锁和读锁是互斥的</font>（这里的互斥是<font color=\'red\'>指线程间的互斥</font>，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁)，这是因为读写锁要<font color=\'red\'>保持写操作的可见性</font>。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。\r\n\r\n因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：\r\n\r\n<font color=\'orange\'>读锁结束，写锁有望；写锁独占，读写全堵</font>（线程间，同一个线程可发生锁降级）\r\n\r\n如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即ReentrantReadWriteLock<font color=\'red\'>读的过程中不允许写</font>，<font color=\'cornflowerblue\'>只有等待线程都释放了读锁，当前线程才能获取</font><font color=\'red\'>写锁，也就是写入必须等待</font>\r\n\r\n\r\n\r\n\r\n\r\n<font color=\'cornflowerblue\'>分析StampedLock（后面详细讲解）</font>，会发现它**改进之处**在于：\r\n\r\n<font color=\'red\'>读的过程中也允许获取写锁介入（相当牛B,读和写两个操作也让你“共享”（注意引号））</font>，这样会导致我们读的数据就可能不一致\r\n\r\n所以，需要额外的方法来<font color=\'red\'>判断读的过程中是否有写入</font>，这是一种<font color=\'red\'>乐观的读锁，O(∩_∩)O哈哈~。</font>\r\n\r\n显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\r\n\r\n\r\n\r\n\r\n\r\n# ==邮戳锁StampedLock==\r\n\r\n\r\n\r\n## 分析邮戳锁的由来（锁的发展）\r\n\r\n\r\n\r\n注意区分：\r\n\r\n- 锁升级（synchronized）\r\n- 锁发展和AQS（lock）\r\n\r\n\r\n\r\n![image-20230722192651080](image/JUC08.assets/image-20230722192651080.png)\r\n\r\n\r\n\r\n**锁解饿问题**\r\n\r\nReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，\r\n\r\n假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了；<font color=\'red\'>因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写</font>\r\n\r\n\r\n\r\n如何解决锁解饿问题？\r\n\r\n- 采取公平锁的方式可以一定程度上缓解这个问题\r\n  - 但是！！！公平锁是以牺牲系统吞吐量为代价的\r\n- <font color=\'red\'>StampedLock类的乐观读锁</font>\r\n\r\n\r\n\r\n## 邮戳锁的读写方式\r\n\r\n\r\n\r\n- 所有<font color=\'red\'>获取锁</font>的方法，都返回一个邮戳(Stamp),Stamp为零表示获取失败，其余都表示成功；\r\n- 所有<font color=\'red\'>释放锁</font>的方法，都需要一个邮戳(Stamp),这个Stamp必须是<font color=\'cornflowerblue\'>和成功获取锁时得到的Stamp一致</font>\r\n- StampedLock<font color=\'red\'>是不可重入的，危险</font>（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）\r\n- StampedLock有三种访问模式：\r\n  - ①Reading(读模式悲观)：功能和ReentrantReadWriteLock的读锁类似\r\n  - ②Writing(写模式)：功能和ReentrantReadWriteLockl的写锁类似\r\n  - **③Optimistic reading(乐观读模式)**：无锁机制，类似于数据库中的乐观锁，支持读写并发，<font color=\'red\'>**很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式**</font>\r\n\r\n\r\n\r\n**<font color=\'red\'>StampedLock = ReentrantReadWriteLock（带戳记版） + 乐观读模式</font>**\r\n\r\n\r\n\r\n## 邮戳锁的缺点\r\n\r\n\r\n\r\n- StampedLock<font color=\'red\'>不支持重入</font>，没有Re开头\r\n- StampedLock的悲观读锁和写锁都<font color=\'red\'>不支持条件变量(Condition)</font>,这个也需要注意。\r\n- 使用StampedLock<font color=\'red\'>一定不要调用中断操作</font>，即不要调用interrupt()方法\r\n  - 会影响性能和造成意外bug\r\n\r\n\r\n\r\n## 传统的读写方式\r\n\r\n\r\n\r\n该方式和ReentrantReadWriteLock几乎一样，只是多了一个返回戳记的形式\r\n\r\n\r\n\r\n**案例：**\r\n\r\n```java\r\npublic class StampedLockDemo {\r\n    static int number = 37;\r\n    static StampedLock stampedLock = new StampedLock();\r\n    public void write(){\r\n        long stamped = stampedLock.writeLock();\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"写线程准备修改\");\r\n        try {\r\n            number = number + 13;\r\n        }finally {\r\n            stampedLock.unlockWrite(stamped);\r\n        }\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"写线程结束修改\");\r\n    }\r\n    //悲观读，读没有完成时候写锁无法获得锁\r\n    public void read(){\r\n        long stamped = stampedLock.readLock();\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\" come in readlock code block，4 seconds continue...\");\r\n        for (int i = 0; i < 4; i++) {\r\n            try {TimeUnit.SECONDS.sleep(1);} catch (InterruptedException e) {e.printStackTrace();}\r\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\" 正在读取中......\");\r\n        }\r\n        int result = number;\r\n        try {\r\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\" 获得成员变量值result：\"+result);\r\n            System.out.println(\"写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥\");\r\n            System.out.println(Thread.currentThread().getName() + \"\\t 读线程结束\");\r\n        } finally {\r\n            stampedLock.unlockRead(stamped);\r\n        }\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\" finally value: \"+result);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        StampedLockDemo resource = new StampedLockDemo();\r\n        /**\r\n         * 传统版\r\n         */\r\n        new Thread(resource::read,\"readThread\").start();\r\n\r\n        //暂停几秒钟线程\r\n        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"----come in\");\r\n            resource.write();\r\n        },\"writeThread\").start();\r\n\r\n        //暂停几秒钟线程\r\n        try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); }\r\n\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"number:\" +number);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 乐观读功能\r\n\r\n\r\n\r\n**案例：**\r\n\r\n```java\r\npublic class StampedLockDemo {\r\n    static int number = 37;\r\n    static StampedLock stampedLock = new StampedLock();\r\n    public void write(){\r\n        long stamped = stampedLock.writeLock();\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"写线程准备修改\");\r\n        try {\r\n            number = number + 13;\r\n        }finally {\r\n            stampedLock.unlockWrite(stamped);\r\n        }\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"写线程结束修改\");\r\n    }\r\n    //乐观读，读的过程中也允许获取写锁介入\r\n    public void tryOptimisticRead(){\r\n        long stamped = stampedLock.tryOptimisticRead();\r\n        int result = number;\r\n        //故意间隔4秒钟，很乐观认为读取中没有其它线程修改过number值，具体靠判断\r\n        System.out.println(\"4秒前stampedLock.validate方法值(true无修改，false有修改)\"+\"\\t\"+stampedLock.validate(stamped));\r\n        for (int i = 0; i < 4; i++) {\r\n            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\r\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"正在读取... \"+i+\" 秒\" +\r\n                    \"后stampedLock.validate方法值(true无修改，false有修改)\"+\"\\t\"+stampedLock.validate(stamped));\r\n        }\r\n        if (!stampedLock.validate(stamped)){\r\n            System.out.println(\"有人修改过------有写操作\");\r\n            stamped = stampedLock.readLock();\r\n            try {\r\n                System.out.println(\"从乐观读 升级为 悲观读\");\r\n                result = number;\r\n                System.out.println(\"重新悲观读后result：\"+result);\r\n            }finally {\r\n                stampedLock.unlockRead(stamped);\r\n            }\r\n        }\r\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\" finally value: \"+result);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        StampedLockDemo resource = new StampedLockDemo();\r\n        /**\r\n         * 乐观版\r\n         */\r\n        new Thread(resource::tryOptimisticRead,\"readThread\").start();\r\n\r\n        //暂停6秒钟线程\r\n        try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        new Thread(() -> {\r\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"----come in\");\r\n            resource.write();\r\n        },\"writeThread\").start();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 总回顾\r\n\r\n\r\n\r\n**注意区分：**\r\n\r\n- 锁升级（synchronized）\r\n- 锁发展和AQS（lock）\r\n\r\n\r\n\r\n**锁的种类：**\r\n\r\n- 1.悲观锁\r\n- 2.乐观锁\r\n- 3.自旋锁\r\n- 4.可重入锁（递归锁）\r\n- 5.写锁（独占锁）/读锁（共享锁）\r\n- 6.公平锁/非公平锁\r\n- 7.死锁\r\n- 8.偏向锁\r\n- 9.轻量锁\r\n- 10.重量锁\r\n- 11.邮戳（票据）锁\r\n\r\n\r\n\r\n**所有知识点：**\r\n\r\n- 1.CompletableFuture异步任务\r\n- 2.“锁”事儿\r\n  - 上面列举的那么多锁\r\n- 3.JMM\r\n- 4.synchronized及其锁升级\r\n- 5.CAS\r\n- 6.volatile\r\n- 7.LockSupport和线程中断\r\n- 8.AbstractQueuedSynchronizer\r\n- 9.ThreadLocal\r\n- 10.原子类Atomic及其增强类\r\n\r\n','image/JUC08.assets/image-20230722192651080.png','原创',4,_binary '',_binary '',_binary '\0','2023-07-22 22:12:04',NULL,2022576839,'JUC08- 读写锁ReentrantReadWriteLock、邮戳锁StampedLock、JUC总结',NULL,NULL,'0');
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_blog_tag_relation`
--

DROP TABLE IF EXISTS `t_blog_tag_relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog_tag_relation` (
  `id` bigint NOT NULL COMMENT 'id',
  `blog_id` bigint DEFAULT NULL COMMENT '博客id',
  `tag_id` bigint DEFAULT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `t_blog_id` (`blog_id`) USING BTREE,
  KEY `t_tag_id` (`tag_id`) USING BTREE,
  CONSTRAINT `t_blog_id` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `t_tag_id` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog_tag_relation`
--

LOCK TABLES `t_blog_tag_relation` WRITE;
/*!40000 ALTER TABLE `t_blog_tag_relation` DISABLE KEYS */;
INSERT INTO `t_blog_tag_relation` VALUES (1673368628201799681,1673367738707361794,1673367778305785857),(1673368628201799682,1673367738707361794,1673367800548179969),(1675516986353795073,1673371611320827905,1673367800548179969),(1675516986362183681,1673371611320827905,1673367880785215489),(1675518115624009730,1675518115531735041,1673367800548179969),(1675518115640786946,1675518115531735041,1673367880785215489),(1675523827653689345,1673369924304650242,1673367800548179969),(1675523827653689346,1673369924304650242,1673367818516578305),(1679024302202056705,1679024302076227586,1673367800548179969),(1679024302243999745,1679024302076227586,1678452659377434625),(1679025014222909442,1679025014147411970,1673367800548179969),(1679025014235492354,1679025014147411970,1678452659377434625),(1679025616365580289,1678452615425323010,1673367800548179969),(1679025616365580290,1678452615425323010,1678452659377434625),(1679026321763627010,1678454551474106369,1673367800548179969),(1679026321763627011,1678454551474106369,1678452659377434625),(1682752692805464066,1678729967006937089,1673367800548179969),(1682752692809658370,1678729967006937089,1678452673055059969),(1682753013854269441,1682752951065538561,1673367800548179969),(1682753013854269442,1682752951065538561,1678452673055059969),(1682753960567402498,1682753916854366210,1673367800548179969),(1682753960571596802,1682753916854366210,1678452673055059969),(1682754138493972481,1682754138464612354,1673367800548179969),(1682754138510749697,1682754138464612354,1678452673055059969),(1682754418342129665,1682754418308575233,1673367800548179969),(1682754418358906882,1682754418308575233,1678452673055059969),(1682754705593233410,1682754705568067585,1673367800548179969),(1682754705593233411,1682754705568067585,1678452673055059969),(1682755018047909890,1682755018022744066,1673367800548179969),(1682755018081464321,1682755018022744066,1678452673055059969),(1682755170204676097,1682755170179510273,1673367800548179969),(1682755170221453314,1682755170179510273,1678452673055059969),(1682755393291317250,1682755393240985602,1673367800548179969),(1682755393308094466,1682755393240985602,1678452673055059969),(1682756499241201666,1675526800714776577,1533670682262970370),(1689975880413097986,1673370844409118721,1673367800548179969),(1689975880421486593,1673370844409118721,1673367842851930114);
/*!40000 ALTER TABLE `t_blog_tag_relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_comment` (
  `id` bigint NOT NULL COMMENT 'id',
  `nickname` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '昵称',
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '内容',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像',
  `createTime` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建时间',
  `blog_id` bigint DEFAULT NULL COMMENT '博客id',
  `extends_commentId` bigint DEFAULT NULL COMMENT '继承父类评论的id',
  `administrator` bit(1) DEFAULT NULL COMMENT '是否为管理员评论',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `t_comment_t_blog` (`blog_id`) USING BTREE,
  CONSTRAINT `t_comment_t_blog` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (1675868596338708481,'spongehah','2635879218@qq.com','有疑问在这里问我哟','https://q2.qlogo.cn/headimg_dl?dst_uin=2635879218&spec=100','2023-07-03 22:06:24',1675526800714776577,NULL,_binary '\0'),(1678101660456480769,'Hah','2635879218@qq.com','测试邮件回复','/img/blogAvatar.jpg','2023-07-10 01:59:48',1675526800714776577,1675868596338708481,_binary ''),(1682768733694603265,'Hah','2635879218@qq.com','test','/img/blogAvatar.jpg','2023-07-22 23:05:05',1675526800714776577,1678101660456480769,_binary '');
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_tag` (
  `id` bigint NOT NULL COMMENT 'id',
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '名称',
  `count` int DEFAULT NULL COMMENT '计数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
INSERT INTO `t_tag` VALUES (1533670682262970370,'闲言碎语',NULL),(1673367778305785857,'Linux',NULL),(1673367800548179969,'Notes',NULL),(1673367818516578305,'Redis',NULL),(1673367842851930114,'SpringCloud',NULL),(1673367880785215489,'Nginx',NULL),(1678452659377434625,'JVM',NULL),(1678452673055059969,'JUC',NULL);
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` bigint NOT NULL COMMENT 'id',
  `nickname` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '昵称',
  `username` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户名',
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '密码',
  `email` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `avatar` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像',
  `type` int DEFAULT NULL COMMENT '类型',
  `createTime` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '创建时间',
  `editTime` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (2022576839,'Hah','admin','3acd0be86de7dcccdbf91b20f94a68cea535922d','2635879218@qq.com','/img/blogAvatar.jpg',NULL,'2023-5-4',NULL);
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-10-02 23:34:00
